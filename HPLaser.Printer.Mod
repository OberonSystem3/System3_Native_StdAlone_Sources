(* OBERON System 3, Release 2.2.

Copyright 1997 Team of the Institute of Computer Systems of ETH Zuerich,
ETH Center, CH-8092 Zuerich, e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be requested from the 
above-mentioned address, or downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Printer; (*	<><> High-Tech-Center	<><>
	<< HP Laserjet	Printer interface for MS-DOS Oberon System	>>
	
	Version: 1.1 
 
	Author:	L. Truszek	
	Date:	15-JAN-93	
	Last update: 06-08-93 
	
	How it works :
						This interface uses the Oberon "OberonXX.Pr3.Fnt" printer files and
						converts to temporary HP font descriptors and loads

	Used manual :	
						PHILIPS NMS 1481 
						Technical reference manual
						HP LaserJet Series II Laserprinter emulation mode 

	Printer Language used :
						HP-PCL 
						
		*)

	IMPORT SYSTEM, Files, Objects, V24, Oberon, Fonts, Texts, Centronics;

	CONST
			(* The maximal logical HP Laserjet	page size for A4 format *)

			HPPageWidth = 2480;	
			HPPageHeight = 3508;	
			HPX = 0;  HPY = 0;
			maxfonts = 20 ;
			BaseFont = 100 ; (* starting number for HP font id-s *)
			N = 40;
			BlockSize = 512;

		(* spacing *)
			PROPOR = 1; (* proportional *)
			FIXEDSP = 0; (* fixed *)

		(* orientation *)
			PORTRAIT = 0; (* portrait	*)
			LANDSCP = 1; (* landscape *)

			ESC = 01BX;
			FF = 0CX;
			
		(* compatibility *)
			PW = 2336; PH = 3281; PL = PW DIV 32;
			CH = PH DIV 4;
			
	(* Character descriptor for HP Laserjet Printer *)

 TYPE
		Pattern = ARRAY 16 OF SET;
		Fontx = Fonts.Font; 
		
		RealVector = ARRAY N OF REAL;
		Poly = RECORD a, b, c, d, t: REAL END ;
		PolyVector = ARRAY N OF Poly;

		Set = POINTER TO ARRAY OF SET;
		WriteProc = PROCEDURE (port: INTEGER; ch: CHAR);

		Font = RECORD 
						name: ARRAY 32 OF CHAR;
						pitch: SHORTINT;
						chartab: Set;	(* ARRAY 256 OF BIT *)
					END;

		HPFontDesc = RECORD	(* the HP font descriptor *)
								size: INTEGER;
								res0: SHORTINT;
								type: SHORTINT;
								res1, 
								base,
								cellwidth,
								cellheight: INTEGER;
								orient: SHORTINT;
								space: SHORTINT;
								symbol,
								pitch,
								height,
								xheight: INTEGER;
								widthtype,style*,
								strokeweight,typeface, 
								res2, serifstyle: SHORTINT;
								res3: INTEGER;
								underdist,underheight: SHORTINT;
								textheight, 
								textwidth, 
								res4,res5: INTEGER;
								pitchext,heightext :SHORTINT;
								res6,res7,res8 :INTEGER;
								name: ARRAY 16 OF CHAR;
					END;

	(* the HP Character descriptor *)

		HPCharDesc= RECORD
								fix1,fix2,
								orient,
								left,
								top,
								width,
								height,
								delta: INTEGER;
							END;

	VAR
		res*: INTEGER;
		Width*, Height*, Depth*: INTEGER;
		FrameX*, FrameY*, FrameW*, FrameH*: INTEGER;
		Unit*: LONGINT;
		Write: WriteProc;
		TmpWrite, FileWrite: WriteProc;

		CurFont, PrevFont :SHORTINT;

		M: POINTER TO ARRAY HPPageHeight OF Set;
		maxX, maxY, minX, minY: INTEGER;

		PrintDevice: ARRAY 32 OF CHAR;

		TMP: Files.Rider;
		
		nofonts: INTEGER;
		font: POINTER TO ARRAY maxfonts OF Font;

		R: Files.Rider;
		f: Files.File;		(* file for output *)
		port: INTEGER;
	
	PROCEDURE V24Send(port: INTEGER;  ch: CHAR);
	VAR t: LONGINT;
	BEGIN
		V24.Send(port, ch, t)
	END V24Send;
	
	PROCEDURE OpenSerial(p: INTEGER);
	VAR t: LONGINT;
	BEGIN
		IF p = 2 THEN port := 1 ELSE port := 0 END;
		V24.Start(port, 9600, 8, V24.ParOdd, V24.Stop1, t);
		IF t # 0 THEN HALT(99) END;
		Write := V24Send
	END OpenSerial;

	PROCEDURE OpenParallel( c: INTEGER);
	BEGIN
		IF c = 2 THEN port := Centronics.LPT2 ELSE port := Centronics.LPT1 END;
		Write := Centronics.Send;
		Centronics.Start(port);
	END OpenParallel;

	PROCEDURE OpenFile(name: ARRAY OF CHAR);
	BEGIN
		f := Files.New(name);	
		Files.Set(R,f,Files.Length(f));
		Write := FileWrite;	
	END OpenFile;

	PROCEDURE open(name: ARRAY OF CHAR);
	BEGIN
		res := 0;
		f := NIL; 
		IF name = "LPT1" THEN OpenParallel(1)	
		ELSIF name = "LPT2" THEN OpenParallel(2) 
		ELSIF name = "COM1" THEN OpenSerial(1) 
		ELSIF name = "COM2" THEN OpenSerial(2) 
		ELSE OpenFile(name)
		END;
	END open;

	PROCEDURE close;
	BEGIN
		IF f # NIL THEN
			Files.Register(f)
		END;
		f := NIL;
		res := -1;
	END close;
 

(* Font table procedures *)

	PROCEDURE LookupFont(name: ARRAY OF CHAR; VAR i: SHORTINT; VAR inserted: BOOLEAN);
	BEGIN 
		inserted := FALSE;
		i := 0;
		WHILE (i < nofonts) & (font[i].name # name) DO INC(i) END ;
		IF i = nofonts THEN
			IF nofonts < maxfonts THEN
				COPY(name,font[i].name);	
				INC(nofonts);
				inserted := TRUE;
			ELSE i := maxfonts		(* table full *)
			END
		END ;
	END LookupFont;
	
(* Set procedures *)

	PROCEDURE New(VAR s: Set; len: INTEGER);
	VAR i,size: INTEGER;
	BEGIN (* Init *)
		size := (len + 31) DIV 32;	(* size in SET elements *)
		NEW(s, size); (* size in bytes *)
		i:= 0;  WHILE i < size DO s[i] := {}; INC(i) END
	END New;
	
	PROCEDURE Incl(s: Set; e1: INTEGER);
	BEGIN (* Incl *)
		INCL(s[e1 DIV 32], e1 MOD 32);
	END Incl;

	PROCEDURE In(s: Set; e1: INTEGER): BOOLEAN;
	BEGIN (* In *)
		RETURN e1 MOD 32 IN s[e1 DIV 32]
	END In;
		
 (* Swap bytes in INTEGER *)

	PROCEDURE SB (i: INTEGER): INTEGER;
	VAR n: INTEGER;  b0,b1: CHAR;
	BEGIN
		SYSTEM.GET(SYSTEM.ADR(i),b0);
		SYSTEM.GET(SYSTEM.ADR(i)+1,b1);
		SYSTEM.PUT(SYSTEM.ADR(n),b1);
		SYSTEM.PUT(SYSTEM.ADR(n)+1,b0);
		RETURN n
	END SB;
	
	PROCEDURE WriteString(VAR s: ARRAY OF CHAR);
	VAR i: INTEGER;
	BEGIN
		i:= 0;
		WHILE s[i] # 0X DO
			IF s[i] = CHR(9) THEN (* fix because Pr3 fonts don't have same TAB *)
				Write(port, " "); Write(port, " "); Write(port, " "); Write(port, " "); INC(i)
			ELSE
				IF (s[i] < CHR(32)) & (ORD(s[i]) IN {0, 7..15, 27}) THEN
					Write(port, ESC); Write(port, "&"); Write(port, "p"); 
					Write(port, "1"); Write(port, "X")
				END;
				Write(port, s[i]); INC(i)
			END
		END
	END WriteString;

	PROCEDURE WriteInt(x: INTEGER);
	VAR i: INTEGER;
			xx: LONGINT;
			s: ARRAY 7 OF CHAR;
	BEGIN
		i:= 0;	
		xx := ABS(x);
		REPEAT
			s[i] := CHR(xx MOD 10 + ORD("0"));
			INC(i);
			xx := xx DIV 10;
		UNTIL xx = 0;
		IF x < 0 THEN s[i] := "-"; INC(i) END;
		REPEAT DEC(i); Write(port, s[i]) UNTIL i = 0;
	END WriteInt;

	PROCEDURE Pos (x,y: INTEGER);
	BEGIN
		y := Height - y - HPY;  DEC(x, HPX);
		Write(port, ESC);Write(port, "*");Write(port, "p");WriteInt(x);Write(port, "x");
		WriteInt(y);Write(port, "Y"); 
	END Pos;


	PROCEDURE SetRes(res:INTEGER);
	BEGIN
 		Write(port, ESC); Write(port, "*");Write(port, "t");WriteInt(res);
 		Write(port, "R");
	END SetRes;

	PROCEDURE Block(w,h: INTEGER);
	BEGIN
		IF (w = 1) & (h =1 )	THEN	(* it's only a dot , execute dot macro *)
			Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "y");
			(*Write(port, "&");Write(port, "f");*) Write(port, "2");Write(port, "X");
		ELSE
			Write(port, ESC); Write(port, "*");Write(port, "c");
			WriteInt(w);Write(port, "a");WriteInt(h);Write(port, "b");
			Write(port, "1");Write(port, "0");Write(port, "0");Write(port, "g"); (* 100 % rule pattern *)
			Write(port, "2");Write(port, "P");
		END;
	END Block;

	PROCEDURE definedot;	(* define macro for one dot *)
	BEGIN
		Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "y");
		(*Write(port, "&");Write(port, "f");*) Write(port, "0");Write(port, "X");	(* start macro *)
	 
		Write(port, ESC); Write(port, "*");Write(port, "c");	(* define block 1x1 *)
		Write(port, "1");Write(port, "a");Write(port, "1");Write(port, "b");
		Write(port, "1");Write(port, "0");Write(port, "0");Write(port, "g"); (* 100 % rule pattern *)
		Write(port, "2");Write(port, "P");
	
		(* end macro *)
		Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "X") ;
	END definedot;
	
	PROCEDURE dot;		(* execute dot macro *)
	BEGIN
		Write(port, ESC);Write(port, "&");Write(port, "f");Write(port, "1");Write(port, "y");
		(*Write(port, "&");Write(port, "f");*) Write(port, "2");Write(port, "X");
	END dot;

	PROCEDURE PutRaster(len: INTEGER ; VAR r: ARRAY OF CHAR);
	VAR i: INTEGER;
	BEGIN
		Write(port, ESC); Write(port, "*");Write(port, "r");
		Write(port, "1"); Write(port, "A");
		Write(port, ESC);Write(port, "*");Write(port, "b");WriteInt(len);
		Write(port, "W");
		i := 0;
		WHILE i < len DO Write(port, r[i]); INC(i) END;
		Write(port, ESC);Write(port, "*");Write(port, "r");Write(port, "B");
	END PutRaster;

	PROCEDURE InitPage;
	VAR y: INTEGER;
	BEGIN
	NEW(M);	
		y :=0;
		WHILE y < Height DO M[y] := NIL; INC(y) END;
		maxX := MIN(INTEGER);
		maxY := MIN(INTEGER);
		minX := MAX(INTEGER);
		minY	:= MAX(INTEGER);
	END InitPage;

	PROCEDURE ClosePage;
	VAR k,j,l,x,y,t,i: INTEGER;
	BEGIN
		IF M = NIL THEN RETURN END;
		y := minY;
		WHILE y <= maxY DO
			IF M[y] # NIL THEN
				j := minX;
				WHILE j <= maxX DO
					WHILE (j <= maxX) & ~ In(M[y],j) DO INC(j) END;
					l := 0; x:= j;
					WHILE (j <= maxX) & In(M[y],j) DO INC(l); INC(j) END;
					IF l > 0 THEN Pos(x,y); Block(l,1) END;
				END;
				M[y] := NIL;	(* Clear *)
			END;
			INC(y);
		END;
		maxX := MIN(INTEGER);
		maxY := MIN(INTEGER);
		minX := MAX(INTEGER);
		minY	:= MAX(INTEGER);
	END ClosePage;

	(* Reverse bits in CHAR variable *)
	PROCEDURE Reverse(VAR c: CHAR); (* reverse bits in BYTE *)
	VAR ib,ob: SET;
			ip,op: INTEGER;
	BEGIN
		ib := SYSTEM.VAL(SET,c);
		ip := 0; op := 7; ob := {};
		WHILE ip < 8 DO
			IF ip IN ib THEN INCL(ob,op) END;
			INC(ip);DEC(op);
		END;
		c := SYSTEM.VAL(CHAR,ob);
	END Reverse;
	
	PROCEDURE CreateFontDesc(id, base, cw, ch, or, sp, pi, he: INTEGER; name: ARRAY OF CHAR);
	VAR i: INTEGER;
			a: LONGINT;
			x: CHAR;
			fd: HPFontDesc;
			fdlen: INTEGER;
	BEGIN
		fdlen := SIZE(HPFontDesc);
		Write(port, ESC); Write(port, "*"); Write(port, "c"); WriteInt(id); Write(port, "D");
		Write(port, ESC); Write(port, "*"); Write(port, "c"); Write(port, "4"); Write(port, "F"); 
		(* temporary font *)
	
		Write(port, ESC); Write(port, ")"); Write(port, "s"); WriteInt(fdlen); Write(port, "W");
	
		fd.size := SB(fdlen);
		fd.res0 := 0;
		fd.type := 2; (* any character *)
		fd.res1 := 0;
		fd.base := SB( base);
		fd.cellwidth := SB(cw) ; 
		fd.cellheight := SB( ch);	
		fd.orient := SHORT(or);
		fd.space := SHORT(sp);
		fd.symbol := SB((10 * 32 + ORD("U") - 64)); (* 10U *)
		fd.pitch := SB( pi * 4 );
		fd.height := SB( 4 * he);
		fd.xheight := 0;  fd.widthtype := 0;  fd.style := 0;  fd.strokeweight := 0;
		fd.typeface := 5;
		fd.res2 := 0;  fd.serifstyle := 0;  fd.res3 := 0;  fd.underdist := 0;  fd.underheight := 0;
		fd.textheight := 0;  fd.textwidth := 0;  fd.res4 := 0;  fd.res5 := 0;  fd.pitchext := 0;
		fd.heightext := 0;  fd.res6 := 0;  fd.res7 := 0;  fd.res8 := 0;
		
		(* copy the font name *)
		i:= 0;
		WHILE (i < LEN(name)) & (i < LEN(fd.name)) DO fd.name[i] := name[i]; INC(i) END;
		WHILE i < LEN(fd.name) DO fd.name[i] := 0X; INC(i) END;
		
		(* copy the descriptor to file *)
		i:= 0;
		a := SYSTEM.ADR(fd);
		WHILE i < fdlen DO
			SYSTEM.GET(a,x); INC(a); 
			Write(port, x);
			INC(i)
		END
	END CreateFontDesc;

 (* define one character for LaserJet *)
 
	PROCEDURE DownloadChar(fnt: Fonts.Font;ch:CHAR; num: INTEGER);
	CONST maxpat = 256;
	TYPE Pattern = POINTER TO PatternDesc;
			PatternDesc = RECORD 
										w, h: SHORTINT;
										raster: ARRAY (maxpat+7) DIV 8 * maxpat OF CHAR;
									END;
	VAR hdr: HPCharDesc;
			size,i,hdrlen: INTEGER;
			dx, x, y, w, h: INTEGER;
			pat, a: LONGINT;
			c: CHAR;
			p: Pattern;
			j, k, l: INTEGER;
		(* reverse bits inchar *)
	BEGIN
		hdrlen := SIZE (HPCharDesc);
		(* Get char definition *)
		Fonts.GetChar(fnt,ch,dx,x,y,w,h,pat);
(*
		IF (dx = 0) OR (w= 0) THEN (* no valid size - no action *) RETURN END; 
*)
		(* create char descriptor for HP *)
		hdr.fix1 := 4 ;					(*	4, 0	*)
		hdr.fix2:= 256 * 1 + 14;	(*	14,1 *)
		hdr.orient := 0; 
		hdr.left := SB(x);	
		hdr.top := SB (h+y); 
		hdr.width := SB ( w) ;
		hdr.height := SB( h);
		hdr.delta := SB( 4* dx) ;	(* multiple of 4 must be *)
		
		(* write commands	for HP *)
		size := (( w+7) DIV 8) * h ;	(* pattern size *)
		Write(port, ESC); Write(port, "*"); Write(port, "c"); WriteInt(num);Write(port, "E");
		Write(port, ESC); Write(port, "("); Write(port, "s"); WriteInt(size+hdrlen); Write(port, "W");
		a := SYSTEM.ADR(hdr);
		i:= 0 ;
		WHILE i < hdrlen DO		(* write char descriptor *)
			SYSTEM.GET(a,c);INC(a);
			Write(port, c);
			INC(i);
		END ;
		IF size # 0 THEN
			(* write raster data in reverse mode *)
			p := SYSTEM.VAL(Pattern,pat);
			l := (w+7) DIV 8;
			j := size - l;
			WHILE j >= 0 DO 
				k := 0;
				WHILE k < l DO
					c := p.raster[j+k]; Reverse(c);
					Write(port, c);
					INC(k);
				END;
				DEC(j,l);
			END
		END
	END DownloadChar;

	PROCEDURE SwitchOn(fntno :SHORTINT);
	BEGIN
		Write(port, ESC);Write(port, "(");WriteInt(BaseFont+fntno); Write(port, "X"); 
	END SwitchOn;

	PROCEDURE CreateFont (fnt: Fonts.Font; fntno, pitch, orient, spacing: INTEGER);
	BEGIN
		(* create font descriptor for new font arrived *)
		CreateFontDesc(fntno, fnt.maxY, (* baseline *)
								fnt.maxX-fnt.minX,	(* cell with *)
								fnt.maxY-fnt.minY,		(* cell height *)
								orient,						(* orientation, potrait*)
								spacing,						(* spacing, proportionel *)
								pitch,
								fnt.height,					(* height *)
								fnt.name);
	END CreateFont;

	PROCEDURE SetFont(name: ARRAY OF CHAR; VAR s : ARRAY OF CHAR);
	VAR fnt: Fonts.Font;
			ch, fnttype: CHAR;
			i, id: INTEGER;
			fntno,pitch: SHORTINT;
			inserted: BOOLEAN;

		PROCEDURE ToPr3Font(VAR fn: ARRAY OF CHAR; VAR pi: SHORTINT);
		VAR i: INTEGER;
				ch,ch2,ch3: CHAR;
		BEGIN
			i:= 0;
			ch := fn[i];
			WHILE ((ch < "0") OR (ch > "9")) & (ch # ".") & (ch # 0X) DO INC(i); ch := fn[i] END;
			IF (ch = ".") OR (ch = 0X) THEN pi := 0;
			ELSE
				pi := SHORT(ORD(ch) - ORD("0")) ;
				INC(i); ch := fn[i];
				IF (ch >= "0") & (ch <= "9") THEN
					pi := SHORT (10* pi + (ORD(ch)- ORD("0")));
					INC(i);ch := fn[i];
				END;
				IF ch # "." THEN INC(i) END;
			END;
			(* convert "*.Scn.*" filename to "*.Pr3.*" file name *)
			ch := fn[i+1];
			ch2 := fn[i+2];
			ch3 := fn[i+3];
			IF (ch = "S") & (ch2 = "c") & (ch3= "n") THEN fn[i+1] := "P"; fn[i+2] := "r"; fn[i+3] := "3" END;
		END ToPr3Font;

	BEGIN
		ToPr3Font(name,pitch);			(* convert name to Printer file name *)
		
		IF (Files.Old(name) = NIL) THEN (* no such file *)
			COPY ("Oberon10.Pr3.Fnt",name); (* default printer font *);
		END;
		LookupFont(name,fntno,inserted); (* lookup in own font table *)
		IF inserted THEN	(* if new font then init*)
			font[fntno].pitch := pitch; 
			New(font[fntno].chartab,256);
			i := 0;
			WHILE s[i] # 0X DO	(* set the used chars in this font *)
				Incl(font[fntno].chartab,ORD(s[i]));
				INC(i);
			END;
		ELSIF fntno < maxfonts THEN	(* found *)
			i := 0;
			WHILE s[i] # 0X DO	(* set used characters inside the font *)
				Incl(font[fntno].chartab,ORD(s[i])) ;
				INC(i);
			END;
		ELSE (* table full*) END;
		PrevFont :=CurFont;
		CurFont := fntno;
		IF CurFont # PrevFont THEN	(* change font if it needed *)
			SwitchOn(fntno);
		END;
	END SetFont;

	PROCEDURE LoadFont( f: SHORTINT); (* load used font with used chars *)
	VAR i: INTEGER;
	BEGIN
		CreateFont(Fonts.This(font[f].name),BaseFont+f,font[f].pitch,PORTRAIT,PROPOR);
		i:= 0;
		WHILE i < 256 DO
			IF In(font[f].chartab,i) THEN DownloadChar(Fonts.This(font[f].name), CHR(i), i) END;
			INC(i);
		END;
	END LoadFont;
 
	PROCEDURE Dot(x,y: INTEGER);
	BEGIN
		IF M = NIL THEN	(* the first graphic usage *)	InitPage END;
		IF M[y] = NIL THEN New(M[y], Width) END;
		Incl(M[y],x);
		IF x > maxX THEN maxX := x END;
		IF y > maxY THEN maxY := y END;
		IF x < minX THEN minX := x END;
		IF y < minY THEN minY := y END;
	END Dot;

	PROCEDURE line(x0, y0, x1, y1: INTEGER);
	VAR x, y, dx, dy, d, inc: INTEGER;
	BEGIN
		IF y1 - y0 < x0 - x1 THEN 
			x := x0; 
			x0 := x1; x1 := x; y := y0; 
			y0 := y1; y1 := y 
		END;
		dx := 2 * (x1 - x0);
		dy := 2 * (y1 - y0);
		x := x0; y := y0; inc := 1;
		IF dy > dx THEN
			d := dy DIV 2;
			IF dx < 0 THEN inc := -1; dx := -dx END;
			WHILE y <= y1 DO
				Dot(x, y);
				INC(y); DEC(d, dx);
				IF d < 0 THEN INC(d, dy); INC(x, inc) END
			END
		ELSE
			d := dx DIV 2;
			IF dy < 0 THEN inc := -1; dy := -dy END;
			WHILE x <= x1 DO
				Dot( x, y);
				INC(x); DEC(d, dy);
				IF d < 0 THEN INC(d, dx); INC(y, inc) END
			END
		END
	END line;

	PROCEDURE circle (x0, y0, r: INTEGER);
	VAR x, y, q: INTEGER;
	BEGIN
		x := 0; y := r; q := r;
		WHILE x <= y DO
			Dot( x0 + x, y0 + y); Dot( x0 + y, y0 + x);
			Dot( x0 - x, y0 + y); Dot( x0 - y, y0 + x);
			Dot( x0 + x, y0 - y); Dot( x0 + y, y0 - x);
			Dot( x0 - x, y0 - y); Dot( x0 - y, y0 - x);
			INC(x); DEC(q, 2 * x - 1);
			IF q <= 0 THEN DEC(y); INC(q, 2 * y) END
		END
	END circle;

	PROCEDURE ellipse(x0, y0, a, b: INTEGER);
	VAR a2, b2, ex, ey, q: LONGINT; x, y: INTEGER;
	BEGIN
		IF (a <= 800) & (b <= 800) THEN (* longint range guard *)
			a2 := LONG(a) * a; b2 := LONG(b) * b;
			ex := b2; ey := a2 * (b * 2 - 1); q := 0;
			a2 := a2 * 2; b2 := b2 * 2;
			x := 0; y := b;
			WHILE ey > ex DO
				Dot( x0 + x, y0 + y); Dot( x0 - x, y0 + y);
				Dot( x0 + x, y0 - y); Dot( x0 - x, y0 - y);
				INC(x); INC(q, 2 * ex); INC(ex, b2);
				IF q > ey THEN DEC(y); DEC(q, 2 * ey); DEC(ey, a2) END
			END;
			WHILE y >= 0 DO
				Dot( x0 + x, y0 + y); Dot( x0 - x, y0 + y);
				Dot( x0 + x, y0 - y); Dot( x0 - x, y0 - y);
				DEC(y); DEC(q, 2 * ey); DEC(ey, a2);
				IF q < -ex THEN INC(x); INC(q, 2 * ex); INC(ex, b2) END
			END
		END
	END ellipse;

	PROCEDURE PrintPoly(x0, y0: INTEGER; VAR p, q: Poly; lim: REAL);
	VAR t: REAL; x, y: LONGINT;
	BEGIN t := 0;
		REPEAT
			Dot(SHORT(ENTIER(((p.a * t + p.b) * t + p.c) * t + p.d) + x0),SHORT(ENTIER(((q.a * t + q.b) * t + q.c) * t + q.d) + y0));
			t := t + 1.0
		UNTIL t >= lim
	END PrintPoly;

	PROCEDURE SolveTriDiag(VAR a, b, c, y: RealVector; n: INTEGER);
	VAR i: INTEGER;
			r: REAL;
	BEGIN (*a, b, c of tri-diag matrix T; solve Ty' = y for y', assign y' to y*)
		i := 1;
		WHILE i < n DO 
			r := y[i];
			r :=r - c[i-1]*y[i-1]; 
			y[i] := r;
			INC(i) 
		END ;
		i := n-1; y[i] := y[i]/a[i];
		WHILE i > 0 DO 
			DEC(i); r := y[i];
			r := (r- b[i]*y[i+1])/a[i] ;
			y[i] := r;
		END
	END SolveTriDiag;	

	PROCEDURE OpenSpline(VAR x, y, d: RealVector; n: INTEGER);
	VAR i: INTEGER; d1, d2: REAL;
			a, b, c: RealVector;
	BEGIN (*from x, y compute d = y'*)
		b[0] := 1.0/(x[1] - x[0]); a[0] := 2.0*b[0]; c[0] := b[0];
		d1 := (y[1] - y[0])*3.0*b[0]*b[0]; d[0] := d1; i := 1;
		WHILE i < n-1 DO
			b[i] := 1.0/(x[i+1] - x[i]);
			a[i] := 2.0*(c[i-1] + b[i]);
			c[i] := b[i];
			d2 := (y[i+1] - y[i])*3.0*b[i]*b[i];
			d[i] := d1 + d2; d1 := d2; INC(i)
		END ;
		a[i] := 2.0*b[i-1]; d[i] := d1; i := 0;
		WHILE i < n-1 DO c[i] := c[i]/a[i]; a[i+1] := a[i+1] - c[i]*b[i]; INC(i) END ;
		SolveTriDiag(a, b, c, d, n)
	END OpenSpline;

	PROCEDURE ClosedSpline(VAR x, y, d: RealVector; n: INTEGER);
	VAR i: INTEGER; d1, d2, hn, dn,r: REAL;
			a, b, c, w: RealVector;
	BEGIN (*from x, y compute d = y'*)
		hn := 1.0/(x[n-1] - x[n-2]);
		dn := (y[n-1] - y[n-2])*3.0*hn*hn;
		b[0] := 1.0/(x[1] - x[0]);
		a[0] := 2.0*b[0] + hn;
		c[0] := b[0];
		d1 := (y[1] - y[0])*3.0*b[0]*b[0]; d[0] := dn + d1;
		w[0] := 1.0; i := 1;
		WHILE i < n-2 DO
			b[i] := 1.0/(x[i+1] - x[i]);
			a[i] := 2.0*(c[i-1] + b[i]);
			c[i] := b[i];
			d2 := (y[i+1] - y[i])*3.0*b[i]*b[i]; d[i] := d1 + d2; d1 := d2;
			w[i] := 0; INC(i)
		END ;
		a[i] := 2.0*b[i-1] + hn; d[i] := d1 + dn;
		w[i] := 1.0; i := 0;
		WHILE i < n-2 DO c[i] := c[i]/a[i]; a[i+1] := a[i+1] - c[i]*b[i]; INC(i) END ;
		SolveTriDiag(a, b, c, d, n-1); SolveTriDiag(a, b, c, w, n-1); 
		r := d[i];
		d1 := (d[0] + r)/(w[0] + w[i] + x[i+1] - x[i]); i := 0;
		WHILE i < n-1 DO 
			d[i]:=d[i] - d1*w[i]; INC(i) ;
		END ;
		d[i] := d[0]
	END ClosedSpline;

	PROCEDURE spline (x0, y0, n, open: INTEGER; VAR u,v: ARRAY OF INTEGER);
	VAR i: INTEGER; dx, dy, ds: REAL;
			x, xd, y, yd, s: RealVector;
			p, q: PolyVector;
	BEGIN (*from u, v compute x, y, s*)
		x[0] := u[0]; y[0] := v[0]; s[0] := 0;	i := 1;
		WHILE i < n DO
			x[i] := u[i]; dx := x[i] - x[i-1];
			y[i] := v[i]; dy := y[i] - y[i-1];
			s[i] := ABS(dx) + ABS(dy) + s[i-1]; INC(i)
		END ;
		IF open = 1	THEN OpenSpline(s, x, xd, n); OpenSpline(s, y, yd, n)
		ELSE ClosedSpline(s, x, xd, n); ClosedSpline(s, y, yd, n)
		END ;
		(*compute coefficients from x, y, xd, yd, s*)	i := 0;
		WHILE i < n-1 DO
			ds := 1.0/(s[i+1] - s[i]);
			dx := (x[i+1] - x[i])*ds;
			p[i].a := ds*ds*(xd[i] + xd[i+1] - 2.0*dx);
			p[i].b := ds*(3.0*dx - 2.0*xd[i] -xd[i+1]);
			p[i].c := xd[i];
			p[i].d := x[i];
			p[i].t := s[i];
			dy := ds*(y[i+1] - y[i]);
			q[i].a := ds*ds*(yd[i] + yd[i+1] - 2.0*dy);
			q[i].b := ds*(3.0*dy - 2.0*yd[i] - yd[i+1]);
			q[i].c := yd[i];
			q[i].d := y[i];
			q[i].t := s[i]; INC(i)
		END;
		(*display polynomials*)
		i := 0;
		WHILE i < n-1 DO PrintPoly( x0, y0, p[i], q[i], p[i+1].t - p[i].t); INC(i) END
	END spline;

(* Standard Printer procedures *)
 
	PROCEDURE Open*(name, options: ARRAY OF CHAR);
	VAR tmp: Files.File;
	BEGIN 
		tmp := Files.New("Printer.Tmp"); Files.Set(TMP,tmp,0);
		Write := TmpWrite;	(* Set write procedure to write tmp file *) 
		COPY(name,PrintDevice);	(* save the output name *)
		NEW(font); nofonts := 0;
		CurFont := -1;
		res := 0;	(* say o.k *)
	END Open;

	PROCEDURE ReplConst* (x, y, w, h: INTEGER);
	BEGIN
		IF (w > 0) & (h > 0 ) THEN Pos(x,y+h); Block(w,h) END;
	END ReplConst;

	PROCEDURE UseListFont*(VAR name: ARRAY OF CHAR);
	BEGIN
	(* not implemented *)
	END UseListFont;

	PROCEDURE GetMetric*(fnt: Fonts.Font): Fonts.Font;
	VAR name: ARRAY 32 OF CHAR; i: INTEGER; metric: Fonts.Font;
	BEGIN
		COPY(fnt.name, name);
		i := 0; WHILE (name[i] # ".") & (name[i] # 0X) DO INC(i) END;
		(* look for Mdx *)
		name[i] := "."; name[i+1] := "M"; name[i+2] := "d"; name[i+3] := "3";
		name[i+4] := "."; name[i+5] := "F"; name[i+6] := "n"; name[i+7] := "t";
		name[i+8] := 0X;
		metric := Fonts.This(name);
		IF metric.type = Fonts.substitute THEN metric := NIL END;
		RETURN metric
	END GetMetric;

	PROCEDURE String*(x, y: INTEGER; s: ARRAY OF CHAR; fnt: Fonts.Font);
	BEGIN
		SetFont(fnt.name,s);
		Pos(x,y);
		WriteString(s);
	END String;

	PROCEDURE ContString*(s: ARRAY OF CHAR; fnt: Fonts.Font);
	BEGIN
		SetFont(fnt.name,s);
		WriteString(s); 
	END ContString;

	PROCEDURE ReplPattern* (x, y, w, h, col: INTEGER);
	BEGIN
		col := ((100 DIV 16) * col) MOD 100 + 1; (* to range 1..100 *)
		Pos(x,y+h);
		Write(port, ESC); Write(port, "*");Write(port, "c");
		WriteInt(w);Write(port, "a");WriteInt(h);Write(port, "b");
		WriteInt(col);Write(port, "g");
		Write(port, "2");Write(port, "P");
	END ReplPattern;

	PROCEDURE Line* (x0, y0, x1, y1: INTEGER);
	BEGIN
		IF x0 = x1 THEN						(* if it is a vertical line *)
			ReplConst(x0,y0,1,ABS(y1-y0));
		ELSIF y0 = y1 THEN				(* if it is a horizontal line *)
			ReplConst(x0,y0,ABS(x1-x0),1);
		ELSE line(x0, y0, x1, y1) END;
	END Line;

	PROCEDURE Circle* (x0, y0, r: INTEGER);
	BEGIN
		circle (x0, y0, r); 
	END Circle;

	PROCEDURE Ellipse*(x0, y0, a, b: INTEGER);
	BEGIN
		ellipse(x0, y0, a, b);
	END Ellipse;

	PROCEDURE Spline* (x0, y0, n, open: INTEGER; VAR X, Y: ARRAY OF INTEGER);
	BEGIN
		spline(x0, y0, n, open ,X, Y);
	END Spline;

	PROCEDURE Picture*(x, y, w, h, mode: INTEGER; adr: LONGINT);
	VAR b: CHAR;
			i,l,xe,ye: INTEGER;
			Line: ARRAY (HPPageWidth+7) DIV 8 OF CHAR;
	BEGIN	(*	the parameter "mode" is not implemented *)
		xe := x + w;
		ye := y + h;
		WHILE y < ye DO 
			Pos(x,y);
			i := x; l:= 0;
			WHILE i < xe DO
				SYSTEM.GET(adr, b); INC(adr);
				Line[l] :=b;INC(l);
				INC(i);
			END;
			IF l > 0 THEN PutRaster(l,Line) END;
			INC(y);
		END;
	END Picture;
 
	PROCEDURE Page* (nofcopies: INTEGER);
	BEGIN
		ClosePage;						(* close graphics page *)
		IF nofcopies > 1 THEN		(* make	a copy from the page *)
			Write(port, ESC); Write(port, "&");Write(port, "I");
			WriteInt(nofcopies);Write(port, "X");
		END;
		Write(port, FF);
	END Page;

	PROCEDURE Close*;
	VAR ch: CHAR;
			i: SHORTINT;
	BEGIN
		open(PrintDevice);			(* open printer devive *)

		Write(port, ESC);Write(port, "E");		(* Reset Printer	*)
		SetRes(300);						(* resolution 330 dpi *)
		definedot;							(* define HP macro for dot *)
		i := 0 ;
		WHILE i < nofonts DO	(* load used fonts *)
			LoadFont(i); INC(i);
		END;

		Files.Set(TMP,Files.Base(TMP),0);	(* copy the temporary file to device *)
		Files.Read(TMP,ch);
		WHILE ~ TMP.eof DO
			Write(port, ch);
			Files.Read(TMP,ch);
		END;
		ClosePage;		(* the page must be ended if it is not so *)
		close;
		font := NIL;
		Files.Set(TMP, NIL, 0);
		nofonts := 0 ;
	END Close;

	PROCEDURE UseColor* (red, green, blue: INTEGER);
	BEGIN
	END UseColor;

	PROCEDURE FileWriteProc(port: INTEGER; ch: CHAR);
	BEGIN
		Files.Write(R,ch);
	END FileWriteProc;

	PROCEDURE TmpWriteProc(port: INTEGER; ch: CHAR);
	BEGIN
		Files.Write(TMP,ch);
	END TmpWriteProc;

	PROCEDURE GetDim(label: ARRAY OF CHAR;  def: INTEGER;  VAR val: INTEGER);
	VAR v: REAL; S: Texts.Scanner;
	BEGIN
		Oberon.OpenScanner(S, label);
		IF (S.class = Texts.Int) OR (S.class = Texts.Real) THEN
			IF S.class = Texts.Int THEN v := S.i
			ELSE v := S.x
			END;
			Texts.Scan(S);
			IF S.class = Texts.Name THEN
				IF S.s = "cm" THEN v := v*360000.0
				ELSIF S.s = "mm" THEN v := v*36000.0
				ELSIF S.s = "in" THEN v := v*36000.0*25.4
				ELSE v := v*36000.0
				END
			ELSE v := v*36000.0
			END;
			val := SHORT(ENTIER(v/Unit + 0.5))
		ELSE val := def
		END
	END GetDim;
	
	PROCEDURE Init;
	VAR S: Texts.Scanner;
	BEGIN 
		Oberon.OpenScanner(S, "Printer.Depth");
		IF S.class = Texts.Int THEN Depth := SHORT(S.i) ELSE Depth := 1 END;
		Unit := 3048;
		GetDim("Printer.Layout.Width", 2480, Width);
		IF Width > HPPageWidth THEN Width := HPPageWidth END;
		GetDim("Printer.Layout.Height", 3508, Height);
		IF Width > HPPageHeight THEN Height := HPPageHeight END;
		GetDim("Printer.Layout.LeftMargin", 236, FrameX);
		GetDim("Printer.Layout.RightMargin", 236, FrameW);
		FrameW := Width-FrameX-FrameW;
		GetDim("Printer.Layout.BottomMargin", 177, FrameY);
		GetDim("Printer.Layout.TopMargin", 177, FrameH);
		FrameH := Height-FrameY-FrameH
	END Init;


BEGIN
	M := NIL;  Init;
	TmpWrite := TmpWriteProc;	
	FileWrite := FileWriteProc
 END Printer.
 
 
 
