(* OBERON System 3, Release 2.2.

Copyright 1997 Team of the Institute of Computer Systems of ETH Zuerich,
ETH Center, CH-8092 Zuerich, e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be requested from the 
above-mentioned address, or downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)


MODULE ASM;

(* ASM - i80386 assembler module for the OP2 compiler *)
(* pjm, prk 16.05.97 *)


	IMPORT SYSTEM, OPM, OPS, OPT, OPB;


	CONST 

		none = -1;
	
		(* node classes for inline instructions*)
		Nassembler = 29;
		Ncode = 30;
		Nfixup = 31;
		
		(* Own Symbol Table types *)
		StLabel = 0; StFwdLabel = 1;
		StConst = 3; StType = 4; StVar = 5; StVarPar = 6; StGlobal = 7;

		(* Own Addressing modes, also used in the St and Sc *)
		Reg8 = 08H; Reg16 = 10H; Reg32 = 20H;
		RegAL = 09H; RegAX = 11H; RegEAX = 21H;
		RegDX = 12H;								(* special case for IN/OUT *)
		RegCL = 13H;								(* special case for rotate/shift *)
		Imm8 = 30H; Imm16 = 31H; Imm32 = 32H; SImm8 = 35H; Imm = 36H;
		Const1 = 33H;								(* special case for rotate/shift *)
		Const3 = 34H;								(* special case for INT 3 *)
		RM = 40H; RM8 = 41H; RM16 = 42H; RM32 = 43H; 
		M = 48H; M8 = 49H; M16 = 4AH; M32 = 4BH; M64 = 4CH; M80 = 4DH;
		(*M2 = 4EH;*)
		SReg = 50H;	(* Segment Register *)
		RegCS = 51H; RegDS = 52H; RegES = 53H; RegFS = 54H;
		RegGS = 55H; RegSS = 56H;
		Rel8 = 60H; Rel16 = 61H; Rel32 = 62H; FwdJmp = 63H;
		CRReg = 70H; DRReg = 71H; TRReg = 72H;
		FReg = 80H; FRegST = 81H;
		
		(* Scanner: ASCII codes *)
		TAB = 09X;
		CR = 0DX;
		SPACE = 20X;
		(* Scanner: Sym values *)
		ScUndef = 0;
		ScIdent = 1; 
		ScSemicolon = 2;	(* ; *)
		ScAt = 3;	(* @ *)
		ScNumber = 4;
		ScComma = 5; 	(* , *)
		ScLBrak = 6;	(* [ *)
		ScRBrak = 7;	(* ] *)
		ScCR = 8;
		ScMult = 9;	(* * *)
		ScEnd = 10;
		ScLabel = 11;
		ScColon = 12;	(* : *)
		ScPlus = 13;
		ScMinus = 14;
		ScDiv = 15;
		ScLPar = 16;
		ScRPar = 17;
		ScString = 18;
		
		(* Structure sizes *)
		NameLen = 32;
		MaxStrLen = 256;
		MnemoLen = 8;
		OpTabLen = 650;
		InstrTabLen = 403;
		
		(* Opcodes modifiers *)
		OmRM = 1;	OmOp = 2;		(* register stored in the RM byte / register added to the opcode *)
		
		(* Match evaluation *)
		NoMatch = 0; SizeCast = 1; TypeCast = 2; ConstCast = 3; Hit = 4;

	TYPE 
		Name = ARRAY NameLen OF CHAR;
		Mnemo = ARRAY MnemoLen OF CHAR;
		
		(*Object: The symbol table. It's an ordered binary tree. First element is root.right *)
		Object = POINTER TO ObjDesc;
		FixPnt = POINTER TO FixPntDesc;
		
		InstrDesc = RECORD
					name: Mnemo;
					start, end: INTEGER;	 (* index in the opcode-tab *)
				END;

		(* Opcode: this structure contains the definition of an opcode, with the
			expected dst/src operands and the information needed to encode it.
			Ex:
				if opc # -1 => modr/m . opc = opc. ( extension of the opcode )
		*)
		OpCode = RECORD
				op: ARRAY 3 OF INTEGER;		(* mode of the dst/src operands, if needed *)
				op0, op1: INTEGER;	   (* opcode *)
				opc: INTEGER;			(* value stored in reg/opcode of modr/m. -1 = none *)
				reg: INTEGER;			(* where is the register stored: none / rm /op *)
			END;
		
		Operand = RECORD
					mode: INTEGER;		(* the mode: Reg8.... *)
					imm: LONGINT;		(* the constant *)
					disp: LONGINT;
					index, base, reg: INTEGER;
					seg, scale: INTEGER;	(* segment override *)
					obj: Object;			(* the jmp label for forward jumps / the object referenced *)
				END;
				
		ObjDesc = RECORD
							typ: INTEGER;
							val, size:  LONGINT;		(* if typ <0 => pos of first use of this label *)
							name: Name;
							left, right, next: Object;
							fix: FixPnt;
							obj: OPT.Object
					 END;
		
		FixPntDesc = RECORD
						pc: LONGINT;
						node: OPT.Node;
						pos: LONGINT;
						next: FixPnt;
					END;

VAR
	(* Global structures *)
		root:  Object;	(* symbol table *)
		OpTab: ARRAY OpTabLen OF OpCode;	(* Table with the opcodes *)
		OpTabN: INTEGER;		(* nof opcodes in the table *)
		Average: LONGINT;		(* debug: access average *)
		InstrTab: ARRAY InstrTabLen OF InstrDesc;	(* Table with the instructions !!Hash *)
		SizeTab: ARRAY 16 OF SHORTINT;		(* size of the oberon types *)
		
		FirstTime: BOOLEAN;		(* First time the module is used *)
		
		pc: LONGINT;	(* program counter. Should be used only for pc-rel jumps !! *)
		
	(* Scanner variables *)
		(*ch: CHAR;*)			(* look-ahead char is OPS.ch*)
		sym: INTEGER; 	(* last token read *)
		ident: Name;		(* last identifier read *)
		val: LONGINT;	  (* last value read *)
		str: ARRAY MaxStrLen OF CHAR;
		errpos: LONGINT;	(* starting position of the last instruction *)
	
	(* Instruction nodes *)
		first, last: OPT.Node;	(* first and last nodes in the instruction stream *)
		fixlist: OPT.Node;	(* list of fixups to be done by the back-end *)

(* ------------------------------------------------------------------- *)
(* Special functions *)

	PROCEDURE AND(a,b: LONGINT):LONGINT;
	BEGIN RETURN(SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET,a) * SYSTEM.VAL(SET,b)))
	END AND;

	PROCEDURE OutXDigit(i: LONGINT);
	BEGIN
		IF i<10 THEN OPM.LogW(CHR(i+ORD("0"))) ELSE OPM.LogW(CHR(i+ORD("A")-10)) END
	END OutXDigit;
		
	PROCEDURE OutHex(i: LONGINT);
	BEGIN
		OutXDigit( i DIV 16); OutXDigit(i MOD 16)
	END OutHex;

(* ------------------------------------------------------------------- *)
(* Addressing Mode functions *)

	PROCEDURE DumpMode(mode: INTEGER);
	BEGIN
		CASE mode OF
		  Reg8: OPM.LogWStr("r8 ")
		| Reg16: OPM.LogWStr("r16 ")
		| Reg32: OPM.LogWStr("r32 ")
		| RegAL: OPM.LogWStr("AL ")
		| RegAX: OPM.LogWStr("AX ")
		| RegEAX: OPM.LogWStr("EAX ")
		| RegDX: OPM.LogWStr("DX ")
		| RegCL: OPM.LogWStr("CL ")
		| RegCS: OPM.LogWStr("CS ")
		| RegDS: OPM.LogWStr("DS ")
		| RegES: OPM.LogWStr("ES ")
		| RegFS: OPM.LogWStr("FS ")
		| RegGS: OPM.LogWStr("GS ")
		| RegSS: OPM.LogWStr("SS ")
		| Imm8: OPM.LogWStr("imm8 ")
		| Imm16: OPM.LogWStr("imm16 ")
		| Imm32: OPM.LogWStr("imm32 ")
		| SImm8: OPM.LogWStr("imm8 (signed) ")
		| Imm: OPM.LogWStr("imm (generic) ")
		| Const1: OPM.LogWStr("1 ")
		| Const3: OPM.LogWStr("t3 ")
		| RM: OPM.LogWStr("r/m ")
		| RM8: OPM.LogWStr("r/m8 ")
		| RM16: OPM.LogWStr("r/m16 ")
		| RM32: OPM.LogWStr("r/m32 ")
		| SReg: OPM.LogWStr("Sreg ")
		| Rel8: OPM.LogWStr("rel8 ")
		| Rel16: OPM.LogWStr("rel16 ")
		| Rel32: OPM.LogWStr("rel32 ")
		| FwdJmp: OPM.LogWStr("FwdJmp ")
		| none: OPM.LogWStr("none ")
		| M: OPM.LogWStr("m ")
		| M8: OPM.LogWStr("m8 ")
		| M16: OPM.LogWStr("m16 ")
		| M32: OPM.LogWStr("m32 ")
		| M64: OPM.LogWStr("m64 ")
		| M80: OPM.LogWStr("m80 ")
		| CRReg: OPM.LogWStr("CR0/CR2-3 ")
		| DRReg: OPM.LogWStr("DR0-3/DR6/DR7 ")
		| TRReg: OPM.LogWStr("TR6/TR7 ")
		| FReg: OPM.LogWStr("ST(i) ")
		| FRegST: OPM.LogWStr("ST ")
		ELSE OPM.LogWStr("unknown mode ")
		END
	END DumpMode;

	PROCEDURE DumpOp(VAR o: Operand);
	BEGIN
		DumpMode(o.mode);
		OPM.LogWNum(o.imm, 4); OPM.LogWNum(o.disp, 4); OPM.LogWNum(o.reg,4); OPM.LogWNum(o.base,4); OPM.LogWNum(o.index, 4);
	END DumpOp;
	
	PROCEDURE ModeSize(mode: INTEGER): INTEGER;
	BEGIN
		CASE mode OF
		  Imm8, Const1, Const3, Rel8, RegAL, RegCL, Reg8, RM8, M8, SImm8:
				RETURN(1)
		| Imm16, Rel16, RegAX, RegDX, Reg16, RM16, M16, SReg, RegCS, RegDS, RegES, RegFS, RegGS, RegSS:
				RETURN(2)
		| Imm32, Rel32, FwdJmp, RegEAX, Reg32, RM32, M32:
				RETURN(4)
		| M64:
				RETURN(8)
		| M80:
				RETURN(10)
		| RM:
				RETURN(0)
		ELSE RETURN(0)
		END
	END ModeSize;
	
	PROCEDURE ConstSize(i: LONGINT; signed: BOOLEAN):INTEGER;
	BEGIN
		IF (MIN(SHORTINT) <= i) & (MAX(SHORTINT) >= i) OR (~signed & (AND(i,0FFFFFF00H)=0)) THEN
			RETURN(1)
		ELSIF (MIN(INTEGER) <= i) & (MAX(INTEGER) >= i) OR (~signed & (AND(i,0FFFF0000H)=0))THEN
			RETURN(2)
		ELSE
			RETURN(4)
		END
	END ConstSize;
	
	PROCEDURE IsRegMode(m: INTEGER; strict: BOOLEAN):BOOLEAN;
	BEGIN
		RETURN((m=Reg8)OR(m=Reg16)OR(m=Reg32)OR
			(~strict &((m=RegAL)OR(m=RegAX)OR(m=RegEAX)OR(m=RegDX))))
	END IsRegMode;
	
	PROCEDURE IsSRegMode(m: INTEGER; strict: BOOLEAN):BOOLEAN;
	BEGIN
		RETURN((m=SReg)OR (~strict &(m=RegCS)OR(m=RegDS)OR(m=RegES)OR
			(m=RegFS)OR(m=RegGS)OR(m=RegSS)))
	END IsSRegMode;
	
	PROCEDURE IsSpecRegMode(m: INTEGER):BOOLEAN;
	BEGIN
		RETURN((m=CRReg)OR(m=DRReg)OR(m=TRReg))
	END IsSpecRegMode;
	
	PROCEDURE IsMMode(m: INTEGER):BOOLEAN;
	BEGIN
		RETURN((m=M)OR(m=M8)OR(m=M16)OR(m=M32)OR(m=M64)OR(m=M80))
	END IsMMode;
	
	PROCEDURE IsModRmMode(m: INTEGER):BOOLEAN;
	BEGIN
		RETURN((m=RM)OR(m=RM8)OR(m=RM16)OR(m=RM32) (*OR IsMMode(m)*))
	END IsModRmMode;
	
	PROCEDURE IsFRegMode(m: INTEGER; strict: BOOLEAN):BOOLEAN;
	BEGIN
		RETURN((m=FReg) OR (~strict & (m=FRegST)))
	END IsFRegMode;

	PROCEDURE NeedModRM(mode, regpos: INTEGER): BOOLEAN;
	BEGIN
		RETURN(IsModRmMode(mode) OR IsMMode(mode) OR
						((regpos = OmRM) & (IsRegMode(mode,TRUE) OR IsSRegMode(mode, FALSE) OR IsSpecRegMode(mode))))
	END NeedModRM;
	
	PROCEDURE IsImmMode(m: INTEGER):BOOLEAN;
	BEGIN
		RETURN((m=Imm8)OR(m=Imm16)OR(m=Imm32)OR(m=SImm8)OR(m=Imm))
	END IsImmMode;
	
	PROCEDURE IsRelMode(m: INTEGER):BOOLEAN;
	BEGIN
		RETURN((m=Rel8)OR(m=Rel16)OR(m=Rel32))
	END IsRelMode;
	
	PROCEDURE Evaluate(VAR op: Operand; mode: INTEGER):INTEGER;
	BEGIN
		IF mode = op.mode THEN RETURN(Hit)	(* 80% of the checks, now the 20% special cases *)
		ELSIF IsModRmMode(mode) THEN
			IF IsMMode(op.mode) THEN
				IF ModeSize(op.mode)=ModeSize(mode) THEN RETURN Hit
				ELSIF (op.mode = RM) OR (op.mode = M) THEN RETURN SizeCast
				ELSE RETURN NoMatch END
			ELSIF IsRegMode(op.mode, FALSE) & (ModeSize(op.mode)=ModeSize(mode)) THEN RETURN TypeCast
			ELSE RETURN NoMatch END
		ELSIF IsRegMode(mode,TRUE) THEN	(* cannot be a specific reg (AL,AX,EAX) *)
			IF ModeSize(op.mode)=ModeSize(mode) THEN
				IF IsRegMode(op.mode,TRUE) THEN RETURN Hit
				ELSIF IsRegMode(op.mode, FALSE) THEN RETURN TypeCast
				ELSE RETURN NoMatch END
			ELSE RETURN NoMatch
			END
		ELSIF mode = RegDX THEN
			IF (op.mode = Reg16) & (op.reg = 2) THEN RETURN Hit ELSE RETURN NoMatch END	(* special case for IN/OUT which uses DX *)
		ELSIF mode = RegCL THEN
			IF (op.mode = Reg8) & (op.reg = 1) THEN RETURN Hit ELSE RETURN NoMatch END	(* special case for shift/rotate which uses CL *)
		ELSIF IsRegMode(mode, FALSE) THEN RETURN NoMatch
		ELSIF IsImmMode(mode) THEN
			IF op.mode = Imm THEN
				IF ModeSize(mode)  > ConstSize(op.imm, mode = SImm8) THEN RETURN ConstCast
				ELSIF ModeSize(mode)  = ConstSize(op.imm, mode = SImm8) THEN RETURN Hit
				ELSE RETURN NoMatch END
			ELSIF IsImmMode(op.mode) THEN
				IF ModeSize(mode)  > ModeSize(op.mode) THEN RETURN ConstCast
				ELSIF ModeSize(mode)  = ModeSize(op.mode) THEN RETURN Hit
				ELSE RETURN NoMatch END
			ELSE RETURN NoMatch END
		ELSIF mode = Const1 THEN
			IF IsImmMode(op.mode) & (op.imm = 1) THEN RETURN Hit ELSE RETURN NoMatch END
		ELSIF mode = Const3 THEN
			IF IsImmMode(op.mode) & (op.imm = 3) THEN RETURN Hit ELSE RETURN NoMatch END
		ELSIF IsMMode(mode) THEN
			IF IsMMode(op.mode) THEN
				IF ModeSize(op.mode)=ModeSize(mode) THEN RETURN Hit
				ELSIF (op.mode = M) OR (mode = M) THEN RETURN SizeCast
				ELSE RETURN NoMatch END
			ELSE RETURN NoMatch END
		ELSIF mode = SReg THEN
			IF IsSRegMode(op.mode,FALSE) THEN RETURN Hit ELSE RETURN NoMatch END
		ELSIF IsRelMode(mode) THEN
			IF (mode = Rel32) & (op.mode = FwdJmp) THEN RETURN Hit
			ELSIF IsImmMode(op.mode) THEN
				IF ModeSize(mode) = ConstSize(op.imm, TRUE) (*ModeSize(op.mode)*) THEN RETURN Hit
				ELSIF ModeSize(mode) > ConstSize(op.imm, TRUE) (*ModeSize(op.mode)*) THEN RETURN ConstCast
				ELSE RETURN NoMatch END
			ELSE RETURN NoMatch END 
			
		ELSIF mode = FReg THEN
			IF IsFRegMode(op.mode, TRUE) THEN RETURN Hit 
			ELSIF IsFRegMode(op.mode, FALSE) THEN RETURN TypeCast
			ELSE RETURN NoMatch END
		ELSE RETURN NoMatch
		END

	END Evaluate;
	
	
	PROCEDURE Match(VAR ind: INTEGER; VAR op: ARRAY OF Operand);
		VAR start, end, i, j, k, best: INTEGER;
		
	BEGIN

		start := InstrTab[ind].start; end := InstrTab[ind].end; ind := -1; best := 0;
		WHILE start < end DO
			i := Evaluate(op[0], OpTab[start].op[0]);
			IF (i = NoMatch) THEN 
			ELSE
				j := Evaluate(op[1], OpTab[start].op[1]);
				IF j = NoMatch  THEN i := NoMatch
				ELSE
					k := Evaluate(op[2], OpTab[start].op[2]);
					IF (i < j) & (i < k) THEN
					ELSIF j < k THEN i :=  j
					ELSE i := k
					END
				END
			END;

			IF i # NoMatch THEN
				IF i = Hit THEN ind := start; RETURN
				ELSIF i > best THEN ind := start; best := i
				ELSIF (i = best) & (i = SizeCast) THEN OPM.Mark(512, errpos); ind := -1; RETURN
				END
			END;
			INC(start)
		END;
		IF ind = -1 THEN OPM.Mark(501, errpos) END
	END Match;
	

(* ------------------------------------------------------------------- *)
(* Symbol Table / Instr Table / Op Table  functions *)

	PROCEDURE insert(VAR name: Name; VAR obj: Object);
		VAR ob0, ob1: Object; d: INTEGER;
	BEGIN ob0 := root; ob1 := ob0.right; d := 1;
		LOOP
			IF ob1 = NIL THEN (*insert undefined label*)
				NEW(ob1); ob1.name := name; ob1.typ := StFwdLabel;
				ob1.left := NIL; ob1.right := NIL; ob1.fix := NIL; ob1.obj := NIL;
				ob1.next := root.next; root.next := ob1;
				ob1.val := OPM.errpos;
				IF d < 0 THEN ob0.left := ob1 ELSE ob0.right := ob1 END;
			ELSIF name < ob1.name THEN d := -1; ob0 := ob1; ob1 := ob1.left
			ELSIF name > ob1.name THEN d :=  1; ob0 := ob1; ob1 := ob1.right
			ELSE (*found, no insertion*) EXIT END
		END;

		obj := ob1
	END insert;

	PROCEDURE find(VAR name: Name; VAR obj: Object);
		VAR ob0: Object; ob : OPT.Object;
	BEGIN ob0 := root.right;

		WHILE (ob0 # NIL) & (ob0.name # name) DO

			IF name < ob0.name THEN ob0 := ob0.left ELSE ob0 := ob0.right END
		END;

		obj := ob0;
		IF obj = NIL THEN
			COPY(name,OPS.name); OPT.Find(ob);
			IF ob # NIL THEN
				NEW(ob0);
				CASE ob.mode OF
				  1: (* Var *)
						ob0.val := 1; ob0.size := SizeTab[ob.typ.form];
						IF ob.mnolev <= 0 THEN
							ob0.typ := StGlobal
						ELSE
							ob0.typ := StVar 
						END
				| 2: (* VarPar *)
						ob0.typ := StVarPar; ob0.val := 1; ob0.size := 4
				| 3: (* Con *)
						ob0.typ := StConst; ob0.val := ob.conval.intval;
						IF (ob.typ.form > 6) OR (ob.typ.form = 2) THEN OPM.err(51)
						END
				| 5: (* Type *)
						ob0.typ := StType; ob0.size := SizeTab[ob.typ.form]; OPM.err(514)
				ELSE ob0.typ := StConst; ob0.val := 0; OPM.err(514)
				END;
				ob0.obj := ob; obj := ob0
			ELSE insert(name, obj)		(* create forward jump *)
			END;
		END;
	END find;

	(* Generates the hash index k for the n-th try. n>=0 *)
	PROCEDURE HashFn(VAR name: ARRAY OF CHAR; VAR k, n: INTEGER);
		VAR i: INTEGER;
	BEGIN
		IF n = 0 THEN
			i := 0; k := 0;
			WHILE name[i] # 0X DO
				k := (k*16 + ORD(name[i])) MOD InstrTabLen; INC(i)
			END;
			n := 1
		ELSE
				k := (k + n) MOD InstrTabLen; INC(n, 1)
		END
	END HashFn;
	
	PROCEDURE FindInstruction(VAR name: ARRAY OF CHAR; VAR inx: INTEGER);
		VAR n: INTEGER;
	BEGIN
		n := 0;
		REPEAT
			HashFn(name, inx, n)
		UNTIL (name = InstrTab[inx].name) OR (InstrTab[inx].name[0] = 0X) OR (n >InstrTabLen);
		IF (InstrTab[inx].name[0] = 0X) OR (n >InstrTabLen) THEN inx := -1 END
	END FindInstruction;
	
(* ------------------------------------------------------------------- *)
(* Scanner functions *)

	PROCEDURE skipBlanks;
	BEGIN
		WHILE (OPS.ch = SPACE) OR (OPS.ch = TAB) DO OPM.Get(OPS.ch) END;
		IF OPS.ch = ";" THEN
			WHILE (OPS.ch # CR) DO OPM.Get(OPS.ch) END	(* Skip comments *)
		END
	END skipBlanks;

	PROCEDURE GetIdent(VAR name: Name);
		VAR i: INTEGER;
	BEGIN i := 0; OPM.errpos := OPM.curpos - 1;
		REPEAT
			IF i < NameLen-1 THEN name[i] := OPS.ch; INC(i) END;
			OPM.Get(OPS.ch)
		UNTIL ~(("A" <= CAP(OPS.ch)) & (CAP(OPS.ch) <= "Z") OR ("0" <= OPS.ch) & (OPS.ch <= "9"));
		name[i] := 0X
	END GetIdent;

	PROCEDURE Get(VAR sym: INTEGER);
	
		PROCEDURE Comment;
		BEGIN

			OPM.Get(OPS.ch);	(* skip "*" *)
			REPEAT
				REPEAT
					OPM.Get(OPS.ch);
					IF OPS.ch = "(" THEN
						OPM.Get(OPS.ch);
						IF OPS.ch = "*" THEN Comment END
					END;
				UNTIL (OPS.ch = "*") OR (OPS.ch = OPM.Eot);
				OPM.Get(OPS.ch)
			UNTIL (OPS.ch = ")") OR (OPS.ch = OPM.Eot);
			OPM.Get(OPS.ch)

		END Comment;
		
		PROCEDURE Str;
			VAR och: CHAR; i: LONGINT;
		BEGIN
			och := OPS.ch; i := 0;
			LOOP
				OPM.Get(OPS.ch);
				IF OPS.ch = och THEN EXIT
				ELSIF OPS.ch < " " THEN OPM.err(3); EXIT
				ELSIF i = MaxStrLen-1 THEN OPM.err(241); EXIT
				END;
				str[i] := OPS.ch; INC(i)
			END;
			OPM.Get(OPS.ch);
			str[i] := 0X; val := i;
		END Str;
		
	BEGIN
		skipBlanks;
		OPM.errpos := OPM.curpos;
		CASE OPS.ch OF
		  "A" .. "Z", "a" .. "z" :
				GetIdent(ident); 
				IF OPS.ch = ":" THEN 
					OPM.Get(OPS.ch); sym := ScLabel
        		ELSIF ident = "END" THEN
        			sym := ScEnd
        		ELSE
					sym := ScIdent(*; find(ident, obj);
					IF obj # NIL THEN type := SHORT(obj.typ); val := obj.val 
					ELSE type := none END*)
				END
		| "0".."9":
				val := 0; sym := ScNumber;
				OPS.Number;
				ASSERT(OPS.numtyp <= 2);
				val := OPS.intval
		| ";":   OPM.Get(OPS.ch); sym := ScSemicolon
		| "@": OPM.Get(OPS.ch); sym := ScAt
		| ",":   OPM.Get(OPS.ch); sym := ScComma
		| "[":   OPM.Get(OPS.ch); sym := ScLBrak
		| "]":   OPM.Get(OPS.ch); sym := ScRBrak
		| CR:	OPM.Get(OPS.ch); sym := ScCR
		| "*":	OPM.Get(OPS.ch); sym := ScMult
		| "/":	OPM.Get(OPS.ch); sym := ScDiv
		| "+":	OPM.Get(OPS.ch); sym := ScPlus
		| "-":	OPM.Get(OPS.ch); sym := ScMinus
		| "(":   OPM.Get(OPS.ch);
					IF OPS.ch = "*" THEN Comment; Get(sym)
					ELSE sym := ScLPar
					END;
		| ")":   OPM.Get(OPS.ch); sym := ScRPar
		| ":":	OPM.Get(OPS.ch); sym := ScColon
		| 22X, 27X: Str; sym := ScString;
		ELSE  sym := ScUndef; OPM.Get(OPS.ch)
		END

	END Get;
	
	PROCEDURE Check(s: INTEGER);
	BEGIN IF sym # s THEN OPM.err(s) END;
		Get(sym)
	END Check;

	PROCEDURE ^ Expression(VAR x: LONGINT);

	PROCEDURE Factor(VAR x: LONGINT);
	BEGIN
		IF sym = ScNumber THEN x := val; Get(sym)
		ELSIF sym = ScLPar THEN
			Get(sym); Expression(x);
			Check(ScRPar)
		ELSE OPM.err(601)
		END
	END Factor;

	PROCEDURE Term(VAR x: LONGINT);
		VAR y: LONGINT; op : INTEGER;
	BEGIN
		Factor(x);
		WHILE (sym = ScMult) OR (sym = ScDiv) DO
			op := sym; Get(sym);
			Factor(y);
			IF op = ScMult THEN x := x * y ELSE x := x DIV y END
		END
	END Term;

	PROCEDURE Expression(VAR x: LONGINT);
		VAR y: LONGINT; op : INTEGER;
	BEGIN
		IF sym = ScMinus THEN op := sym; Get(sym); Term(x); x := -x
		ELSE Term(x)
		END;
		WHILE (sym = ScPlus) OR (sym = ScMinus) DO
			op := sym; Get(sym);
			Term(y);
			IF op = ScPlus THEN x := x + y ELSE x := x - y END
		END
	END Expression;

	PROCEDURE GetBaseIndex(VAR o: Operand; size: LONGINT);
		VAR obj: Object;
	BEGIN
		CASE size OF
			  0: o.mode := M
			| 1: o.mode := M8
			| 2: o.mode := M16
			| 4: o.mode := M32
			| 8: o.mode := M64
			| 10: o.mode := M80
		END;
		o.disp := o.imm; o.imm := 0;		(* this is not a const but a rm !! *)
		WHILE (sym = ScLBrak) OR (sym = ScPlus) DO
			Get(sym);
			IF sym = ScIdent THEN find(ident, obj) ELSE obj := NIL END;
			IF (obj = NIL) OR ~IsRegMode(obj.typ, FALSE) OR (ModeSize(obj.typ) # 4) THEN 
				OPM.err(506); RETURN
			END;
			Get(sym);
			IF sym = ScMult THEN		(* This is the index, get the scale *)
				IF o.index # none THEN OPM.err(509); RETURN END;
				o.index := SHORT(obj.val);
				Get(sym);
				IF (sym # ScNumber) OR ((val # 1) & (val # 2) & (val # 4) & (val # 8)) THEN 
					OPM.err(508); RETURN
				END;
				o.scale := SHORT(val);
				Get(sym);
			ELSIF (sym = ScRBrak) OR (sym = ScPlus) THEN
				IF o.base = none THEN o.base := SHORT(obj.val)
				ELSIF o.index = none THEN o.index := SHORT(obj.val)
				ELSE OPM.err(509)
				END;
			ELSE OPM.err(510); RETURN
			END;
			IF sym = ScRBrak THEN Get(sym) END
		END; (* WHILE ScLBrak *)
		END GetBaseIndex;

	PROCEDURE GetOperand(VAR o: Operand);
		VAR obj: Object; size: LONGINT;
	BEGIN
		o.reg := none; o.disp := 0; o.base := none; o.index := none; o.imm := 0;
		o.seg := none; o.scale := none; o.obj := NIL;
		size := 0;	(* unknown size *)
		IF sym = ScIdent THEN
			find(ident, obj);
			IF (obj # NIL) & (obj.typ = SReg) THEN
				o.seg := SHORT(obj.val); Get(sym); Check(ScColon);
				IF sym = ScIdent THEN find(ident, obj) END
			END
		END;
		IF (sym = ScIdent) & (obj # NIL) & (obj.typ = StType) THEN
			size := SHORT(obj.size); Get(sym);
			IF (sym # ScIdent) OR (ident # "PTR") THEN (* OPM.err(511) *)	(* PTR is optional *)
			ELSE Get(sym)
			END;
			IF sym = ScIdent THEN find(ident, obj) END
		END;
		CASE sym OF
		  ScAt:
				Get(sym);
				IF sym # ScNumber THEN OPM.err(-601) END;
				o.disp := val; o.mode := RM32;
				Get(sym);
		| ScLBrak:
				GetBaseIndex(o, size)
		| ScIdent, ScNumber, ScMinus:

				IF sym = ScIdent THEN
					IF obj = NIL THEN OPM.err(500); RETURN END;
					
					IF size = 0 THEN size := obj.size END;		(* don't override the xyz PTR command *)
					
					IF IsRegMode(obj.typ, FALSE) THEN
						o.mode := obj.typ; o.reg := SHORT(obj.val); Get(sym); RETURN
					ELSIF IsSRegMode(obj.typ, FALSE) THEN
						o.mode := obj.typ; o.reg := SHORT(obj.val); Get(sym); RETURN
					ELSIF IsSpecRegMode(obj.typ) THEN
						o.mode := obj.typ; o.reg := SHORT(obj.val); Get(sym); RETURN
					ELSIF IsFRegMode(obj.typ, FALSE) THEN
						o.mode := obj.typ; Get(sym);
						IF sym = ScLPar THEN Expression(size); o.reg := SHORT(size) ELSE o.reg := 0; o.mode := FRegST END;
						RETURN
					ELSIF obj.typ = StLabel THEN
						o.imm := obj.val; o.mode := Rel8; Get(sym); RETURN
					ELSIF obj.typ = StFwdLabel THEN
						o.obj := obj; o.mode := FwdJmp; Get(sym); RETURN
					ELSIF obj.typ = StConst THEN
						o.imm := obj.val; Get(sym);
					ELSIF (obj.typ = StVar) OR (obj.typ = StVarPar) THEN
						o.imm := obj.val; o.obj := obj; Get(sym)
					ELSIF (obj.typ = StGlobal) THEN
						o.disp := 012345678H; o.obj := obj; 
						CASE size OF
						  1: o.mode := M8
						| 2: o.mode := M16
						| 4: o.mode := M32
						| 8: o.mode := M64
						| 10: o.mode := M80
						ELSE o.mode := M32
						END;
						Get(sym); RETURN		(* Global Var *)
					ELSE OPM.err(600); RETURN END
				ELSE Expression(o.imm)
				END;

				CASE size OF
				  1: o.mode := Imm8
				| 2: o.mode := Imm16
				| 4: o.mode := Imm32
				ELSE o.mode := Imm
				END;
				IF sym = ScLBrak THEN GetBaseIndex(o, size) END;
		ELSE
			o.mode := none; OPM.err(511)
		END;  (* CASE sym OF *)
	END GetOperand;
	
(* ------------------------------------------------------------------- *)
(* Fixpoint handling functions *)

	PROCEDURE CheckLabels;
		VAR obj, obj1, obj2: Object;
	BEGIN obj1 := root.next; obj := NIL; (* invert list *)
		WHILE obj1 # NIL DO
			obj2 := obj1.next; obj1.next := obj; obj := obj1; obj1 := obj2
		END;
		WHILE obj # NIL DO
			IF obj.typ = StFwdLabel THEN
				OPM.Mark(128, obj.val)	(* unsatisfied forward reference *)
			END;
			obj := obj.next
		END
	END CheckLabels;

	PROCEDURE InsertFix(VAR obj: Object; pc: LONGINT);
		VAR fix: FixPnt; x: OPT.Node;
	BEGIN
		CASE obj.typ OF
		  StFwdLabel:
			NEW(fix); fix.pc := pc;
			fix.node := last;
			fix.pos := ORD(last.conval.ext[0])-3;	(* displacement position *)
			fix.next := obj.fix; obj.fix := fix
		| StVar, StVarPar, StGlobal:
			x := OPT.NewNode(Nfixup);
			x.obj := obj.obj; x.conval := OPT.NewConst();
			x.conval.intval := pc; x.conval.intval2 := OPM.errpos;
			x.link := fixlist; fixlist := x
		ELSE
			OPM.err(607)
		END
	END InsertFix;

	PROCEDURE FixDisp(VAR fix: FixPnt);
		VAR pos, disp: LONGINT;
	BEGIN
		disp := pc - fix.pc;
		FOR pos := fix.pos TO fix.pos+3 DO
			fix.node.conval.ext[pos] := CHR(disp);
			disp := disp DIV 256
		END;
	END FixDisp;
	
(* ------------------------------------------------------------------- *)
(* Code Generation functions *)

PROCEDURE NewNode;
	VAR x: OPT.Node;
BEGIN
	x := OPT.NewNode(Ncode); x.conval := OPT.NewConst();
	x.conval.ext := OPT.NewExt(); x.conval.ext[0] := 0X;	(* Instr length *)
	x.conval.intval := OPM.errpos;
	OPB.Link(first, last, x)
END NewNode;

PROCEDURE PutByte(b: LONGINT);
	VAR pos: INTEGER;
BEGIN
	pos := ORD(last.conval.ext[0]) + 1;
	IF pos > 255 THEN
		NewNode; pos := 1
	END;
	last.conval.ext[pos] := CHR(b);
	last.conval.ext[0] := CHR(pos);
	INC(pc)
END PutByte;

PROCEDURE PutBytes(b, size: LONGINT);
	VAR pos: INTEGER;
BEGIN
	pos := ORD(last.conval.ext[0]);
	IF pos > 255-size THEN
		NewNode; pos := 0
	END;
	WHILE size>0 DO
		INC(pos); last.conval.ext[pos] := CHR(b);
		b := b DIV 256; INC(pc); DEC(size);
	END;
	last.conval.ext[0] := CHR(pos)
END PutBytes;

PROCEDURE ModRM(VAR modrm: LONGINT; VAR op: Operand; mode: INTEGER; UseSpecReg: BOOLEAN);
	VAR mod: LONGINT;
BEGIN

	IF (IsRegMode(mode,TRUE) & ~UseSpecReg) OR IsSRegMode(mode, FALSE) OR IsSpecRegMode(mode) THEN 
		(* put reg index into the reg/opcode field *)
		ASSERT(op.reg # none);
		modrm := modrm + op.reg * 8H;
	ELSIF IsModRmMode(mode) OR IsMMode(mode) OR (IsRegMode(mode,TRUE) & UseSpecReg) THEN
		IF op.reg # none THEN
			(* put reg index into the r/m field, 3H into the Mod field *)
			modrm := modrm + op.reg + 0C0H;
		ELSE
			(* set the mod field *)
			IF (op.disp = 0) & ~((op.base = 5) & (op.index = none)) THEN 	(* avoid case 0[EBP] *)
				mod := 0
			ELSIF ConstSize(op.disp, TRUE)=1 THEN
				mod := 1
			ELSIF (op.base = none) & (op.index = none) THEN
				mod := 0
			ELSE
				mod := 2
			END;
			modrm := modrm + mod * 40H;
			IF op.index # none THEN
				modrm := modrm + 4		(* use the sib byte *)
			ELSIF op.base # none THEN
				modrm := modrm + op.base
			ELSE 
				modrm := modrm + 5			(* special case: disp32 *)
			END
		END
	ELSE OPM.err(1000)
	END
END ModRM;

PROCEDURE SIB(op: Operand): SHORTINT;
	VAR val: INTEGER;
BEGIN
	IF op.index = 5 THEN 	(* ESP not allowed *)
		OPM.err(501)
	ELSIF op.index # none THEN
		val := op.base + op.index*08H;
		CASE op.scale OF
		  none, 1: 
		|2: val := val + 1 * 40H
		|4: val := val + 2 * 40H
		|8: val := val + 3 * 40H
		END
	ELSE
		val := op.base + 04H*08H;
	END;
	RETURN(SHORT(val))
END SIB;

PROCEDURE GenCode(ind: INTEGER; VAR op: ARRAY OF Operand);
	VAR i: LONGINT; name: Mnemo; fixobj: Object;
		UseRM, UseImm, UseSpecReg, UseSegReg, UseDisp: BOOLEAN; seg, reg, modrm, sib, imm, immSize, disp: LONGINT;
BEGIN
(* Initialisation *)
	disp := 0;
	IF IsRelMode(op[0].mode) THEN		(* compute the size of the rel operand *)
		CASE ConstSize(op[0].imm-2 - pc, TRUE) OF		(* +2 = place for prefix & opcode0 *)
		  1: op[0].mode := Rel8
		| 2, 4: op[0].mode := Rel32
		END
	END;
	COPY(InstrTab[ind].name, name);
	
	Match(ind, op);
	


	IF ind < 0 THEN RETURN END;	(* no matching opcode found *)
	
(* Instruction prefix *)
	UseSpecReg := IsSpecRegMode(OpTab[ind].op[0]) OR IsSpecRegMode(OpTab[ind].op[1]);
	UseSegReg := IsSRegMode(OpTab[ind].op[0], FALSE) OR IsSRegMode(OpTab[ind].op[1], FALSE);
	
		IF (ModeSize(OpTab[ind].op[0]) = 2) & ~UseSpecReg & ~UseSegReg THEN	(* 16-bit mode *)
	(* address-size prefix
			special cases:
				LEA/OUTS with 16-bit source
	*)
			IF (OpTab[ind].op[0] = Rel16) OR (((name ="LEA")OR(name="OUTS")) & (OpTab[ind].op[1] = RM16)) THEN PutByte(67H);
	(* operand size prefix *)
			ELSIF (name # "RET") & (name # "ARPL") & (name # "STR") THEN PutByte(66H) 
			END
		END;
		
(* prepare the instruction*)
		seg := none; reg := none; modrm := 0; UseRM := FALSE; sib := none;
		UseImm := FALSE; fixobj := NIL;
		UseDisp := FALSE;
		i := 0;
		WHILE (i<3) & (OpTab[ind].op[i] # none) DO
			(* segment prefix *)
			IF op[i].seg # none THEN

				IF seg # none THEN OPM.err(504) ELSE seg := op[i].seg END;
			END;
			(* register to be added to the opcode *)
			IF (OpTab[ind].reg = OmOp) & (IsRegMode(OpTab[ind].op[i], TRUE) OR IsFRegMode(OpTab[ind].op[i], TRUE)) THEN

				reg := op[i].reg
			END;
			(* modrm byte *)
			IF NeedModRM(OpTab[ind].op[i], OpTab[ind].reg) THEN

				ModRM(modrm, op[i], OpTab[ind].op[i], UseSpecReg); UseRM := TRUE; 
				IF IsModRmMode(OpTab[ind].op[i]) OR IsMMode(OpTab[ind].op[i]) THEN 
					disp := op[i].disp; fixobj := op[i].obj;
					UseDisp := (disp # 0) OR ((op[i].base = 5) & (op[i].index = none))
				END
			END;
			(* sib byte *)
			IF (op[i].index # none) OR (op[i].base = 4) THEN			(* process the escape ESP *)

				ASSERT (sib = none);
				sib := SIB(op[i])
			END;
			IF IsImmMode(OpTab[ind].op[i]) OR (IsRelMode(OpTab[ind].op[i]) & IsImmMode(op[i].mode)) THEN

				ASSERT( ~UseImm);
				UseImm := TRUE; imm := op[i].imm; immSize := ModeSize(OpTab[ind].op[i]) 
			END;
			INC(i);
		END;


(* segment override *)
		IF seg # none THEN PutByte(seg) END;
		
(* opcode *)
		IF reg = none THEN reg := 0 END;
		IF OpTab[ind].op1 # none THEN
			PutByte(OpTab[ind].op0); PutByte(OpTab[ind].op1 + reg)
		ELSE
			PutByte(OpTab[ind].op0 + reg)
		END;

	(* modr/m *)
		IF OpTab[ind].opc # none THEN
			ASSERT( AND(modrm, 38H) = 0);		(* reg/opcode field not used *)
			modrm := modrm + OpTab[ind].opc * 8H;
			UseRM := TRUE
		END;
		IF UseRM THEN PutByte(modrm) END;
		
	(* sib *)
		IF sib # none THEN PutByte(sib) END;
		
	(* displacement / immediate *)
		IF  UseDisp THEN
			IF fixobj # NIL THEN InsertFix(fixobj, pc) END;
			IF ConstSize(disp, TRUE) = 1 THEN PutByte(disp) ELSE PutBytes(disp, 4) END
		END;
		IF IsRelMode(OpTab[ind].op[0]) & ~IsImmMode(op[0].mode) THEN
			PutBytes(op[0].imm-pc-ModeSize(OpTab[ind].op[0]), ModeSize(OpTab[ind].op[0]));
			IF op[0].mode = FwdJmp THEN InsertFix(op[0].obj, pc) END
		END;
		IF UseImm THEN PutBytes(imm, immSize) END;
END GenCode;


(* ------------------------------------------------------------------- *)
(* Parser functions *)

	PROCEDURE ParseLabel;
		VAR obj: Object; fix: FixPnt;
	BEGIN

		ASSERT(sym = ScLabel);		(* Test done by the caller *)
		insert(ident, obj);
		IF obj.typ = StFwdLabel THEN
			fix := obj.fix;
			WHILE fix # NIL DO
				FixDisp(fix); fix := fix.next
			END;
			obj.typ := StLabel; obj.val := pc
		ELSE OPM.err(512)
		END;
		Get(sym)
	END ParseLabel;

	PROCEDURE ParseInstruction;
		VAR	ind, size: INTEGER; i: LONGINT; op: ARRAY 3 OF Operand; name: Name;
	BEGIN

		(* Read Mnemonic *)
			IF (ident = "DB") OR (ident = "DW") OR (ident = "DD") THEN
				CASE ident[1] OF
				   "B": size := 1
				| "W": size := 2
				| "D": size := 4
				END;
				Get(sym);
				WHILE (sym = ScNumber) OR (sym = ScString) DO
					IF (sym = ScString) & (val = 1) THEN PutBytes(ORD(str[0]), size)
					ELSIF (sym = ScNumber) & (ConstSize(val, FALSE) <= size) THEN PutBytes(val, size)
					ELSE OPM.err(203)
					END;
					Get(sym);
					IF sym = ScComma THEN Get(sym) 
					ELSE RETURN
					END
				END
			ELSIF (ident = "DS") THEN
				Get(sym);
				IF (sym = ScString) THEN
					FOR i := 0 TO val DO PutBytes(ORD(str[i]), 1) END;
					Get(sym)
				ELSE OPM.err(513)
				END
			ELSE
				FOR i := 0 TO 2 DO op[i].mode := none END;
				FindInstruction(ident, ind);	(* index in the hash tab *)
				COPY(ident, name);
				errpos := OPM.errpos;
				Get(sym);
				IF ind < 0 THEN OPM.err(502); RETURN END;
				
				name[3] := 0X;
				IF name = "REP" THEN	(* REP/REPE/REPZ/REPNE/REPNZ *)
					GenCode(ind, op);
					IF sym = ScCR THEN Get(sym) END;		(* there should be no label here *)
					FindInstruction(ident, ind);	(* index in the hash tab *)
					errpos := OPM.errpos;
					Get(sym);
					IF ind < 0 THEN OPM.err(502); RETURN END
				END;
				
				i := 0;
				IF sym # ScCR THEN
					LOOP
						GetOperand(op[i]); INC(i);
						IF sym # ScComma THEN EXIT END;
						Get(sym)
					END
				END;
				
				GenCode(ind, op);
			END (* IF DB *)
	END ParseInstruction;
(* ------------------------------------------------------------------- *)
(* Initialisation functions *)

	PROCEDURE InsertReg(name: Name; t, v: INTEGER);
		VAR obj: Object;
	BEGIN
		insert(name, obj); obj.typ := t; obj.val := v; obj.size := 0
	END InsertReg;
	
	PROCEDURE InsertType(name: Name; s: INTEGER);
		VAR obj: Object;
	BEGIN
		insert(name, obj); obj.typ := StType; obj.val := none; obj.size := s
	END InsertType;

	PROCEDURE InsertMnemo(name: Mnemo; VAR k: INTEGER);
		VAR n: INTEGER;
	BEGIN
		n := 0;
		REPEAT HashFn(name, k, n)
		UNTIL (InstrTab[k].name[0] = 0X) OR (n > 2*InstrTabLen) OR (InstrTab[k].name = name);
		IF n > 2*InstrTabLen THEN
			OPM.LogWStr("iASM, internal instruction table too small!!"); OPM.LogWLn
		END;
		IF InstrTab[k].name = name THEN 
			OPM.LogWStr(name); OPM.LogWStr(" already in the table"); OPM.LogWLn;
			RETURN
		END;
		COPY(name, InstrTab[k].name);
		InstrTab[k].start := OpTabN; InstrTab[k].end := OpTabN

	END InsertMnemo;
	
	PROCEDURE InsertAlias(name, alias: Mnemo);
		VAR n,a: INTEGER;
	BEGIN
		FindInstruction(name, n);
		IF n = -1 THEN OPM.LogWStr("InsertAlias: the name doesn't exist "); OPM.LogWStr(name); OPM.LogWLn; RETURN END;
		InsertMnemo(alias, a);
		InstrTab[a].start := InstrTab[n].start; InstrTab[a].end := InstrTab[n].end;
	END InsertAlias;
	
	PROCEDURE InsertOp3(idx, dest, src, o3, op0, op1, opc, om: INTEGER);
		VAR pos: INTEGER;
	BEGIN
		pos := InstrTab[idx].end;
		IF OpTab[pos].op0 # -1 THEN OPM.LogWStr("Op Table, overwriting"); OPM.LogWLn END;
		OpTab[pos].op[0] := dest; OpTab[pos].op[1] := src; OpTab[pos].op[2] := o3;	(* dest / src addressing mode *)
		OpTab[pos].op0 := op0; OpTab[pos].op1 := op1;	(* opcodes *)
		OpTab[pos].opc := opc; OpTab[pos].reg := om;	(* opcode modifier (rm.opcode) / register storing place (opcode /rm byte) *)
		IF OpTabN < OpTabLen-1 THEN INC(InstrTab[idx].end); INC(OpTabN)
		ELSE OPM.LogWStr("Op Table FULL"); OPM.LogWLn
		END
	END InsertOp3;
	
	PROCEDURE InsertOp(idx, dest, src, op0, op1, opc, om: INTEGER);
		VAR pos: INTEGER;
	BEGIN
		pos := InstrTab[idx].end;
		IF OpTab[pos].op0 # -1 THEN OPM.LogWStr("Op Table, overwriting"); OPM.LogWLn END;
		OpTab[pos].op[0] := dest; OpTab[pos].op[1] := src; OpTab[pos].op[2] := none;	(* dest / src addressing mode *)
		OpTab[pos].op0 := op0; OpTab[pos].op1 := op1;	(* opcodes *)
		OpTab[pos].opc := opc; OpTab[pos].reg := om;	(* opcode modifier (rm.opcode) / register storing place (opcode /rm byte) *)
		IF OpTabN < OpTabLen-1 THEN INC(InstrTab[idx].end); INC(OpTabN)
		ELSE OPM.LogWStr("Op Table FULL"); OPM.LogWLn
		END
	END InsertOp;
	
	PROCEDURE Init;
	BEGIN 
		(* Internal Symbol-Table *)
			root.next := NIL; root.left := NIL; root.right := NIL;
			InsertReg("AL", RegAL, 0); InsertReg("AH", Reg8, 4);
			InsertReg("AX", RegAX, 0); InsertReg("EAX", RegEAX, 0);
			InsertReg("BL", Reg8, 3); InsertReg("BH", Reg8, 7);
			InsertReg("BX", Reg16, 3); InsertReg("EBX", Reg32, 3);
			InsertReg("CL", Reg8, 1); InsertReg("CH", Reg8, 5);
			InsertReg("CX", Reg16, 1); InsertReg("ECX", Reg32, 1);
			InsertReg("DL", Reg8, 2); InsertReg("DH", Reg8, 6);
			InsertReg("DX", Reg16, 2); InsertReg("EDX", Reg32, 2);
			InsertReg("SP", Reg16, 4); InsertReg("ESP", Reg32, 4);
			InsertReg("BP", Reg16, 5); InsertReg("EBP", Reg32, 5);
			InsertReg("SI", Reg16, 6); InsertReg("ESI", Reg32, 6);
			InsertReg("DI", Reg16, 7); InsertReg("EDI", Reg32, 7);
			
			InsertReg("CS", RegCS, 1H); InsertReg("SS", RegSS, 2H);
			InsertReg("DS", RegDS, 3H); InsertReg("ES", RegES, 0H);
			InsertReg("FS", RegFS, 4H); InsertReg("GS", RegGS, 5H);
			
			InsertReg("CR0", CRReg, 0); InsertReg("CR2", CRReg, 2); InsertReg("CR3", CRReg, 3);
			InsertReg("DR0", DRReg, 0); InsertReg("DR1", DRReg, 1); InsertReg("DR2", DRReg, 2);
			InsertReg("DR3", DRReg, 3); InsertReg("DR6", DRReg, 6); InsertReg("DR7", DRReg, 7);
			InsertReg("TR6", TRReg, 6); InsertReg("TR7", TRReg, 7);
			
			InsertReg("ST", FReg, 0);

			InsertType("BYTE", 1);
			InsertType("WORD", 2);
			InsertType("DWORD", 4);
			InsertType("QWORD", 8);
			InsertType("TBYTE", 10);
			
		(* Synchronizing scanner *)
			WHILE OPS.ch # CR DO OPM.Get(OPS.ch) END;
		
		(* Global variables *)
			pc := 0;
	END Init;
	
	PROCEDURE Close;
	BEGIN root.right := NIL;
	END Close;

	PROCEDURE InsertFloatInstr;
		VAR k: INTEGER;
	BEGIN
		
		InsertMnemo("F2XM1", k);
		InsertOp(k, none, none, 0D9H, 0F0H, none, none);
		
		InsertMnemo("FABS", k);
		InsertOp(k, none, none, 0D9H, 0E1H, none, none);
		
		InsertMnemo("FADD", k);
		InsertOp(k, M32, none, 0D8H, none, 0, none);
		InsertOp(k, M64, none, 0DCH, none, 0, none);
		InsertOp(k, FRegST, FReg, 0D8H, 0C0H, none, OmOp);
		InsertOp(k, FReg, FRegST, 0DCH, 0C0H, none, OmOp);

		InsertMnemo("FADDP", k);
		InsertOp(k, FReg, FRegST, 0DEH, 0C0H, none, OmOp);
		InsertOp(k, none, none, 0DEH, 0C1H, none, none);

		InsertMnemo("FIADD", k);
		InsertOp(k, M32, none, 0DAH, none, 0, none);
		InsertOp(k, M16, none, 0DEH, none, 0, none);

		InsertMnemo("FBLD", k);
		InsertOp(k, M80, none, 0DFH, none, 4, none);
		
		InsertMnemo("FBSTP", k);
		InsertOp(k, M80, none, 0DFH, none, 6, none);
		
		InsertMnemo("FCHS", k);
		InsertOp(k, none, none, 0D9H, 0E0H, none, none);

		InsertMnemo("FNCLEX", k);
		InsertOp(k, none, none, 0DBH, 0E2H, none, none);

		InsertMnemo("FCOM", k);
		InsertOp(k, M32, none, 0D8H, none, 2, none);
		InsertOp(k, M64, none, 0DCH, none, 2, none);
		InsertOp(k, FReg, none, 0D8H, 0D0H, none, OmOp);
		InsertOp(k, none, none, 0DCH, 0D1H, none, none);

		InsertMnemo("FCOMP", k);
		InsertOp(k, M32, none, 0D8H, none, 3, none);
		InsertOp(k, M64, none, 0DCH, none, 3, none);
		InsertOp(k, FReg, none, 0D8H, 0D8H, none, OmOp);
		InsertOp(k, none, none, 0D8H, 0D9H, none, none);

		InsertMnemo("FCOMPP", k);
		InsertOp(k, none, none, 0DEH, 0D9H, none, none);
		
		InsertMnemo("FCOS", k);
		InsertOp(k, none, none, 0D9H, 0FFH, none, none);
		
		InsertMnemo("FDECSTP", k);
		InsertOp(k, none, none, 0D9H, 0F6H, none, none);
		
		InsertMnemo("FDIV", k);
		InsertOp(k, M32, none, 0D8H, none, 6, none);
		InsertOp(k, M64, none, 0DCH, none, 6, none);
		InsertOp(k, FRegST, FReg, 0D8H, 0F0H, none, OmOp);
		InsertOp(k, FReg, FRegST, 0DCH, 0F8H, none, OmOp);

		InsertMnemo("FDIVP", k);
		InsertOp(k, FReg, FRegST, 0DEH, 0F8H, none, OmOp);
		InsertOp(k, none, none, 0DEH, 0F9H, none, none);

		InsertMnemo("FIDIV", k);
		InsertOp(k, M32, none, 0DAH, none, 6, none);
		InsertOp(k, M16, none, 0DEH, none, 6, none);

		InsertMnemo("FDIVR", k);
		InsertOp(k, M32, none, 0D8H, none, 7, none);
		InsertOp(k, M64, none, 0DCH, none, 7, none);
		InsertOp(k, FRegST, FReg, 0D8H, 0F8H, none, OmOp);
		InsertOp(k, FReg, FRegST, 0DCH, 0F0H, none, OmOp);

		InsertMnemo("FDIVRP", k);
		InsertOp(k, FReg, FRegST, 0DEH, 0F0H, none, OmOp);
		InsertOp(k, none, none, 0DEH, 0F1H, none, none);

		InsertMnemo("FIDIVR", k);
		InsertOp(k, M32, none, 0DAH, none, 7, none);
		InsertOp(k, M16, none, 0DEH, none, 7, none);

		InsertMnemo("FFREE", k);
		InsertOp(k, none, none, 0DDH, 0C0H, none, OmOp);

		InsertMnemo("FICOM", k);
		InsertOp(k, M16, none, 0DEH, none, 2, none);
		InsertOp(k, M32, none, 0DAH, none, 2, none);

		InsertMnemo("FICOMP", k);
		InsertOp(k, M16, none, 0DEH, none, 3, none);
		InsertOp(k, M32, none, 0DAH, none, 3, none);

		InsertMnemo("FILD", k);
		InsertOp(k, M16, none, 0DFH, none, 0, none);
		InsertOp(k, M32, none, 0DBH, none, 0, none);
		InsertOp(k, M64, none, 0DFH, none, 5, none);
		
		InsertMnemo("FINCSTP", k);
		InsertOp(k, none, none, 0D9H, 0F7H, none, none);
		
		InsertMnemo("FNINIT", k);
		InsertOp(k, none, none, 0DBH, 0E3H, none, none);

		InsertMnemo("FIST", k);
		InsertOp(k, M16, none, 0DFH, none, 2, none);
		InsertOp(k, M32, none, 0DBH, none, 2, none);

		InsertMnemo("FISTP", k);
		InsertOp(k, M16, none, 0DFH, none, 3, none);
		InsertOp(k, M32, none, 0DBH, none, 3, none);
		InsertOp(k, M64, none, 0DFH, none, 7, none);

		InsertMnemo("FLD", k);
		InsertOp(k, M32, none, 0D9H, none, 0, none);
		InsertOp(k, M64, none, 0DDH, none, 0, none);
		InsertOp(k, M80, none, 0DBH, none, 5, none);
		InsertOp(k, FReg, none, 0D9H, 0C0H, none, OmOp);
		
		InsertMnemo("FLD1", k);
		InsertOp(k, none, none, 0D9H, 0E8H, none, none);

		InsertMnemo("FLDL2T", k);
		InsertOp(k, none, none, 0D9H, 0E9H, none, none);
		
		InsertMnemo("FLDL2E", k);
		InsertOp(k, none, none, 0D9H, 0EAH, none, none);

		InsertMnemo("FLDPI", k);
		InsertOp(k, none, none, 0D9H, 0EBH, none, none);

		InsertMnemo("FLDLG2", k);
		InsertOp(k, none, none, 0D9H, 0ECH, none, none);

		InsertMnemo("FLDLN2", k);
		InsertOp(k, none, none, 0D9H, 0EDH, none, none);

		InsertMnemo("FLDZ", k);
		InsertOp(k, none, none, 0D9H, 0EEH, none, none);

		InsertMnemo("FLDCW", k);
		InsertOp(k, M, none, 0D9H, none, 5, none);

		InsertMnemo("FLDENV", k);
		InsertOp(k, M, none, 0D9H, none, 4, none);

		InsertMnemo("FMUL", k);
		InsertOp(k, M32, none, 0D8H, none, 1, none);
		InsertOp(k, M64, none, 0DCH, none, 1, none);
		InsertOp(k, FRegST, FReg, 0D8H, 0C8H, none, OmOp);
		InsertOp(k, FReg, FRegST, 0DCH, 0C8H, none, OmOp);

		InsertMnemo("FMULP", k);
		InsertOp(k, FReg, FRegST, 0DEH, 0C8H, none, OmOp);
		InsertOp(k, none, none, 0DEH, 0C9H, none, none);

		InsertMnemo("FIMUL", k);
		InsertOp(k, M32, none, 0DAH, none, 1, none);
		InsertOp(k, M16, none, 0DEH, none, 1, none);

		InsertMnemo("FNOP", k);
		InsertOp(k, none, none, 0D9H, 0D0H, none, none);

		InsertMnemo("FPATAN", k);
		InsertOp(k, none, none, 0D9H, 0F3H, none, none);

		InsertMnemo("FPREM", k);
		InsertOp(k, none, none, 0D9H, 0F8H, none, none);

		InsertMnemo("FPREM1", k);
		InsertOp(k, none, none, 0D9H, 0F5H, none, none);

		InsertMnemo("FPTAN", k);
		InsertOp(k, none, none, 0D9H, 0F2H, none, none);

		InsertMnemo("FRNDINT", k);
		InsertOp(k, none, none, 0D9H, 0FCH, none, none);

		InsertMnemo("FRSTOR", k);
		InsertOp(k, M, none, 0DDH, none, 4, none);

		InsertMnemo("FSAVE", k);
		InsertOp(k, M, none, 09BH, 0DDH, 6, none);

		InsertMnemo("FNSAVE", k);
		InsertOp(k, M, none, 0DDH, none, 6, none);

		InsertMnemo("FSCALE", k);
		InsertOp(k, none, none, 0D9H, 0FDH, none, none);

		InsertMnemo("FSIN", k);
		InsertOp(k, none, none, 0D9H, 0FEH, none, none);

		InsertMnemo("FSINCOS", k);
		InsertOp(k, none, none, 0D9H, 0FBH, none, none);

		InsertMnemo("FSQRT", k);
		InsertOp(k, none, none, 0D9H, 0FAH, none, none);

		InsertMnemo("FST", k);
		InsertOp(k, M32, none, 0D9H, none, 2, none);
		InsertOp(k, M64, none, 0DDH, none, 2, none);
		InsertOp(k, FReg, none, 0DDH, 0D0H, none, OmOp);

		InsertMnemo("FSTP", k);
		InsertOp(k, M32, none, 0D9H, none, 3, none);
		InsertOp(k, M64, none, 0DDH, none, 3, none);
		InsertOp(k, M80, none, 0DBH, none, 7, none);
		InsertOp(k, FReg, none, 0D9H, 0D8H, none, OmOp);

		InsertMnemo("FSTCW", k);
		InsertOp(k, M, none, 09BH, 0D9H, 7, none);

		InsertMnemo("FNSTCW", k);
		InsertOp(k, M, none, 0D9H, none, 7, none);

		InsertMnemo("FSTENV", k);
		InsertOp(k, M, none, 09BH, 0D9H, 6, none);

		InsertMnemo("FNSTENV", k);
		InsertOp(k, M, none, 0D9H, none, 6, none);

		InsertMnemo("FSTSW", k);
		InsertOp(k, M, none, 09BH, 0DDH, 7, none);

		InsertMnemo("FNSTSW", k);
		InsertOp(k, M, none, 0DDH, none, 7, none);
		InsertOp(k, RegAX, none, 0DFH, 0E0H, 7, none);

		InsertMnemo("FSUB", k);
		InsertOp(k, M32, none, 0D8H, none, 4, none);
		InsertOp(k, M64, none, 0DCH, none, 4, none);
		InsertOp(k, FRegST, FReg, 0D8H, 0E0H, none, OmOp);
		InsertOp(k, FReg, FRegST, 0DCH, 0E8H, none, OmOp);

		InsertMnemo("FSUBP", k);
		InsertOp(k, FReg, FRegST, 0DEH, 0E8H, none, OmOp);
		InsertOp(k, none, none, 0DEH, 0E9H, none, none);

		InsertMnemo("FISUB", k);
		InsertOp(k, M32, none, 0DAH, none, 4, none);
		InsertOp(k, M16, none, 0DEH, none, 4, none);

		InsertMnemo("FSUBR", k);
		InsertOp(k, M32, none, 0D8H, none, 5, none);
		InsertOp(k, M64, none, 0DCH, none, 5, none);
		InsertOp(k, FRegST, FReg, 0D8H, 0E8H, none, OmOp);
		InsertOp(k, FReg, FRegST, 0DCH, 0E0H, none, OmOp);

		InsertMnemo("FSUBRP", k);
		InsertOp(k, FReg, FRegST, 0DEH, 0E0H, none, OmOp);
		InsertOp(k, none, none, 0DEH, 0E1H, none, none);

		InsertMnemo("FISUBR", k);
		InsertOp(k, M32, none, 0DAH, none, 5, none);
		InsertOp(k, M16, none, 0DEH, none, 5, none);

		InsertMnemo("FTST", k);
		InsertOp(k, none, none, 0D9H, 0E4H, none, none);

		InsertMnemo("FUCOM", k);
		InsertOp(k, FReg, none, 0DDH, 0E0H, none, OmOp);
		InsertOp(k, none, none, 0DDH, 0E1H, none, none);

		InsertMnemo("FUCOMP", k);
		InsertOp(k, FReg, none, 0DDH, 0E8H, none, OmOp);
		InsertOp(k, none, none, 0DDH, 0E9H, none, none);

		InsertMnemo("FUCOMPP", k);
		InsertOp(k, none, none, 0DAH, 0E9H, none, none);

		InsertMnemo("FWAIT", k);
		InsertOp(k, none, none, 09BH, none, none, none);

		InsertMnemo("FXAM", k);
		InsertOp(k, none, none, 0D9H, 0E5H, none, none);

		InsertMnemo("FXCH", k);
		InsertOp(k, FReg, none, 0D9H, 0C8H, none, OmOp);
		InsertOp(k, none, none, 0D9H, 0C9H, none, none);

		InsertMnemo("FXTRACT", k);
		InsertOp(k, none, none, 0D9H, 0F4H, none, none);

		InsertMnemo("FYL2X", k);
		InsertOp(k, none, none, 0D9H, 0F1H, none, none);

		InsertMnemo("FYL2XP1", k);
		InsertOp(k, none, none, 0D9H, 0F9H, none, none);
	END InsertFloatInstr;
	
	
	PROCEDURE InsertInstr1;
		VAR i,k: INTEGER;
	BEGIN
		InsertMnemo("AAA", k);
		InsertOp(k, none, none, 37H, none, none, none);
		
		InsertMnemo("AAD", k);
		InsertOp(k, none, none, 0D5H, 0AH, none, none);
		
		InsertMnemo("AAM", k);
		InsertOp(k, none, none, 0D4H, 0AH, none, none);
		
		InsertMnemo("AAS", k);
		InsertOp(k, none, none, 3FH, none, none, none);
		
		FOR i:=0 TO 7 DO				(* similar integer ops *)
			CASE i OF
			  0: InsertMnemo("ADD", k)
			|1: InsertMnemo("OR", k)
			|2: InsertMnemo("ADC", k)
			|3: InsertMnemo("SBB", k)
			|4: InsertMnemo("AND", k)
			|5: InsertMnemo("SUB", k)
			|6: InsertMnemo("XOR", k)
			|7: InsertMnemo("CMP", k)
			END;
			InsertOp(k, RegAL, Imm8, 04H + i*08H, none, none, none);
			InsertOp(k, RegAX, Imm16, 05H + i*08H, none, none, none);
			InsertOp(k, RegEAX, Imm32, 05H + i*08H, none, none, none);
			InsertOp(k, RM8, Imm8, 80H, none, i, none);
			InsertOp(k, RM16, Imm16, 81H, none, i, none);
			InsertOp(k, RM32, Imm32, 81H, none, i, none);
			InsertOp(k, RM16, SImm8, 83H, none, i, none);
			InsertOp(k, RM32, SImm8, 83H, none, i, none);
			InsertOp(k, RM8, Reg8, i * 08H, none, none, OmRM);
			InsertOp(k, RM16, Reg16, 01H + i * 08H, none, none, OmRM);
			InsertOp(k, RM32, Reg32, 01H + i * 08H, none, none, OmRM);
			InsertOp(k, Reg8, RM8, 02H + i * 08H, none, none, OmRM);
			InsertOp(k, Reg16, RM16, 03H + i * 08H, none, none, OmRM);
			InsertOp(k, Reg32, RM32, 03H + i * 08H, none, none, OmRM);
		END;
		
		InsertMnemo("ARPL", k);
		InsertOp(k, RM16, Reg16, 63H, none, none, OmRM);
		
		InsertMnemo("BOUND", k);
		InsertOp(k, Reg16, M16, 62H, none, none, OmRM);
		InsertOp(k, Reg32, M32, 62H, none, none, OmRM);
		
		InsertMnemo("BSF", k);
		InsertOp(k, Reg16, RM16, 0FH, 0BCH, none, none);
		InsertOp(k, Reg32, RM32, 0FH, 0BCH, none, none);

		InsertMnemo("BSR", k);
		InsertOp(k, Reg16, RM16, 0FH, 0BDH, none, none);
		InsertOp(k, Reg32, RM32, 0FH, 0BDH, none, none);

		InsertMnemo("BSWAP", k);
		InsertOp(k, Reg32, none, 0FH, 0C8H, none, OmOp);
		
		FOR i := 0 TO 3 DO
			CASE i OF
				  0: InsertMnemo("BT", k)
				| 1: InsertMnemo("BTS", k)
				| 2: InsertMnemo("BTR", k)
				| 3: InsertMnemo("BTC", k)
			END;
			InsertOp(k, RM16, Reg16, 0FH, 0A3H + i*8, none, OmRM);
			InsertOp(k, RM32, Reg32, 0FH, 0A3H + i*8, none, OmRM);
			InsertOp(k, RM16, Imm8, 0FH, 0BAH, i+4, none);
			InsertOp(k, RM32, Imm8, 0FH, 0BAH, i+4, none)
		END;

		InsertMnemo("CALL", k);
		InsertOp(k, RM16, none, 0FFH, none, 2, none);
		InsertOp(k, Rel32, none, 0E8H, none, none, none);
		InsertOp(k, RM32, none, 0FFH, none, 2, none);
		
		InsertMnemo("CBW", k);
		InsertOp(k, none, none, 066H, 098H, none, none);
		
		InsertMnemo("CWDE", k);
		InsertOp(k, none, none, 098H, none, none, none);
		
		FOR i := 8 TO 0DH DO
			CASE i OF
				  8: InsertMnemo("CLC", k)
				| 9: InsertMnemo("STC", k)
				| 0AH: InsertMnemo("CLI", k)
				| 0BH: InsertMnemo("STI", k)
				| 0CH: InsertMnemo("CLD", k)
				| 0DH: InsertMnemo("STD", k)
			END;
			InsertOp(k, none, none, 0F0H + i, none, none, none)
		END;
		
		InsertMnemo("CLTS", k);
		InsertOp(k, none, none, 0FH, 06H, none, none);
		
		InsertMnemo("CMC", k);
		InsertOp(k, none, none, 0F5H, none, none, none);
		
		InsertMnemo("CMPSB", k);
		InsertOp(k, none, none, 0A6H, none, none, none);
		
		InsertMnemo("CMPSW", k);
		InsertOp(k, none, none, 066H, 0A7H, none, none);
		
		InsertMnemo("CMPSD", k);
		InsertOp(k, none, none, 0A7H, none, none, none);
		
		InsertMnemo("CWD", k);
		InsertOp(k, none, none, 066H, 099H, none, none);
		InsertMnemo("CDQ", k);
		InsertOp(k, none, none, 099H, none, none, none);
		
		InsertMnemo("DAA", k);
		InsertOp(k, none, none, 027H, none, none, none);
		InsertMnemo("DAS", k);
		InsertOp(k, none, none, 02FH, none, none, none);

		InsertMnemo("DEC", k);
		InsertOp(k, RM8, none, 0FEH, none, 1, none);
		InsertOp(k, RM16, none, 0FFH, none, 1, none);
		InsertOp(k, RM32, none, 0FFH, none, 1, none);
		InsertOp(k, Reg16, none, 48H, none, none, OmOp);
		InsertOp(k, Reg32, none, 48H, none, none, OmOp);
		
		InsertMnemo("DIV", k);
		InsertOp(k, RegAL, RM8, 0F6H, none, 6, none);
		InsertOp(k, RegAX, RM16, 0F7H, none, 6, none);
		InsertOp(k, RegEAX, RM32, 0F7H, none, 6, none);
		InsertOp(k, RM8, none, 0F6H, none, 6, none);
		InsertOp(k, RM16, none, 0F7H, none, 6, none);
		InsertOp(k, RM32, none, 0F7H, none, 6, none);
		
		InsertMnemo("HLT", k);
		InsertOp(k, none, none, 0F4H, none, none, none);
		
		InsertMnemo("IDIV", k);
		InsertOp(k, RegAX, RM16, 0F7H, none, 7, none);
		InsertOp(k, RegEAX, RM32, 0F7H, none, 7, none);
		InsertOp(k, RM8, none, 0F6H, none, 7, none);


		InsertMnemo("IMUL", k);
		InsertOp(k, RM8, none, 0F6H, none, 5, none);
		InsertOp(k, RM16, none, 0F7H, none, 5, none);
		InsertOp(k, RM32, none, 0F7H, none, 5, none);
		InsertOp(k, Reg16, RM16, 0FH, 0AFH, none, OmRM);
		InsertOp(k, Reg32, RM32, 0FH, 0AFH, none, OmRM);
		InsertOp(k, Reg16, SImm8, 06BH, none, none, OmRM);
		InsertOp(k, Reg32, SImm8, 06BH, none, none, OmRM);
		InsertOp(k, Reg16, Imm16, 069H, none, none, OmRM);
		InsertOp(k, Reg32, Imm32, 069H, none, none, OmRM);
		InsertOp3(k, Reg16, RM16, SImm8, 06BH, none, none, OmRM);
		InsertOp3(k, Reg32, RM32, SImm8, 06BH, none, none, OmRM);
		InsertOp3(k, Reg16, RM16, Imm16, 069H, none, none, OmRM);
		InsertOp3(k, Reg32, RM32, Imm32, 069H, none, none, OmRM);
	END InsertInstr1;
		
	PROCEDURE InsertInstr2;
		VAR i,k: INTEGER;
	BEGIN
		InsertMnemo("IN", k);
		InsertOp(k, RegAL, Imm8, 0E4H, none, none, none);
		InsertOp(k, RegAX, Imm8, 0E5H, none, none, none);
		InsertOp(k, RegEAX, Imm8, 0E5H, none, none, none);
		InsertOp(k, RegAL, RegDX, 0ECH, none, none, none);
		InsertOp(k, RegAX, RegDX, 0EDH, none, none, none);
		InsertOp(k, RegEAX, RegDX, 0EDH, none, none, none);

		InsertMnemo("INC", k);
		InsertOp(k, RM8, none, 0FEH, none, 0, none);
		InsertOp(k, RM16, none, 0FFH, none, 0, none);
		InsertOp(k, RM32, none, 0FFH, none, 0, none);
		InsertOp(k, Reg16, none, 040H, none, none, OmOp);
		InsertOp(k, Reg32, none, 040H, none, none, OmOp);

		InsertMnemo("INSB", k);
		InsertOp(k, none, none, 06CH, none, none, none);

		InsertMnemo("INSW", k);
		InsertOp(k, none, none, 066H, 06DH, none, none);
		
		InsertMnemo("INSD", k);
		InsertOp(k, none, none, 06DH, none, none, none);
		
		InsertMnemo("INT", k);
		InsertOp(k, Const3, none, 0CCH, none, none, none);
		InsertOp(k, Imm8, none, 0CDH, none, none, none);
		
		InsertMnemo("INTO", k);
		InsertOp(k, none, none, 0CEH, none, none, none);
		
		InsertMnemo("IRETD", k);
		InsertOp(k, none, none, 0CFH, none, none, none);
		

		FOR i := 0 TO 15 DO
			CASE i OF
			0: InsertMnemo("JO", k)
			| 1: InsertMnemo("JNO", k)
			| 2: InsertMnemo("JB", k)
			| 3: InsertMnemo("JNB", k)
			| 4: InsertMnemo("JZ", k)
			| 5: InsertMnemo("JNZ", k)
			| 6: InsertMnemo("JBE", k)
			| 7: InsertMnemo("JNBE", k)
			| 8: InsertMnemo("JS", k)
			| 9: InsertMnemo("JNS", k)
			| 10: InsertMnemo("JP", k)
			| 11: InsertMnemo("JNP", k)
			| 12: InsertMnemo("JL", k)
			| 13: InsertMnemo("JNL", k)
			| 14: InsertMnemo("JLE", k)
			| 15: InsertMnemo("JNLE", k)
			END;
			InsertOp(k, Rel8, none, 70H + i, none, none, none);
			InsertOp(k, Rel16, none, 0FH, 80H + i, none, none);
			InsertOp(k, Rel32, none, 0FH, 80H + i, none, none);
		END;
		InsertAlias("JB", "JC"); InsertAlias("JB", "JNAE");
		InsertAlias("JNB", "JNC"); InsertAlias("JNB", "JAE");
		InsertAlias("JZ", "JE");
		InsertAlias("JNZ", "JNE");
		InsertAlias("JBE", "JNA");
		InsertAlias("JNBE", "JA");
		InsertAlias("JP", "JPE");
		InsertAlias("JNP", "JPO");
		InsertAlias("JL", "JNGE");
		InsertAlias("JNL", "JGE");
		InsertAlias("JLE", "JNG");
		InsertAlias("JNLE", "JG");
		
		InsertMnemo("JMP", k);
		InsertOp(k, Rel8, none, 0EBH, none, none, none);
		InsertOp(k, RM16, none, 0FFH, none, 4, none);
		InsertOp(k, Rel32, none, 0E9H, none, none, none);
		InsertOp(k, RM32, none, 0FFH, none, 4, none);
		
		InsertMnemo("LAHF", k);
		InsertOp(k, none, none, 09FH, none, none, none);
		
		InsertMnemo("LAR", k);
		InsertOp(k, Reg16, RM16, 0FH, 02H, none, OmRM);
		InsertOp(k, Reg32, RM32, 0FH, 02H, none, OmRM);

		InsertMnemo("LEA", k);
		InsertOp(k, Reg16, M16, 08DH, none, none, OmRM);
		InsertOp(k, Reg16, M32, 08DH, none, none, OmRM);
		(*InsertOp(k, Reg32, M16, 08DH, none, none, OmRM);*)
		InsertOp(k, Reg32, M32, 08DH, none, none, OmRM);

		InsertMnemo("LEAVE", k);
		InsertOp(k, none, none, 0C9H, none, none, none);

		InsertMnemo("LDS", k);
		InsertOp(k, Reg16, M16, 0C5H, none, none, OmRM);
		InsertOp(k, Reg32, M32, 0C5H, none, none, OmRM);
		InsertMnemo("LSS", k);
		InsertOp(k, Reg16, M16, 0FH, 0B2H, none, OmRM);
		InsertOp(k, Reg32, M32, 0FH, 0B2H, none, OmRM);
		InsertMnemo("LES", k);
		InsertOp(k, Reg16, M16, 0C4H, none, none, OmRM);
		InsertOp(k, Reg32, M32, 0C4H, none, none, OmRM);
		InsertMnemo("LFS", k);
		InsertOp(k, Reg16, M16, 0FH, 0B4H, none, OmRM);
		InsertOp(k, Reg32, M32, 0FH, 0B4H, none, OmRM);
		InsertMnemo("LGS", k);
		InsertOp(k, Reg16, M16, 0FH, 0B5H, none, OmRM);
		InsertOp(k, Reg32, M32, 0FH, 0B5H, none, OmRM);
		
		InsertMnemo("LGDT", k);
		InsertOp(k, M, none, 0FH, 01H, 2, none);
		
		InsertMnemo("LIDT", k);
		InsertOp(k, M, none, 0FH, 01H, 3, none);

		InsertMnemo("LOCK", k);
		InsertOp(k, none, none, 0F0H, none, none, none);

		InsertMnemo("LLDT", k);
		InsertOp(k, RM16, none, 0FH, 00H, 2, none);
		
		InsertMnemo("LMSW", k);
		InsertOp(k, RM16, none, 0FH, 01H, 6, none);

		InsertMnemo("LODSB", k);
		InsertOp(k, none, none, 0ACH, none, none, none);

		InsertMnemo("LODSW", k);
		InsertOp(k, none, none, 066H, 0ADH, none, none);

		InsertMnemo("LODSD", k);
		InsertOp(k, none, none, 0ADH, none, none, none);

		InsertMnemo("LOOP", k);
		InsertOp(k, Rel8, none, 0E2H, none, none, none);
		
		InsertMnemo("LOOPE", k);
		InsertOp(k, Rel8, none, 0E1H, none, none, none);
		InsertAlias("LOOPE", "LOOPZ");
		
		InsertMnemo("LOOPNE", k);
		InsertOp(k, Rel8, none, 0E0H, none, none, none);
		InsertAlias("LOOPNE", "LOOPNZ");

		InsertMnemo("LSL", k);
		InsertOp(k, Reg16, RM16, 0FH, 03H, none, OmRM);
		InsertOp(k, Reg32, RM32, 0FH, 03H, none, OmRM);

		InsertMnemo("LTR", k);
		InsertOp(k, RM16, none, 0FH, 00H, 3, none);
	END InsertInstr2;
	
	PROCEDURE InsertInstr3;
		VAR i,k: INTEGER;
	BEGIN
		InsertMnemo("MOV", k);
		InsertOp(k, RM8, Reg8, 88H, none, none, OmRM);
		InsertOp(k, RM16, Reg16, 89H, none, none, OmRM);
		InsertOp(k, RM32, Reg32, 89H, none, none, OmRM);
		InsertOp(k, Reg8, RM8,  8AH, none, none, OmRM);
		InsertOp(k, Reg16, RM16, 8BH, none, none, OmRM);
		InsertOp(k, Reg32, RM32, 8BH, none, none, OmRM);
		InsertOp(k, RM16, SReg, 8CH, none, none, OmRM);
		InsertOp(k, SReg, RM16, 8EH, none, none, OmRM);
		InsertOp(k, Reg8, Imm8,  0B0H, none, none, OmOp);
		InsertOp(k, Reg16, Imm16,  0B8H, none, none, OmOp);
		InsertOp(k, Reg32, Imm32,  0B8H, none, none, OmOp);
		InsertOp(k, RM8, Imm8,  0C6H, none, none, none);
		InsertOp(k, RM16, Imm16,  0C7H, none, none, none);
		InsertOp(k, RM32, Imm32,  0C7H, none, none, none);
		InsertOp(k, Reg32, CRReg, 0FH, 20H, none, OmRM);
		InsertOp(k, CRReg, Reg32, 0FH, 22H, none, OmRM);
		InsertOp(k, Reg32, DRReg, 0FH, 21H, none, OmRM);
		InsertOp(k, DRReg, Reg32, 0FH, 23H, none, OmRM);
		InsertOp(k, Reg32, TRReg, 0FH, 24H, none, OmRM);
		InsertOp(k, TRReg, Reg32, 0FH, 26H, none, OmRM);

		InsertMnemo("MOVSB", k);
		InsertOp(k, none, none, 0A4H, none, none, none);
		
		InsertMnemo("MOVSW", k);
		InsertOp(k, none, none, 066H, 0A5H, none, none);
		
		InsertMnemo("MOVSD", k);
		InsertOp(k, none, none, 0A5H, none, none, none);
		
		InsertMnemo("MOVSX", k);
		InsertOp(k, Reg16, RM8, 0FH, 0BEH, none, OmRM);
		InsertOp(k, Reg32, RM8, 0FH, 0BEH, none, OmRM);
		InsertOp(k, Reg32, RM16, 0FH, 0BFH, none, OmRM);
		
		InsertMnemo("MOVZX", k);
		InsertOp(k, Reg16, RM8, 0FH, 0B6H, none, OmRM);
		InsertOp(k, Reg32, RM8, 0FH, 0B6H, none, OmRM);
		InsertOp(k, Reg32, RM16, 0FH, 0B7H, none, OmRM);

		InsertMnemo("MUL", k);
		InsertOp(k, RegAL, RM8, 0F6H, none, 4, none);
		InsertOp(k, RegAX, RM16, 0F7H, none, 4, none);
		InsertOp(k, RegEAX, RM32, 0F7H, none, 4, none);
		InsertOp(k, RM8, none, 0F6H, none, 4, none);
		InsertOp(k, RM16, none, 0F7H, none, 4, none);
		InsertOp(k, RM32, none, 0F7H, none, 4, none);
		
		InsertMnemo("NEG", k);
		InsertOp(k, RM8, none, 0F6H, none, 3, none);
		InsertOp(k, RM16, none, 0F7H, none, 3, none);
		InsertOp(k, RM32, none, 0F7H, none, 3, none);

		InsertMnemo("NOP", k);
		InsertOp(k, none, none, 090H, none, none, none);
		
		InsertMnemo("NOT", k);
		InsertOp(k, RM8, none, 0F6H, none, 2, none);
		InsertOp(k, RM16, none, 0F7H, none, 2, none);
		InsertOp(k, RM32, none, 0F7H, none, 2, none);

		InsertMnemo("OUT", k);
		InsertOp(k, Imm8, RegAL, 0E6H, none, none, none);
		InsertOp(k, Imm8, RegAX, 0E7H, none, none, none);
		InsertOp(k, Imm8, RegEAX, 0E7H, none, none, none);
		InsertOp(k, RegDX, RegAL, 0EEH, none, none, none);
		InsertOp(k, RegDX, RegAX, 0EFH, none, none, none);
		InsertOp(k, RegDX, RegEAX, 0EFH, none, none, none);

		InsertMnemo("OUTSB", k);
		InsertOp(k, none, none, 06EH, none, none, none);
		InsertMnemo("OUTSW", k);
		InsertOp(k, none, none, 066H, 06FH, none, none);
		InsertMnemo("OUTSD", k);
		InsertOp(k, none, none, 06FH, none, none, none);

		InsertMnemo("POP", k);
(*		InsertOp(k, M16, none, 08FH, none, 0, none);*)
		InsertOp(k, M32, none, 08FH, none, 0, none);
(*		InsertOp(k, Reg16, none, 058H, none, none, OmOp);*)
		InsertOp(k, Reg32, none, 058H, none, none, OmOp);
		InsertOp(k, RegDS, none, 01FH, none, none, none);
		InsertOp(k, RegES, none, 07H, none, none, none);
		InsertOp(k, RegSS, none, 017H, none, none, none);
		InsertOp(k, RegFS, none, 0FH, 0A1H, none, none);
		InsertOp(k, RegGS, none, 0FH, 0A9H, none, none);
		
		InsertMnemo("POPAD", k);
		InsertOp(k, none, none, 061H, none, none, none);

		InsertMnemo("POPFD", k);
		InsertOp(k, none, none, 09DH, none, none, none);

		InsertMnemo("PUSH", k);
(*		InsertOp(k, Reg16, none, 050H, none, none, OmOp);*)
		InsertOp(k, Reg32, none, 050H, none, none, OmOp);
		InsertOp(k, SImm8, none, 06AH, none, none, none);
(*		InsertOp(k, Imm16, none, 068H, none, none, none);*)
		InsertOp(k, Imm32, none, 068H, none, none, none);
(*		InsertOp(k, M16, none, 0FFH, none, 6, none);*)
		InsertOp(k, M32, none, 0FFH, none, 6, none);
		InsertOp(k, RegCS, none, 0EH, none, none, none);
		InsertOp(k, RegDS, none, 01EH, none, none, none);
		InsertOp(k, RegES, none, 06H, none, none, none);
		InsertOp(k, RegSS, none, 016H, none, none, none);
		InsertOp(k, RegFS, none, 0FH, 0A0H, none, none);
		InsertOp(k, RegGS, none, 0FH, 0A8H, none, none);
	END InsertInstr3;
		
	PROCEDURE InsertInstr4;
		VAR i,k: INTEGER;
	BEGIN
		InsertMnemo("PUSHAD", k);
		InsertOp(k, none, none, 060H, none, none, none);

		InsertMnemo("PUSHFD", k);
		InsertOp(k, none, none, 09CH, none, none, none);

		FOR i := 0 TO 7 DO
			CASE i OF
				  0: InsertMnemo("ROL", k)
				| 1: InsertMnemo("ROR", k)
				| 2: InsertMnemo("RCL", k)
				| 3: InsertMnemo("RCR", k)
				| 4: InsertMnemo("SHL", k)
				| 5: InsertMnemo("SHR", k)
				| 6:  (*SAL*)
				| 7: InsertMnemo("SAR", k)
			END;
			IF i = 6 THEN ELSE
				InsertOp(k, RM8, Const1, 0D0H, none, i, none);
				InsertOp(k, RM8, RegCL, 0D2H, none, i, none);
				InsertOp(k, RM8, Imm8, 0C0H, none, i, none);
				InsertOp(k, RM16, Const1, 0D1H, none, i, none);
				InsertOp(k, RM16, RegCL, 0D3H, none, i, none);
				InsertOp(k, RM16, Imm8, 0C1H, none, i, none);
				InsertOp(k, RM32, Const1, 0D1H, none, i, none);
				InsertOp(k, RM32, RegCL, 0D3H, none, i, none);
				InsertOp(k, RM32, Imm8, 0C1H, none, i, none)
			END
		END;
		InsertAlias("SHL", "SAL");
		
		InsertMnemo("REP", k);
		InsertOp(k, none, none, 0F3H, none, none, none);
		InsertAlias("REP", "REPE"); InsertAlias("REP", "REPZ");
		InsertMnemo("REPNE", k);
		InsertOp(k, none, none, 0F2H, none, none, none);
		InsertAlias("REPNE", "REPNZ");

		InsertMnemo("RET", k);
		InsertOp(k, none, none, 0C3H, none, none, none);
		InsertOp(k, Imm16, none, 0C2H, none, none, none);

		InsertMnemo("SAHF", k);
		InsertOp(k, none, none, 09EH, none, none, none);

		InsertMnemo("SCASB", k);
		InsertOp(k, none, none, 0AEH, none, none, none);
		InsertMnemo("SCASW", k);
		InsertOp(k, none, none, 66H, 0AFH, none, none);
		InsertMnemo("SCASD", k);
		InsertOp(k, none, none, 0AFH, none, none, none);

		FOR i:=0 TO 0FH DO
			CASE i OF
				   0: InsertMnemo("SETO", k)
				| 1: InsertMnemo("SETNO", k)
				| 2: InsertMnemo("SETB", k)
				| 3: InsertMnemo("SETNB", k)
				| 4: InsertMnemo("SETZ", k)
				| 5: InsertMnemo("SETNZ", k)
				| 6: InsertMnemo("SETBE", k)
				| 7: InsertMnemo("SETNBE", k)
				| 8: InsertMnemo("SETS", k)
				| 9: InsertMnemo("SETNS", k)
				| 0AH: InsertMnemo("SETP", k)
				| 0BH: InsertMnemo("SETNP", k)
				| 0CH: InsertMnemo("SETL", k)
				| 0DH: InsertMnemo("SETNL", k)
				| 0EH: InsertMnemo("SETLE", k)
				| 0FH: InsertMnemo("SETNLE", k)
			END;
			InsertOp(k, RM8, none, 0FH, 90H + i, none, none);
		END;
		InsertAlias("SETB", "SETC");
		InsertAlias("SETNB", "SETAE");
		InsertAlias("SETZ", "SETE");
		InsertAlias("SETNBE", "SETA");
		InsertAlias("SETNL", "SETGE");
		InsertAlias("SETNLE", "SETG");
		InsertAlias("SETBE", "SETNA");
		InsertAlias("SETB", "SETNAE");
		InsertAlias("SETNB", "SETNC");
		InsertAlias("SETNZ", "SETNE");
		InsertAlias("SETLE", "SETNG");
		InsertAlias("SETL", "SETNGE");
		InsertAlias("SETP", "SETPE");
		InsertAlias("SETNP", "SETPO");

		InsertMnemo("SGDT", k);
		InsertOp(k, M, none, 0FH, 01H, 0, none);
		InsertMnemo("SIDT", k);
		InsertOp(k, M, none, 0FH, 01H, 1, none);

		InsertMnemo("SHLD", k);
		InsertOp3(k, RM16, Reg16, Imm8, 0FH, 0A4H, none, OmRM);
		InsertOp3(k, RM32, Reg32, Imm8, 0FH, 0A4H, none, OmRM);
		InsertOp3(k, RM16, Reg16, RegCL, 0FH, 0A5H, none, OmRM);
		InsertOp3(k, RM32, Reg32, RegCL, 0FH, 0A5H, none, OmRM);

		InsertMnemo("SHRD", k);
		InsertOp3(k, RM16, Reg16, Imm8, 0FH, 0ACH, none, OmRM);
		InsertOp3(k, RM32, Reg32, Imm8, 0FH, 0ACH, none, OmRM);
		InsertOp3(k, RM16, Reg16, RegCL, 0FH, 0ADH, none, OmRM);
		InsertOp3(k, RM32, Reg32, RegCL, 0FH, 0ADH, none, OmRM);

		InsertMnemo("SMSW", k);
		InsertOp(k, RM16, none, 0FH, 01H, 4, none);

		InsertMnemo("SLDT", k);
		InsertOp(k, RM16, none, 0FH, 00H, 0, none);

		InsertMnemo("STOSB", k);
		InsertOp(k, none, none, 0AAH, none, none, none);

		InsertMnemo("STOSW", k);
		InsertOp(k, none, none, 066H, 0ABH, none, none);

		InsertMnemo("STOSD", k);
		InsertOp(k, none, none,  0ABH, none, none, none);

		InsertMnemo("STR", k);
		InsertOp(k, RM16, none,  0FH, 00H, 1, none);

		InsertMnemo("TEST", k);
		InsertOp(k, RegAL, Imm8,  0A8H, none, none, none);
		InsertOp(k, RegAX, Imm16,  0A9H, none, none, none);
		InsertOp(k, RegEAX, Imm32,  0A9H, none, none, none);
		InsertOp(k, RM8, Imm8,  0F6H, none, 0, none);
		InsertOp(k, RM16, Imm16,  0F7H, none, 0, none);
		InsertOp(k, RM32, Imm32,  0F7H, none, 0, none);
		InsertOp(k, RM8, Reg8,  084H, none, none, OmRM);
		InsertOp(k, RM16, Reg16,  085H, none, none, OmRM);
		InsertOp(k, RM32, Reg32,  085H, none, none, OmRM);

		InsertMnemo("VERR", k);
		InsertOp(k, RM16, none,  0FH, 00H, 4, none);

		InsertMnemo("VERW", k);
		InsertOp(k, RM16, none,  0FH, 00H, 5, none);

		InsertMnemo("WAIT", k);
		InsertOp(k, none, none,  09BH, none, none, none);

		InsertMnemo("XLATB", k);
		InsertOp(k, none, none,  0D7H, none, none, none);

		InsertMnemo("XCHG", k);
		InsertOp(k, RegAX, Reg16, 090H, none, none, OmOp);
		InsertOp(k, Reg16, RegAX, 090H, none, none, OmOp);
		InsertOp(k, RegEAX, Reg32, 090H, none, none, OmOp);
		InsertOp(k, Reg32, RegEAX, 090H, none, none, OmOp);
		InsertOp(k, RM8, Reg8, 086H, none, none, OmRM);
		InsertOp(k, Reg8, RM8, 086H, none, none, OmRM);
		InsertOp(k, RM16, Reg16, 087H, none, none, OmRM);
		InsertOp(k, Reg16, RM16, 087H, none, none, OmRM);
		InsertOp(k, RM32, Reg32, 087H, none, none, OmRM);
		InsertOp(k, Reg32, RM32, 087H, none, none, OmRM);
	END InsertInstr4;
	
	PROCEDURE BodyInit;
		VAR k: INTEGER;
	BEGIN
		OPM.LogWLn; OPM.LogWStr("  using OP2-ASM add-on / prk");
		NEW(root); root.left := NIL; root.right := NIL; root.next := NIL;
		FOR k:= 0 TO OpTabLen-1 DO OpTab[k].op0 := -1 END;
		FOR k:= 0 TO InstrTabLen-1 DO InstrTab[k].name[0] := 0X END;
		OpTabN := 0; Average := 0;
		InsertInstr1;	InsertInstr2;	InsertInstr3;	InsertInstr4;	InsertFloatInstr;
		SizeTab[0] := 0; SizeTab[1] := 1; SizeTab[2] := 1; SizeTab[3] := 1;
		SizeTab[4] := 1; SizeTab[5] := 2; SizeTab[6] := 4; SizeTab[7] := 4;
		SizeTab[8] := 8; SizeTab[9] := 4; SizeTab[10] := 4; SizeTab[11] := 4;
		SizeTab[12] := 0; SizeTab[13] := 4; SizeTab[14] := 4; SizeTab[15] := 0;

	END BodyInit;
(* ------------------------------------------------------------------- *)
(* Entry points and exported functions *)

	PROCEDURE Assemble*(VAR x: OPT.Node);
	BEGIN
		IF FirstTime THEN BodyInit; FirstTime := FALSE END;
		Init; 
		first := NIL; last := NIL; NewNode;
		fixlist := NIL;
		Get(sym);
		WHILE (sym # ScEnd) & (sym # ScUndef) DO
				IF sym = ScLabel THEN ParseLabel END;
				IF sym = ScIdent THEN ParseInstruction END;
				WHILE (sym # ScEnd) & (sym # ScCR) DO
					Get(sym); OPM.err(510)
				END;
				Get(sym)
		END;

		IF OPM.noerr THEN CheckLabels END;	(* check for undefined forward jumps *)
		Close;
		OPB.Construct(Nassembler, first, fixlist); x := first; x.conval := NIL;
	END Assemble;

	PROCEDURE DumpInstructions;
		VAR i,j,k: INTEGER;
	BEGIN
		IF FirstTime THEN BodyInit; FirstTime := FALSE END;
		FOR i:= 0 TO InstrTabLen-1 DO
			IF InstrTab[i].name # "" THEN
				FOR j := InstrTab[i].start TO InstrTab[i].end-1 DO
					OPM.LogWStr(InstrTab[i].name);
					k := 0;
					WHILE (k < 3) & (OpTab[j].op[k] # none) DO
						IF k = 0 THEN OPM.LogWStr("   ") ELSE OPM.LogWStr(" , ") END;
						DumpMode(OpTab[j].op[k]);
						INC(k)
					END;
					OPM.LogWLn
				END
			END
		END
	END DumpInstructions;
	
BEGIN
	FirstTime := TRUE;	(* the module initialisation is delayed to the first call *)

END ASM.


ASM.DumpInstructions
