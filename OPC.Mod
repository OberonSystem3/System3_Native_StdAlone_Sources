(* OBERON System 3, Release 2.2.

Copyright 1997 Team of the Institute of Computer Systems of ETH Zuerich,
ETH Center, CH-8092 Zuerich, e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be requested from the 
above-mentioned address, or downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)


MODULE OPC;

(* code generator (back end) *)
(* NM, rml, prk 16.05.97 *)


	IMPORT OPT, OPL, OPO, OPM, SYSTEM;


	CONST
		(* structure forms *)
		Undef = 0; Byte = 1; Bool = 2; Char = 3; SInt = 4; Int = 5; LInt = 6;
		Real = 7; LReal = 8; Set = 9; String = 10; NilTyp = 11; NoTyp = 12;
		Pointer = 13; ProcTyp = 14; Comp = 15;
		intSet = {SInt..LInt}; realSet = {Real, LReal};


		(* composite structure forms *)
		Basic = 1; Array = 2; SDynArr = 3; DynArr = 4; Record = 5;
		
		(* Arrays extlev *)
		static = 0; dynamic = 1; sdynamic = 2;

	
		(* nodes classes *)
		Nvar = 0; Nvarpar = 1; Nconst = 7; Nproc = 9;  Nret = 32; 
		
		(* item base modes (=object modes) *)
		Var = 1; VarPar = 2; Con = 3; Fld = 4; Typ = 5; LProc = 6; XProc = 7; CProc = 9; IProc = 10; TProc = 13;
		
		(* item modes for Intel i386 (must not overlap item basemodes,  > 13) *)
		Reg = OPO.Reg; Abs = OPO.Abs; RegRel = OPO.RegRel; Coc = OPO.Coc;

		(*SYSTEM ops*)
		adr = 24; cc = 25; bit = 26; lsh = 27; rot = 28; val = 29;

		(*SYSTEM function number*)
		getfn = 24; putfn = 25; getrfn = 26; putrfn = 27; sysnewfn = 30; movefn = 31;

		(* procedure flags (conval^.setval) *)
		hasBody = 1; isRedef = 2; slNeeded = 3; locked =6;

		(* record flags (flags) *)	
		passiveObj = 4; activeObj = 5; safe = 8;	timed = 9;

		ActiveTag = 80000003H;
		NotActiveTag = 7FFFFFFCH;

		(* module visibility of objects *)
		internal = 0; external = 1; externalR = 2;

		(* base type and method offset *)
		BaseTypeOffs = -8; MethodOffs = -72;

		(* POINTER TO ARRAY offset *)
		PtrToArrOffs* = 8; (* len descriptor start *)

		(* static link address *)
		StaticLinkAdr = 8;

		(* relations *)
		eql = 9; neq = 10; lss = 11; leq = 12; gtr = 13; geq = 14;
		
		false = 0; true = 1; nil = 0;

		(* conditions: the same as opcodes je, jne,....  *)
		EQ = OPL.je; NE = OPL.jne; LT = OPL.jl; LE = OPL.jle; GT = OPL.jg; GE = OPL.jge; 
		AB = OPL.ja; AE = OPL.jae; BL = OPL.jb; BE = OPL.jbe;
		CS = OPL.jc; CC = OPL.jnc; always = OPL.jmp; never = -1;

	(* opcode of pseudo RISC processor *)
	(* integer operations *)
	ld = OPL.ld; 	store = OPL.store; 	lea = OPL.lea; 	push = OPL.push; 
	pop = OPL.pop; 	ldProc = OPL.ldProc;	ldXProc = OPL.ldXProc;	ldbdw = OPL.ldbdw; 
	ldwdw = OPL.ldwdw; 	ldbw = OPL.ldbw; (* sign extended load; b: byte; w: word; dw: dword *)
	ldbdwu = OPL.ldbdwu;	ldwdwu = OPL.ldwdwu;	ldbwu = OPL.ldbwu; (* zero extended load *)
	putReg = OPL.putReg;	getReg = OPL.getReg;
	add = OPL.add; 	sub = OPL.sub; 	mul = OPL.mul; 	div = OPL.div; 
	mod = OPL.mod ; 	neg = OPL.neg; 	abs = OPL.abs;	cmp = OPL.cmp; 
	je = OPL.je; 	jne = OPL.jne; 	jl = OPL.jl; 	jle = OPL.jle; 
	jg = OPL.jg; 	jge = OPL.jge;	ja = OPL.ja; 	jae = OPL.jae; 
	jb = OPL.jb; 	jbe = OPL.jbe;	jc = OPL.jc; 	jnc = OPL.jnc; 
	jmp = OPL.jmp; 	jmpReg = OPL.jmpReg;	sete = OPL.sete; 	setne = OPL.setne; 
	setl = OPL.setl; 	setle = OPL.setle; 	setg = OPL.setg; 	setge = OPL.setge;
	seta = OPL.seta; 	setae = OPL.setae; 	setb = OPL.setb; 	setbe = OPL.setbe;
	setc = OPL.setc; 	setnc = OPL.setnc;	te = OPL.te; 	tne = OPL.tne; 
	tle = OPL.tle;	ta = OPL.ta; 	tae = OPL.tae;	to =  OPL.to;
	trap = OPL.trap;	or = OPL.or; 	xor = OPL.xor; 
	and = OPL.and; 	not = OPL.not;	bt = OPL.bt; 	btr = OPL.btr; 
	bts = OPL.bts;	call = OPL.call; 	callReg = OPL.callReg; 	xcall = OPL.xcall; 
	ret = OPL.ret; 	enter = OPL.enter; 	leave = OPL.leave;	sal = OPL.sal; 
	sar = OPL.sar ; 	shr = OPL.shr; 	rol = OPL.rol;	cld = OPL.cld; 
	repMovs = OPL.repMovs; 	cmpString = OPL.cmpString;
	cli = OPL.cli;	sti = OPL.sti;	in = OPL.in;	out = OPL.out;
	assembler = OPL.assembler;		(* iASM *)

	clear = OPL.clear;
	intpt = OPL.intpt;


	(* floating point operations *)
	fload = OPL.fload; 	fstore = OPL.fstore; 	fist = OPL.fist; 	fild = OPL.fild;
	fadd = OPL.fadd; 	fsub = OPL.fsub; 	fmul = OPL.fmul;	fdiv = OPL.fdiv; 
	fabs = OPL.fabs; 	fchs = OPL.fchs; 	fcmp = OPL.fcmp;

	(* special *)
	phi = OPL.phi; 	pushReg = OPL.pushReg;	popReg = OPL.popReg; 	case = OPL.case;
	entier = OPL.entier;	short = OPL.short;	label = OPL.label;

	newStat = OPL.newStat;

	(* predefined registers of the pseudo RISC machine *)
	ESP = OPL.RiscESP; FP = OPL.RiscFP; none = OPL.none;
	
	(* scale factor *)
	noScale = OPO.noScale;
	
	TYPE 
		Item* = RECORD
			mode*, mnolev*, scale*: SHORTINT;	(* mnolev < 0 -> mno (module number) = -mnolev *)
			typ*: OPT.Struct; node*: OPT.Node;
			adr*, offs*, inx*, descReg*, descOffs*: LONGINT
		END;
(*
	mode:	item mode
	mnolev: 	module number or nesting level
	typ: 	type of item
	node: 	link to node -> used for OPL.AbsAccess and alias analysis
	adr, offs, inx:	see below
	descReg: 	descriptor register (dynamic array)
	descOffs: 	descriptor offset (dynamic array)
*)

(* Items: 

	the fields mnolev and typ are set for all modes in OPV.
	mnolev is not valid for non-allocated constants.

Intel i386 :
   mode  | adr    offs     inx
---------------------------------
 1 Var   | vadr	(adr will be stored in obj.linkadr too. 
         |	Local variables)
 2 VarPar| vadr   	
 3 Con   | val    	(adr: Boolean, Byte..LInt)
         | adr    len(of string)
         | adr   	(LReal, Real)
 6 LProc | adr            
 7 XProc | pno    LinkAdr 	(LinkAdr will be stored in obj.linkadr too)
 9 CProc |     	
10 IProc | adr    LinkAdr	(not implemented yet)
13 TProc | TagAdr Off
         |
15 Reg   | reg          
16 Abs   | vadr            reg	(inx = none: no index register)
17 RegRel| reg    off      reg	(inx = none: no index register)
18 Coc   | CC     Tjmp     Fjmp
*)

		Label* = LONGINT;
		
	CONST
		Nil* = -1;	  (* label nil *)
		BUG = 40;      (* Trap code for Bugs in OP2 *)

	VAR
	level*: SHORTINT; 	(* nesting level *)
	pc*: INTEGER; 	(* pc of pseudo RISC machine *)
	RiscCodeErr*: BOOLEAN; 	(* risc code error -> out of risc code space *)
	inxchk, ovflchk, ranchk, typchk  , initarr  : BOOLEAN;	(* index, overflow, range and type checks *)
	True, False, Stack: Item; 	(* constant items True, False and Stack *)
	ebp: Item; 	(* base pointer item *)
	formTab: ARRAY 16 OF SHORTINT; 
	CCtab: ARRAY 2, (geq-eql+1) OF INTEGER;	(* condition code table, CCtab[0] = integer; CCtab[1] = char *)
	InvCCtab: ARRAY (CC-EQ) DIV 32 + 1 OF INTEGER; (* inverted conditon code table*)


	PROCEDURE^ GenDimTrap* (VAR len: Item);


	PROCEDURE Init* (opt: SET);
		CONST
			inx = 0; ovfl = 1; ran = 2; typ = 3; ptr = 5;  noinitarr = 14; 
	BEGIN
		pc := 0; level := 0;
		inxchk:= inx IN opt; ovflchk:= ovfl IN opt; ranchk:= ran IN opt; typchk:= typ IN opt; OPL.ptrinit := ptr IN opt;

		initarr:=~(noinitarr IN opt)

	END Init;

	PROCEDURE IncReg (pReg: LONGINT);
	(* increments field used in the pseudo code where reg was first used *)
	BEGIN
		IF ~RiscCodeErr & (pReg >= 0) THEN INC (OPL.Instr[pReg].used) END (* pReg < 0: special registers  *)
	END IncReg;
	
	PROCEDURE InitInstr (op: INTEGER; mode, form: SHORTINT; node: OPT.Node);
	(* initialize the pseudo instruction at position pc *)
	BEGIN
		IF pc >= OPL.RiscCodeLen THEN
			IF ~RiscCodeErr THEN
				OPM.err(211);
				RiscCodeErr := TRUE
			END;
			pc := 0
		END;
		ASSERT ((mode >= 0) & (mode <= 3));
		ASSERT ((op MOD 32 = 0) & (op > 0));
		OPL.Instr [pc].op := op + formTab[form] + mode * 8; OPL.Instr [pc].node := SYSTEM.VAL (OPL.WeakNode, node);
		OPL.Instr [pc].src1 := none; OPL.Instr [pc].src2 := none; OPL.Instr [pc].inx := none;
		OPL.Instr [pc].dest := pc; OPL.Instr [pc].used := 0; OPL.Instr [pc].hint := OPL.noHint;
		OPL.Instr [pc].pc := OPL.Nil; OPL.Instr [pc].reg := OPL.Nil; OPL.Instr [pc].abs := FALSE
	END InitInstr;

	PROCEDURE NewStat* (textPos: LONGINT);
	BEGIN
		InitInstr (newStat, 0, 0, NIL);
		OPL.Instr [pc].src1 := textPos;
		OPM.errpos := textPos;
		INC (pc)
	END NewStat;

	PROCEDURE ^ MoveCoc (VAR z, y: Item); (* z := Coc (y) *)
	
	PROCEDURE GenLoad (op: INTEGER; VAR z, x: Item);
	(* loads x into register; used for: ld, ldbdw, ldwdw, ldbw, lea, fload, fild, ldbdwu, ldwdwu, lbdwu *)
	BEGIN
		CASE x.mode OF
			Abs:
				InitInstr (op, OPO.MemReg, x.typ.form, x.node);
				OPL.Instr[pc].src2 := x.adr; OPL.Instr[pc].inx := x.inx; 
				OPL.Instr[pc].scale := x.scale; OPL.Instr[pc].src1 := none;
				IncReg (x.inx)
		  | Var:
				ASSERT (x.mnolev > 0);
				InitInstr (op, OPO.MemReg, x.typ.form, x.node);
				OPL.Instr[pc].src2 := x.adr; OPL.Instr[pc].inx := none;
				OPL.Instr[pc].scale := x.scale;
				OPL.Instr[pc].src1 := FP
		  | Con:
				ASSERT ( (op # lea) & (op # fload) & (op # fild) & (op # pop) );
				ASSERT ( (op < ldbdw) OR (op > ldbwu) ); 
				InitInstr (op, OPO.ImmReg, x.typ.form, x.node);
				OPL.Instr[pc].src2 := x.adr
		  | Reg:
				ASSERT ((op # lea) & (op # fild));
				InitInstr (op, OPO.RegReg, x.typ.form, x.node);
				OPL.Instr[pc].src1 := x.adr;
				IF op # pop THEN IncReg (x.adr) END
		  | RegRel:
				InitInstr (op, OPO.MemReg, x.typ.form, x.node);
				OPL.Instr[pc].src1 := x.adr; OPL.Instr[pc].src2 := x.offs; OPL.Instr[pc].inx := x.inx;
				OPL.Instr[pc].scale := x.scale;
				IncReg (x.adr); IncReg (x.inx)
		  | Coc:
				MoveCoc (z, x); RETURN	(* don't change pc and z.adr *)
		ELSE HALT (BUG)
		END;
		z.adr := pc; z.mode := Reg;
		INC (pc)
	END GenLoad;
					
	PROCEDURE GenPush (VAR x: Item); 
	(* push x *)
		VAR dummy: Item;
	BEGIN
		ASSERT ((x.mode = Reg) OR (x.mode = Con));
		dummy.node := NIL;
		GenLoad (push, dummy, x)
	END GenPush;

	PROCEDURE GenPop (VAR x: Item); 
	(* pop x *)
		VAR dummy: Item;
	BEGIN
		(* x.typ is initialized by the caller *)
		dummy.node := NIL;
		x.mode := Reg; x.adr := pc; x.node := NIL;
		GenLoad (pop, dummy, x);
	END GenPop;

	PROCEDURE GenLoadProc (op: INTEGER; VAR z: Item; val: LONGINT; node: OPT.Node);
	(* ldProc, ldXProc *)
	BEGIN
		InitInstr (op, OPO.ImmReg, LInt, node);
		z.mode := Reg; z.typ := OPT.sysptrtyp; z.adr := pc; 
		OPL.Instr [pc].src1 := val;
		INC (pc)
	END GenLoadProc;
	
	PROCEDURE GenStore (op: INTEGER; VAR z, x: Item); 
	(* z := x; used for: store, fstore, fist *)
	BEGIN
		ASSERT (x.mode = Reg);
		CASE z.mode OF
			Abs:
				InitInstr (op, OPO.RegMem, z.typ.form, z.node); OPL.Instr[pc].dest := x.adr;
				OPL.Instr[pc].src2 := z.adr; OPL.Instr[pc].inx := z.inx; OPL.Instr[pc].scale := z.scale;
				OPL.Instr[pc].src1 := none;
				IncReg (z.inx)
		  | Var:
				ASSERT (z.mnolev > 0);
				InitInstr (op, OPO.RegMem, z.typ.form, z.node); OPL.Instr[pc].dest := x.adr;
				OPL.Instr[pc].src2 := z.adr; OPL.Instr[pc].inx := none;
				OPL.Instr[pc].src1 := FP
		  | RegRel:
				InitInstr (op, OPO.RegMem, z.typ.form, z.node); OPL.Instr[pc].dest := x.adr;
				OPL.Instr[pc].src1 := z.adr; OPL.Instr[pc].src2 := z.offs; OPL.Instr[pc].inx := z.inx;
				OPL.Instr[pc].scale := z.scale;
				IncReg (z.adr); IncReg (z.inx)
		ELSE HALT (BUG)
		END;
		IF op # getReg THEN IncReg (x.adr) END;
		INC (pc)
	END GenStore;

	PROCEDURE GenPopReg (hint, form: SHORTINT); 
	(* popReg *)
	BEGIN
		IF hint = OPL.noHint THEN InitInstr (popReg, 0, 0, NIL)
		ELSE
			InitInstr (popReg, OPO.RegReg, form, NIL);
			OPL.Instr [pc].hint := hint;
		END;
		INC (pc)
	END GenPopReg;

	PROCEDURE Gen0 (op: INTEGER);
	(* used for: cld, pushReg, label *)
	BEGIN
		InitInstr (op, 0, 0, NIL);
		INC (pc)
	END Gen0;

	PROCEDURE Gen1 (op: INTEGER; adr: LONGINT; node: OPT.Node);
	(* used for: je, jne, jl, jle, jg, jge, ja, jae, jb, jbe, jc, jnc, jmp, jmpReg, intpt, trap, te, tne, ta, tae, to, ret, enter, leave *)
	BEGIN
		IF op = jmpReg THEN 
			InitInstr (op, OPO.RegReg, LInt, node); IncReg (adr)
		ELSE InitInstr (op, 0, 0, node)
		END;
		OPL.Instr[pc].src2 := adr;
		INC (pc)
	END Gen1;

	PROCEDURE Gen2 (op: INTEGER; VAR z, x: Item);
	(* z := op (x); used for: neg, not, abs, fabs, fchs, short, entier *)
	BEGIN
		ASSERT (x.mode = Reg);
		InitInstr (op, OPO.RegReg, x.typ.form, x.node);
		OPL.Instr[pc].src1 := x.adr;
		IncReg (x.adr);
		z.adr := pc; z.mode := Reg;
		INC (pc)
	END Gen2;
	
	PROCEDURE Gen3 (op: INTEGER; VAR z, x, y: Item);
	(* z := op (x, y); used for: add, sub, mul, div, mod, or, xor, and, btr, bts, sal,sar, shr, rol, fadd, fsub, fmul, fdiv *)
	BEGIN
		IF y.mode = Con THEN InitInstr (op, OPO.ImmReg, x.typ.form, x.node)
		ELSE 
			InitInstr (op, OPO.RegReg, x.typ.form, x.node); IncReg (y.adr)
		END;
		OPL.Instr[pc].src1 := x.adr; OPL.Instr[pc].src2 := y.adr;
		IncReg (x.adr);
		IF (op = div) OR (op = mod) THEN OPL.Instr[x.adr].hint := OPL.tryEAX
		ELSIF (op >= sal) & (op <= rol) & (y.mode # Con) THEN OPL.Instr[y.adr].hint := OPL.useECX
		ELSIF (op = mul) & (x.typ.form = SInt) THEN OPL.Instr [x.adr].hint := OPL.tryEAX
		END;
		z.adr := pc; z.mode := Reg;
		INC (pc)
	END Gen3;

	PROCEDURE PushRegs*;
	(* pushReg *)
	BEGIN
		Gen0 (pushReg)
	END PushRegs;

	PROCEDURE GenCall (op: INTEGER; adr, parSize: LONGINT; node: OPT.Node);
	(* used for call, xcall, callReg *)
	BEGIN
		IF op = callReg THEN
			InitInstr (op, OPO.RegReg, LInt, node); IncReg (adr)
		ELSE
			InitInstr (op, 0, 0, node)
		END;
		OPL.Instr [pc].src1 := parSize; OPL.Instr[pc].src2 := adr;
		INC (pc)
	END GenCall;
	
	PROCEDURE GenFlags (op: INTEGER; VAR x, y: Item);
	(* x op y; used for: cmp, bt, fcmp, cmpString *)
	BEGIN
		IF y.mode = Con THEN InitInstr (op, OPO.ImmReg, x.typ.form, x.node)
		ELSE
			InitInstr (op, OPO.RegReg, x.typ.form, x.node); IncReg (y.adr)
		END;
		OPL.Instr[pc].src1 := x.adr; OPL.Instr[pc].src2 := y.adr;
		IncReg (x.adr);
		INC (pc)
	END GenFlags;
	
	PROCEDURE GenSetC (op: INTEGER; VAR z: Item); (* set condition *)
	(* used for: sete, setne, setl, setle, setg, setge, seta, setae, setb, setbe, setc, setne *)
	BEGIN
		InitInstr (op, OPO.RegReg, SInt, z.node);
		z.adr := pc; z.mode := Reg;
		INC (pc)
	END GenSetC;

	PROCEDURE GenRepMovs (VAR z, x, nofElem: Item; moveSize: SHORTINT); (* z := x; block copy *)
	(* used for: repMovs *)
	BEGIN
		InitInstr (repMovs, 0, 0, NIL);
		OPL.Instr [pc].dest := z.adr; (* destination address *)
		OPL.Instr [pc].src1 := x.adr; (* source address *)
		OPL.Instr [pc].src2 := nofElem.adr; (* nofelements *)
		OPL.Instr [pc].inx := moveSize; (* move size: 8, 16 or 32 bit *)
		INC (pc)
	END GenRepMovs;
	
	PROCEDURE GenPhi (reg0, reg1: LONGINT); 
	(* phi *)
	BEGIN
		InitInstr (phi, 0, 0, NIL);
		OPL.Instr [pc].src1 := reg0; OPL.Instr [pc].src2 := reg1;
		OPL.Instr [reg1].hint := SHORT (-1 - reg0);
		INC (pc)
	END GenPhi;

	PROCEDURE  MakeCon* (VAR cons: Item; typ: OPT.Struct; val: LONGINT);

	(* makes a constant item cons *)
	BEGIN
		cons.mode := Con; cons.adr := val; cons.offs := 0; cons.typ := typ; cons.node := NIL
	END MakeCon;

	PROCEDURE SetCC (VAR x: Item; cc: LONGINT); 
	(* set condition code *)
	BEGIN
		x.typ := OPT.booltyp; x.mode := Coc; x.adr := cc; x.offs := Nil; x.inx := Nil; x.node := NIL
	END SetCC;

	PROCEDURE DefLabel* (VAR L: Label);
	BEGIN
		L := pc;
		Gen0 (label)
	END DefLabel;
	
	PROCEDURE FixLinkWith (L, val: Label);
		VAR L1: Label;
	(* -2 - Label = position in the pseudo code *)
	BEGIN
		IF ~RiscCodeErr THEN
			ASSERT ((L < 0) & (val >= 0));
			L := -2 - L;
			WHILE L # Nil DO
				L1 := -2 - OPL.Instr[L].src2;
				OPL.Instr[L].src2 := val;
				L := L1
			END
		END
	END FixLinkWith;
	
	PROCEDURE FixLink* (L: Label);
		VAR L1: Label;
	(* -2 - Label = position in the pseudo code *)
	BEGIN
		IF ~RiscCodeErr THEN
			ASSERT (L < 0);
			L := -2 - L;
			IF L # Nil THEN
				REPEAT
					L1 := -2 - OPL.Instr[L].src2;
					OPL.Instr[L].src2 := pc;
					L := L1
				UNTIL L = Nil;
				Gen0 (label)
			END
		END
	END FixLink;
	
	PROCEDURE MergedLinks* (L0, L1: Label): Label;
		VAR L2, L3: Label;
	(* -2 - Label = position in the pseudo code *)
	BEGIN
		L2 := -2 - L0;
		IF ~RiscCodeErr & (L2 # Nil) THEN
			LOOP 
				L3 := -2 - OPL.Instr[L2].src2;
				IF L3 = Nil THEN EXIT END;
				L2 := L3
			END;
			OPL.Instr[L2].src2 := L1;
			RETURN L0
		ELSE 
			RETURN L1
		END
	END MergedLinks;

	PROCEDURE Jmp* (VAR loc: Label; node: OPT.Node);
	(* jump ; forward jumps are encoded as -2-pc, where pc is the address of the last jump -> fixup chain *)
		VAR pos: Label;
	BEGIN
		IF loc < 0 THEN (* forward jump *)
			pos := loc; loc := -2-pc;
			Gen1 (jmp, pos, node)
		ELSE (* backward jump *)
			Gen1 (jmp, loc, node)
		END
	END Jmp;

	PROCEDURE^ load (VAR x: Item);
	
	PROCEDURE Jcc* (VAR x: Item; VAR loc: Label; node: OPT.Node); 
	(* conditional jump ; forward jumps are encoded as -2-pc, where pc is the address of the last jump -> fixup chain *)
	BEGIN
		IF x.mode # Coc THEN
			ASSERT (x.typ.form = Bool);
			load (x); GenFlags (cmp, x, True);
			SetCC (x, EQ)
		END;
		IF x.adr # never THEN
			IF loc < 0 THEN (* forward jump *)
				Gen1 (SHORT (x.adr), x.offs, node); (* Tjmp *)
				loc := -2-(pc-1)
			ELSE (* backward jump *)
				Gen1 (SHORT (x.adr), loc, node); FixLinkWith (x.offs, loc)
			END
		ELSIF loc>=0 THEN FixLinkWith (x.offs, loc) (* Fjmp *)
		END;
		FixLink (x.inx) (* Fjmp *)
	END Jcc;	
	
	PROCEDURE Jncc* (VAR x: Item; VAR loc: Label; node: OPT.Node); 
	(* conditional jump on false *)
		VAR j: INTEGER;
	BEGIN
		IF x.mode # Coc THEN
			ASSERT (x.typ.form = Bool);
			load (x); GenFlags (cmp, x, True);
			SetCC (x, EQ)
		END;
		IF x.adr # always THEN
			IF x.adr = never THEN j := always ELSE j := InvCCtab [(x.adr - EQ) DIV 32] END;		(* jncc bug *)
			IF loc < 0 THEN (* forward jump *)
				Gen1 (j, x.inx, node); (* Fjmp *)
				loc := -2-(pc-1)
			ELSE (* backward jump *)
				Gen1 (j, loc, node);
				FixLinkWith (x.inx, loc) (* Fjmp *)
			END;
		ELSIF loc>=0 THEN FixLinkWith (x.inx, loc) (* Fjmp *)
		END;
		FixLink (x.offs) (* Tjmp *)
	END Jncc;
				
	PROCEDURE CompleteSL (VAR x: Item); 
	(* complete static link *)
		VAR n: INTEGER; sl: Item;
	BEGIN
		IF x.mnolev > 0 THEN
			n := level - x.mnolev;
			IF (x.mode IN {Var, VarPar}) & (n > 0) THEN
				sl.mode := RegRel; sl.typ := OPT.sysptrtyp; sl.mnolev := level; sl.inx := none; 
				sl.adr := FP; sl.offs := StaticLinkAdr; sl.node := NIL;
				IF n > 1 THEN
					load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
					WHILE n > 2 DO
						load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
						DEC (n)
					END
				END;
				load (sl);
				x.mode := RegRel; x.offs := x.adr; x.adr := sl.adr; x.inx := none
			END
		END
 	END CompleteSL;			

	PROCEDURE loadAdr (VAR x: Item); 
	(* load address *)
		VAR typ: OPT.Struct;
	BEGIN
		ASSERT (x.mode IN {Abs, Var, VarPar, RegRel});
		typ := x.typ;

		IF (x.mode = VarPar) OR ((x.typ.comp IN {Array, SDynArr, DynArr})&(x.typ.extlev=dynamic) & (x.mode = Var)) THEN

			CompleteSL (x);
			x.typ := OPT.sysptrtyp;
			IF x.mode = VarPar THEN (* x is from the own procedure *)
				x.mode := RegRel; x.offs := x.adr; x.adr := FP; x.inx := none
			END;
			GenLoad (ld, x, x)
		ELSE (* Abs, Var, RegRel *)
			CompleteSL (x);
			x.typ := OPT.sysptrtyp;
		(* IF (x.mode = RegRel) & (x.offs = 0) THEN x.mode := Reg ELSE *) GenLoad (lea, x, x) (* END*)	(* << mb 16.2.94 *)
		END;
		x.offs := 0; x.inx := none; x.scale := noScale; x.typ := typ
	END loadAdr;

	PROCEDURE loadf (VAR x: Item); 
	(* load floating point *)
	BEGIN
		IF x.mode # Reg THEN
			IF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel
			ELSE CompleteSL (x)
			END;
			GenLoad (fload, x, x)
		END
	END loadf;
	
	PROCEDURE load (VAR x: Item);
	BEGIN
		IF x.mode # Reg THEN
			IF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel
			ELSE CompleteSL (x)
			END;
			GenLoad (ld, x, x)
		END
	END load;
	
	PROCEDURE DeRef* (VAR x: Item);
		VAR btyp: OPT.Struct;
	BEGIN
		load (x);
		x.mode := RegRel; x.offs := 0; x.inx := none; x.scale := noScale;
		btyp := x.typ.BaseTyp;

		IF (btyp # NIL) & (btyp.comp IN {Array, SDynArr}) THEN
			REPEAT btyp := btyp.BaseTyp UNTIL ~(btyp.comp IN {Array, SDynArr});

			IF (btyp.comp = Record) OR (btyp.form = Pointer) THEN x.offs := 16 END 
			(* offset 16 = first element  -> used in types like POINTER TO ARRAY n OF {Record, Pointer} *)
		END
	END DeRef;


	PROCEDURE NewTdNode (VAR node: OPT.Node; entryNr: LONGINT; imported: BOOLEAN);
	(* new typedescriptor node: entryNr = high,low; imported = readonly field *)
		VAR 
			low, high: INTEGER;
			extraNode: OPL.ExtraNode;
	BEGIN
		NEW (node);
		NEW (extraNode); extraNode.next := OPL.extraNodes; extraNode.node := node; OPL.extraNodes := extraNode;
		node.left := NIL; node.right := NIL; node.link := NIL; node.typ := NIL; node.obj := NIL; node.conval := NIL;
		(* initialization of the typedescriptor node *)
		low := SHORT (entryNr MOD 100H);
		IF low > 127 THEN low := low - 256 END;
		high := SHORT ((entryNr DIV 100H) MOD 100H);
		IF high > 127 THEN high := high - 256 END;
		node.class := SHORT (high); node.subcl := SHORT (low); node.readonly := imported;
	END NewTdNode;

	PROCEDURE GetTdAdr (VAR typ: OPT.Struct; VAR tag: Item);
	(* returns the typedescriptor address (absolute address) *)
		VAR index: LONGINT;
	BEGIN
		ASSERT (typ # NIL);
		tag.mode := Abs; tag.mnolev := typ.mno; tag.typ := OPT.sysptrtyp; tag.inx := none; tag.adr := 0; tag.node := NIL;
		IF typ.mno = 0 THEN (* typedescriptor in the compiled module *)
			IF typ.tdadr DIV 10000H = 0 THEN (* first use of typ.tdadr *)
				typ.tdadr := (typ.tdadr + 1) * 10000H (* typ.tdadr DIV 10000H = EntryNr + 1 *)
			END;
			NewTdNode (tag.node, typ.tdadr DIV 10000H - 1, FALSE)
		ELSE (* type is imported *)
			IF typ.tdadr DIV 10000H = 0 THEN (* no link entry yet; typ.tdadr = EntryNr *)
				OPL.NewVarCons (typ.mno, SHORT (typ.tdadr), index);
				typ.tdadr := (index + 1) * 10000H + 1
					(* typ.tdadr DIV 10000H = VarConsLinkIndex + 1; typ.tdadr MOD 10000H = 1 -> imported type *)
			END;
			NewTdNode (tag.node, typ.tdadr DIV 10000H - 1, TRUE)
		END
	END GetTdAdr;


	PROCEDURE ^ Mul* (VAR z, x, y: Item; f: INTEGER); (* z := x * y *)

	PROCEDURE TypeTest* (VAR x: Item; testtyp: OPT.Struct; guard, equal, varRec: BOOLEAN);
	(*
		equal = TRUE: the two types must be the same
		guard = TRUE: trap is generated if test fails
		equal, guard = FALSE: only condition codes are set
	*)
		VAR testTag, z, c: Item;
	BEGIN
		ASSERT (testtyp # NIL);
		IF ~guard OR typchk THEN
			z := x;
			IF varRec THEN (* type descriptor is on the stack *)
				CompleteSL (z);
				IF z.mode IN {Var, VarPar} THEN
					INC (z.adr, 4); z.mode := Var  (* type descriptor is on the stack (hidden parameter) *)
				ELSE
					ASSERT (z.mode = RegRel);
					INC (z.offs, 4)
				END
			ELSE (* pointer *)
				IF testtyp.form = Pointer THEN
					testtyp := testtyp.BaseTyp;
					DeRef (z)
				END;
				z.offs := -4
			END;

			IF ~equal THEN
				DeRef (z);
				z.offs := z.offs + BaseTypeOffs - 4 * testtyp.extlev
			END;
			load (z);
			GetTdAdr (testtyp, testTag); load (testTag);
			GenFlags (cmp, z, testTag);
			IF equal THEN Gen1 (tne, OPL.EqualGuardTrap, NIL)
			ELSIF guard THEN Gen1 (tne, OPL.GuardTrap, NIL)
			ELSE SetCC (x, EQ)
			END
		END
	END TypeTest;

	PROCEDURE Procedure* (VAR proc: Item; n: OPT.Node);
		VAR obj: OPT.Object; index: LONGINT;
	BEGIN
		obj := n.obj;
		proc.mode := obj.mode; proc.node := n; proc.mnolev := obj.mnolev; proc.inx := none; 
		IF ~ (proc.mode IN {TProc, Typ}) THEN (* external, local procedure *)		(* was active only, seems safe *)
			IF (proc.mode IN {XProc}) & (proc.mnolev < 0) & (obj.adr DIV 10000H = 0) THEN 
				(* imported procedure and no link entry yet *)
				OPL.NewLink (-obj.mnolev, obj.adr, index);
				obj.adr := index * 10000H + obj.adr (* obj.adr = link index * 10000H + entry number *)
			END;
			proc.adr := obj.adr 
		ELSE (* proc.mode = TProc *)
			proc.offs := MethodOffs - 4 * (obj.adr DIV 10000H);
		END
	END Procedure;
	
	PROCEDURE CheckOverflow (VAR x: Item);
	BEGIN
		IF ovflchk THEN Gen1 (to, OPL.OverflowTrap, NIL) END
	END CheckOverflow;
			
	PROCEDURE CheckIntRange (VAR x: Item; form: SHORTINT);
	BEGIN
	END CheckIntRange;

	PROCEDURE CheckRealRange (VAR x: Item; form: SHORTINT);
	BEGIN
	END CheckRealRange;

	PROCEDURE CheckIndex (VAR index, len: Item);
		VAR t: Item;
	BEGIN
		t := index;
		IF index.mode = Con THEN (* DynArr with constant index *)
			load (t)
		END;
		GenFlags (cmp, t, len);
		Gen1 (tae, OPL.RangeTrap, NIL)
	END CheckIndex;
	
	PROCEDURE ChangeType (VAR item: Item; form: SHORTINT);
	BEGIN
		CASE form OF
			Byte: item.typ:= OPT.bytetyp
		  | Bool: item.typ:= OPT.booltyp
		  | Char: item.typ:= OPT.chartyp
		  | SInt: item.typ:= OPT.sinttyp
		  | Int: item.typ:= OPT.inttyp
		  | LInt: item.typ:= OPT.linttyp
		  | Real: item.typ:= OPT.realtyp
		  | LReal: item.typ:= OPT.lrltyp
		  | Set: item.typ:= OPT.settyp
		  | Pointer: item.typ:= OPT.sysptrtyp
		  | ProcTyp: item.typ:= OPT.notyp
		ELSE HALT (BUG)
		END
	END ChangeType;
	
	PROCEDURE^ Convert* (VAR x: Item; form: SHORTINT);
	
	PROCEDURE SetElem* (VAR z, x: Item); (* z := {x} *)
	BEGIN
		MakeCon (z, OPT.settyp, 0);
		load (z);
		IF x.typ.form # LInt THEN Convert (x, LInt)
		ELSE load (x)
		END;
		Gen3 (bts, z, z, x)
	END SetElem;

	PROCEDURE Convert* (VAR x: Item; form: SHORTINT);
		VAR 
			t: Item; 
			xform: SHORTINT;

		PROCEDURE IntToInt (VAR z, x: Item; xform, zform: SHORTINT);
		(* integer to integer convertion *)
		BEGIN
			ASSERT ((xform IN intSet) & (zform IN intSet) & (x.typ.form IN intSet) & (z.typ.form IN intSet));
			IF xform < zform THEN (* smaller to bigger *)
				IF x.mode = VarPar THEN
					loadAdr (x); x.mode := RegRel;
				ELSE CompleteSL (x)
				END;
				ChangeType (x, zform);
				IF x.mode # Con THEN															(* const conversion *)
					IF zform = Int THEN GenLoad (ldbw, z, x)
					ELSIF xform = Int THEN GenLoad (ldwdw, z, x)
					ELSE GenLoad (ldbdw, z, x)
					END
				ELSE z := x
				END
			ELSE (* bigger to smaller *)
				IF x.mode = Reg THEN
					ChangeType (x, zform);
					Gen2 (short, z, x)
				END;
				CheckIntRange (x, zform)
			END
			(* z.typ will be changed by Convert *)
		END IntToInt;
		
		PROCEDURE IntToReal (VAR z, x: Item; xform, zform: SHORTINT);
		(* integer to real convertion *)
			VAR  temp, cons: Item;
		BEGIN
			IF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel;
			ELSE CompleteSL (x)
			END;
			ChangeType (x, LInt);
			IF xform = SInt THEN GenLoad (ldbdw, x, x)
			ELSIF xform = Int THEN GenLoad (ldwdw, x, x)
			ELSE load (x)
			END;
			GenPush (x); (* store x on the stack as a temporary variable *)
			temp.mode := RegRel; temp.typ := OPT.linttyp; 
			temp.adr := ESP; temp.offs := 0; temp.inx := none; temp.node := NIL;
			ChangeType (z, zform);
			ChangeType (temp, zform);
			GenLoad (fild, z, temp);
			MakeCon (cons, OPT.linttyp, 4);
			temp := Stack; Gen3 (add, temp, Stack, cons) (* free temporary variable space *)
			(* z.typ will be changed by Convert *)
		END IntToReal;
		
		PROCEDURE IntToCharByte (VAR z, x: Item; form: SHORTINT);
		BEGIN
			IF (x.typ.form # SInt) & (x.mode = Reg) THEN
				ChangeType (x, form);
				Gen2 (short, z, x)
			END;
			CheckIntRange (x, form)
			(* z.typ will be changed by Convert *)
		END IntToCharByte;
		
		PROCEDURE RealToReal (VAR z, x: Item; xform, zform: SHORTINT);
		(* real to real convertion *)
		BEGIN
			IF xform < zform THEN (* smaller to bigger *)
				z := x; loadf (z);
			ELSE (* bigger to smaller *)
				z := x; loadf (z);
				CheckRealRange (x, Real)
			END
			(* z.typ will be changed by Convert *)
		END RealToReal;
		
		PROCEDURE RealToInt (VAR z, x: Item; xform, zform: SHORTINT);
		(* real to integer convertion *)
		BEGIN
			loadf (x); ChangeType (x, LInt);
			Gen2 (entier, z, x)
			(* z.typ will be changed by Convert *) 
		END RealToInt;
		
		PROCEDURE CharToInt (VAR z, x: Item; zform: SHORTINT);
		(* character to integer convertion *)
		BEGIN
			IF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel
			ELSE CompleteSL (x)
			END;
			ChangeType (x, zform);
			IF zform = Int THEN GenLoad (ldbwu, z, x)
			ELSIF zform = LInt THEN GenLoad (ldbdwu, z, x)
			ELSE (* ok, char or byte to shortint *)
			END
			(* z.typ will be changed by Convert *)
		END CharToInt;
	
		PROCEDURE ByteToInt (VAR z, x: Item; zform: SHORTINT);
		(* byte to integer convertion *)
		BEGIN
			IF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel
			ELSE CompleteSL (x)
			END;
			ChangeType (x, zform);
			IF zform = Int THEN GenLoad (ldbw, z, x)
			ELSIF zform = LInt THEN GenLoad (ldbdw, z, x)
			ELSE (* ok, char or byte to shortint *)
			END
			(* z.typ will be changed by convert *)
		END ByteToInt;
		
	BEGIN (* Convert *)
		IF x.mode = Coc THEN
			t := x; MoveCoc (x, t) 
		END;
		t := x; xform := x.typ.form;
		IF xform IN intSet THEN
			IF form IN intSet THEN IntToInt (x, t, xform, form)
			ELSIF form IN realSet THEN IntToReal (x, t, xform, form)
			ELSIF form IN {Char, Byte} THEN IntToCharByte (x, t, form)
			ELSE HALT (BUG)
			END
		ELSIF xform IN realSet THEN
			IF form IN realSet THEN RealToReal (x, t, xform, form)
			ELSIF form = LInt THEN RealToInt (x, t, xform, form)
			ELSIF form IN {Int, SInt} THEN
				RealToInt (x, t, xform, form); ChangeType (x, LInt); t := x; IntToInt (x, t, LInt, form)
			ELSIF form IN {Char, Byte} THEN
				RealToInt (x, t, xform, LInt); ChangeType (x, LInt); t := x; IntToCharByte (x, t, form)
			ELSE HALT (BUG)
			END
		ELSIF (xform IN {Byte, Char}) & (form IN {Byte,Char}) THEN (* ok, type is changed by OPV *)
		ELSIF xform = Char THEN
			ASSERT (form IN intSet + realSet);											(* shift error *)
			IF form IN intSet THEN CharToInt (x, t, form)
			ELSE	(* form IN realSet *)
				CharToInt(x, t, LInt); t:=x; IntToReal(x, t, LInt, form)
			END
		ELSIF xform = Byte THEN
			IF form IN intSet THEN ByteToInt (x, t, form)
			ELSIF form IN realSet THEN RealToInt (x, t, xform, form)
			ELSE HALT (BUG)
			END
		ELSIF (form = ProcTyp) & (xform # NoTyp) THEN HALT (BUG)
		END;
		ChangeType (x, form)
	END Convert;

	PROCEDURE Include* (VAR z, x: Item; incl: BOOLEAN); (* INCL / EXCL (z, x) *)
		VAR y,  v: Item;

		PROCEDURE exp2 (x: LONGINT): LONGINT;
		(* returns 2^x *)
			VAR i: LONGINT;
		BEGIN
			ASSERT (x >= 0);
			i := 1;
			WHILE x > 0 DO
				i := i * 2;
				DEC  (x)
			END;
			RETURN i
		END exp2;

	BEGIN
		v := z;
		load (v); y := v;
		IF incl THEN
			IF x.mode = Con THEN
				IF x.adr = OPM.MaxSet THEN x.adr := OPM.MinLInt
				ELSE x.adr := exp2 (x.adr)
				END;
				Gen3 (or, v, y, x)
			ELSE
				IF x.typ.form # LInt THEN Convert (x, LInt) END;
				load (x);
				Gen3 (bts, v, y, x)
			END
		ELSE
			IF x.mode = Con THEN
				IF x.adr = OPM.MaxSet THEN x.adr := OPM.MaxLInt
				ELSE x.adr := -1 - exp2 (x.adr)
				END;
				Gen3 (and, v, y, x)
			ELSE
				IF x.typ.form # LInt THEN Convert (x, LInt) END;
				load (x);
				Gen3 (btr, v, y, x)
			END
		END;
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel
		ELSE CompleteSL (z)
		END;
		GenStore (store, z, v)
	END Include;

	PROCEDURE MoveCoc (VAR z, y: Item); (* z := Coc (y) *)
		VAR L: Label; phiItem: Item;
	BEGIN
		ASSERT (y.mode = Coc);
		IF (y.offs = Nil) & (y.inx = Nil) THEN (* no jump links *)
			GenSetC (SHORT (sete + y.adr - EQ), z)
		ELSE
			Jncc (y, y.inx, NIL);
			GenLoad (ld, z, True);
			phiItem := z;
			L := Nil;
			Jmp (L, NIL);
			FixLink (y.inx); (* Fjmp fixup *)
			GenLoad (ld, z, False);
			GenPhi (phiItem.adr, z.adr); (* registers in z and phiItem must be the same when generating Intel code *)
			FixLink (L)
		END
	END MoveCoc;	

	PROCEDURE Relation* (VAR x: Item);
		VAR y: Item;
	BEGIN 
		IF x.mode = Coc THEN 
			y := x; MoveCoc (x, y) 
		END
	END Relation;

	PROCEDURE Cmp* (VAR z, x, y: Item; rel: INTEGER); (* z := cmp (x, y) *)
		VAR xform: INTEGER;
	BEGIN
		xform := x.typ.form;
		IF xform IN {Byte, Char..LInt, Set, NilTyp, Pointer, ProcTyp} THEN
			load (x);
			IF y.mode # Con THEN load (y) END;
			GenFlags (cmp, x, y)
		ELSIF xform IN realSet THEN
			loadf (y); loadf (x); GenFlags (fcmp, x, y)
		ELSIF xform = Bool THEN (* only eq or neq *)
			load (x);
			IF y.mode = Coc THEN
				z := y; MoveCoc (y, z) 
			ELSIF y.mode # Con THEN load (y)
			END;
			GenFlags (cmp, x, y)
		ELSE (* strings *)

			ASSERT ((xform = String) OR (x.typ.comp IN {Array, SDynArr, DynArr}));

			loadAdr (x); loadAdr (y);
			GenFlags (cmpString, x, y);
			xform := String;
		END;
		ASSERT (rel IN {eql, neq, lss, leq, gtr, geq});
		IF xform IN {Char, String, Real, LReal} THEN SetCC (z, CCtab [1, rel-eql])
		ELSE SetCC (z, CCtab [0, rel-eql])
		END;
	END Cmp;

	PROCEDURE In* (VAR z, x, y: Item); (* z := x IN y *)
		VAR t: Item;
	BEGIN
		IF (y.mode # Con) & (y.typ.form # Set) THEN
			t := y; SetElem (y, t)
		ELSE load (y)
		END;
		IF x.mode # Con THEN
			IF x.typ.form # LInt THEN Convert (x, LInt)
			ELSE load (x) 
			END
		END;
		GenFlags (bt, y, x);
		SetCC (z, CS)
	END In;

	PROCEDURE SetRange* (VAR z, x, y: Item); (* z := {x..y} *)
		VAR t, xShifted, yShifted, maxSet, fullSet: Item; val: LONGINT;
	BEGIN
		z.typ := OPT.settyp;
		MakeCon (fullSet, OPT.linttyp, -1);
		MakeCon (maxSet, OPT.linttyp, OPM.MaxSet);
		IF x.mode = Con THEN
			ASSERT (y.mode # Con);
			load (y);
			maxSet.typ := y.typ; load (maxSet);
			t := y; Gen3 (sub, y, maxSet, t);
			load (fullSet);
			Gen3 (shr, z, fullSet,  y);
			IF x.adr # 0 THEN
				IF x.adr = OPM.MaxSet THEN x.adr := MIN (LONGINT)
				ELSE
					val := 2;
					WHILE x.adr > 1 DO
						val := val*2;
						DEC (x.adr)
					END;
					x.adr := -val
				END;
				t := z; Gen3 (and, z, t, x)
			END
		ELSIF y.mode = Con THEN
			load (x);
			load (fullSet);
			Gen3 (sal, z, fullSet, x);
			IF y.adr # OPM.MaxSet THEN
				IF y.adr = OPM.MaxSet-1 THEN y.adr := MAX (LONGINT)
				ELSE
					val := 2;
					WHILE y.adr > 0 DO
						val := val*2;
						DEC (y.adr)
					END;
					y.adr := val-1
				END;
				t := z; Gen3 (and, z, t, y)
			END
		ELSE (* x, y # constant *)
			load (x);
			t := fullSet; load (t);
			xShifted.typ := OPT.linttyp; xShifted.node := NIL;
			Gen3 (sal, xShifted, t, x);
			load (y);
			maxSet.typ := y.typ; load (maxSet);
			t := y; Gen3 (sub, y, maxSet, t);
			load (fullSet);
			yShifted.typ := OPT.linttyp; yShifted.node := NIL;
			Gen3 (shr, yShifted, fullSet, y);
			Gen3 (and, z, xShifted, yShifted)
		END
	END SetRange;

	PROCEDURE Not* (VAR z, x: Item); (* z := NOT (x) *)
		VAR temp: LONGINT;
	BEGIN
		IF x.mode = Coc THEN
			z := x; z.adr := InvCCtab [(z.adr - EQ) DIV 32];
			temp := z.offs; z.offs := z.inx; z.inx := temp; (* permute Fjmp and Tjmp *)
		ELSE
			load (x);
			GenFlags (cmp, x, False);
			SetCC (z, EQ)
		END
	END Not;
	
	PROCEDURE Neg* (VAR z, x: Item); (* z := -x *)
	BEGIN
		ASSERT ( (x.typ.form = Set) OR (x.typ.form IN intSet) OR (x.typ.form IN realSet) );
		IF x.typ.form = Set THEN 
			load (x); Gen2 (not, z, x)
		ELSIF x.typ.form IN intSet THEN
			load (x); Gen2 (neg, z, x)
		ELSE (* x.typ.form = realSet *)
			loadf (x);  Gen2 (fchs, z, x)
		END
	END Neg;
	
	PROCEDURE AbsVal* (VAR z, x: Item); (* z := ABS (x) *)
	BEGIN
		ASSERT ( (x.typ.form IN intSet) OR (x.typ.form IN realSet) );
		IF x.typ.form IN intSet THEN
			load (x);
			Gen2 (abs, z, x);
			IF x.typ.form IN {Int, LInt} THEN OPL.Instr [pc-1].hint := OPL.useEAX END;
		ELSE (* x.typ.form IN realSet *)
			loadf (x);
			Gen2 (fabs, z, x)
		END
	END AbsVal;
	
	PROCEDURE Cap* (VAR z, x: Item); (* z := CAP (x) *)
		VAR c: Item;
	BEGIN
		MakeCon (c, OPT.chartyp, 5FH);
		load (x);
		Gen3 (and, z, x, c)
	END Cap;
	
	PROCEDURE Odd* (VAR z, x: Item); (* z := ODD (x) *)
		VAR c: Item;
	BEGIN
		MakeCon (c, OPT.sinttyp, 1);
		load (x);
		Gen3 (and, z, x, c)
	END Odd;
	
	PROCEDURE Ash* (VAR z, x, y: Item); (* z := ASH (x, y) *)
		VAR L, Lc: Label; t, phiItem: Item;
	BEGIN
		IF y.mode = Con THEN
			IF x.mode = Con THEN
				MakeCon (z, OPT.linttyp, ASH (x.adr, y.adr));
			ELSIF y.adr > 0 THEN
				load (x); Gen3 (sal, z, x, y) 
			ELSIF y.adr < 0 THEN
				y.adr := ABS (y.adr);
				load (x); Gen3 (sar, z, x, y)
			END
		ELSE
			load (x); load (y); z.typ := OPT.linttyp;
			MakeCon (t, OPT.linttyp, 0);
			GenFlags (cmp, y, t);
			Lc := -2-pc; Gen1 (jl, Nil, NIL);
			Gen3 (sal, z, x, y);
			L := -2-pc; Gen1 (jmp, Nil, NIL); 
			phiItem := z;
			FixLink (Lc);
			Gen2 (neg, t, y);
			Gen3 (sar, z, x, t);
			GenPhi (phiItem.adr, z.adr); (* z and phiItem must be in the same register when generating target code *)
			FixLink (L)
		END
	END Ash;

	PROCEDURE Add* (VAR z, x, y: Item; f: INTEGER); (* z := x + y *)
	BEGIN
		ASSERT ( (f IN realSet) OR (f = Set) OR (f IN intSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y); Gen3 (fadd, z, x, y)
		ELSIF f = Set THEN 
			IF x.mode = Con THEN 
				load (y); Gen3 (or, z, y, x)
			ELSE
				load (x);
				IF y.mode # Con THEN load (y) END;
				Gen3 (or, z, x, y)
			END
		ELSE (* f IN intSet *)
			IF x.mode = Con THEN
				load (y); Gen3 (add, z, y, x)
			ELSE
				load (x);
				IF y.mode # Con THEN load (y) END;
				Gen3 (add, z, x, y)
			END;
			CheckOverflow (z)
		END
	END Add;

	PROCEDURE Sub* (VAR z, x, y: Item; f: INTEGER); (* z := x - y *)
		VAR t: Item;
	BEGIN
		ASSERT ( (f IN realSet) OR (f = Set) OR (f IN intSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y);  Gen3 (fsub, z, x, y)
		ELSIF f = Set THEN 
			load (x);
			IF y.mode # Con THEN
				load (y); Gen2 (not, t, y)
			ELSE
				y.adr := -1- y.adr; t := y
			END;
			z := x; Gen3 (and, z, x, t)
		ELSE (* f IN intSet *)
			load (x);
			IF y.mode # Con THEN load (y) END;
			Gen3 (sub, z, x, y);
			CheckOverflow (z)
		END
	END Sub;
	
	PROCEDURE Mul* (VAR z, x, y: Item; f: INTEGER); (* z := x * y *)
		VAR val, exp: LONGINT; shift: Item;
	BEGIN
		ASSERT ( (f = Set) OR (f IN intSet) OR (f IN realSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y); Gen3 (fmul, z, x, y)
		ELSIF f = Set THEN
			IF x.mode = Con THEN
				load (y); Gen3 (and, z, y, x)
			ELSE
				load (x);
				IF (y.mode # Reg) & (y.mode # Con) THEN load (y) END;
				Gen3 (and, z, x, y)
			END
		ELSE (* f IN intSet *) 
		(*  The shift-left check is necessary because several procedures in OPC call Mul directly. *)
			MakeCon (shift, OPT.linttyp, 0);
			IF x.mode = Con THEN
				val := x.adr; exp := 0;
				ASSERT (val # 0);
				WHILE ~ODD (val) DO 
					val := val DIV 2;
					INC (exp)
				END;
				load (y);
				IF (val = 1) & ~ovflchk THEN (* shift *)
					IF exp # 0 THEN
						shift.adr := exp; Gen3 (sal, z, y, shift)
					ELSE z := y
					END
				ELSE Gen3 (mul, z, y, x)
				END
			ELSIF y.mode = Con THEN
				val := y.adr; exp := 0;
				ASSERT (val # 0);
				WHILE ~ODD (val) DO
					val := val DIV 2;
					INC (exp)
				END;
				load (x);
				IF (val = 1) & ~ovflchk THEN (* shift *)
					IF exp # 0 THEN
						shift.adr := exp; Gen3 (sal, z, x, shift)
					ELSE z := x
					END
				ELSE Gen3 (mul, z, x, y)
				END
			ELSE
				load (x); load (y);
				Gen3  (mul, z, x, y)
			END;
			CheckOverflow (z)
		END
	END Mul;
	
	PROCEDURE Div* (VAR z, x, y: Item; f: INTEGER); (* z := x DIV y; z := x / y *)
	BEGIN
		ASSERT ( (f IN realSet) OR (f = Set) OR (f IN intSet) );
		IF f IN realSet THEN
			loadf (x); loadf (y); Gen3 (fdiv, z, x, y)
		ELSIF f = Set THEN
			IF x.mode = Con THEN 
				load (y); Gen3 (xor, z, y, x) 
			ELSE
				load (x);
				IF (y.mode # Reg) & (y.mode # Con) THEN load (y) END;
				Gen3 (xor, z, x, y)
			END
		ELSE (* f IN intSet *) (* front end checks for shift right possibilities *)
			load (x);
			IF y.mode # Con THEN load (y) END;
			Gen3 (div, z, x, y)
			(* no overflow check necessary *)
		END
	END Div;

	PROCEDURE Mod* (VAR z, x, y: Item); (* z := x MOD y *)
	BEGIN 
		load (x);
		IF y.mode # Con THEN load (y) END; (* front end checks for shift left possibilities *)
		Gen3 (mod, z, x, y)
		(* no overflow check necessary *)
	END Mod;

	PROCEDURE CondAnd* (VAR x: Item); (* prepares conditional and *)
		VAR jcc: INTEGER;
	BEGIN
		IF x.mode = Coc THEN jcc := InvCCtab [(x.adr - EQ) DIV 32]
		ELSE (* form = Bool, mode # Con *)
			ASSERT ( (x.typ.form = Bool) & (x.mode # Con) );
			load (x); GenFlags (cmp, x, True);
			SetCC (x, NE);
			jcc := jne
		END;
		Gen1 (jcc, x.inx, NIL); (* ... Fjmp *) 
		x.inx := -2-(pc-1);
		FixLink (x.offs) (* Tjmp here *)
	END CondAnd;

	PROCEDURE And* (VAR z, x, y: Item); (* conditional and *)
	BEGIN
		z := x;
		IF y.mode # Coc THEN
			IF y.mode = Con THEN
				IF y.adr = true THEN SetCC (y, always) 
				ELSE SetCC (y, never) 
				END
			ELSE
				load (y); GenFlags (cmp, y, True); 
				SetCC (y, EQ)
			END
		END;
		IF y.inx # Nil THEN z.inx := MergedLinks (z.inx, y.inx) END; (* merge Fjmp *)
		z.adr := y.adr; z.offs := y.offs (* Tjmp *)
	END And;

	PROCEDURE CondOr* (VAR x: Item); (* prepares conditional or *)
		VAR jcc: INTEGER;
	BEGIN
		IF x.mode = Coc THEN jcc := SHORT (x.adr)
		ELSE (* form = Bool, mode # Con *)
			ASSERT ( (x.typ.form = Bool) & (x.mode # Con) );
			load (x); GenFlags (cmp, x, True);
			SetCC (x, EQ);
			jcc := je
		END;
		Gen1 (jcc, x.offs, NIL); (* ... Tjmp *)
		x.offs := -2-(pc-1);
		FixLink (x.inx) (* Fjmp here *)
	END CondOr;

	PROCEDURE Or* (VAR z, x, y: Item); (* conditional or *)
	BEGIN
		z := x;
		IF y.mode # Coc THEN
			IF y.mode = Con THEN
				IF y.adr = true THEN SetCC (y, always) 
				ELSE SetCC (y, never) 
				END
			ELSE
				load (y); GenFlags (cmp, y, True); 
				SetCC (y, EQ)
			END
		END;
		IF y.offs # Nil THEN z.offs := MergedLinks (x.offs, y.offs) END; (* merge Tjmp *)
		z.adr := y.adr; z.inx := y.inx (* Fjmp *)
	END Or;

	PROCEDURE SYSmop* (VAR z, x: Item; subcl: SHORTINT; typ: OPT.Struct);	
	(* implementation of SYSTEM.ADR, CC, VAL *)
		VAR
			xform, typform: SHORTINT;
			t, const: Item;
	BEGIN
		CASE subcl OF
			adr: loadAdr (z)
		  | cc: z := x; OPM.err (200) (* !!later: not implemented *)
		  | val: 
				xform := x.typ.form; typform := typ.form;
				MakeCon (const, OPT.linttyp, 4);
				IF (xform IN  {Byte, Char, SInt, Int, LInt, Set, Pointer, ProcTyp}) & (typform IN realSet) & (x.mode = Reg) THEN
					(* load (x) *); GenPush (x);
					t.mode := RegRel; t.adr := ESP; t.offs := 0; t.inx := none; t.typ := OPT.realtyp; t.node := NIL;
					GenLoad (fload, z, t);
					t := Stack; Gen3 (add, t, t, const)
				ELSIF (xform IN realSet) & (typform IN {Byte, Char, SInt, Int, LInt, Set, Pointer, ProcTyp}) 
						& (x.mode = Reg) THEN
					t := Stack; Gen3 (sub, t, t, const);
					t.mode := RegRel; t.adr := ESP; t.offs := 0; t.inx := none; t.typ := OPT.realtyp; t.node := NIL;
					loadf (x);
					GenStore (fstore, t, x);
					t.typ := typ; GenLoad (ld, z, t);
					t := Stack; Gen3 (add, t, t, const)
				END;
				IF (z.typ.size # typ.size) & ((x.mode # Con) OR (typ.size > 4)) THEN OPM.err(-304) END;
				z.typ := typ
			END
	END SYSmop;
	
	PROCEDURE Mem (VAR x: Item); (* x := MEM [x] *)
	BEGIN
		IF x.mode = Con THEN 
			x.mode := Abs; x.inx := none
		ELSE
			load (x); x.mode := RegRel; x.offs := 0; x.inx := none
		END
	END Mem;
	
	PROCEDURE SYSdop* (VAR z, x, y: Item; subcl: SHORTINT);	(* implementation of SYSTEM.BIT, LSH, ROT *)
		VAR t, phiItem: Item; L, Lc: Label;
	BEGIN 
		CASE subcl OF
			bit:
				Mem (x); load (x);
				IF y.mode # Con THEN load (y) END;
				GenFlags (bt, x, y);
				GenSetC (setc, z)
		  | lsh:
				IF y.mode = Con THEN
					IF x.mode = Con THEN
						MakeCon (z, OPT.linttyp, SYSTEM.LSH (x.adr, y.adr))										(* shift error *)
					ELSIF y.adr > 0 THEN
						load (x); Gen3 (sal, z, x, y) 
					ELSIF y.adr < 0 THEN
						y.adr := ABS (y.adr);
						load (x); Gen3 (shr, z, x, y)
					END
				ELSE
					load (x); load (y);
					MakeCon (t, OPT.linttyp, 0);
					GenFlags (cmp, y, t);
					Lc := -2-pc; Gen1 (jl, Nil, NIL);
					Gen3 (sal, z, x, y); 
					phiItem := z;
					L := -2-pc; Gen1 (jmp, Nil, NIL);
					FixLink (Lc);
					Gen2 (neg, t, y);
					Gen3 (shr, z, x, t);
					GenPhi (phiItem.adr, z.adr); (* phiItem, z must have the same register when generating targed code *)
					FixLink (L)
				END
		  | rot:
				IF y.mode = Con  THEN
					IF x.mode = Con THEN
						MakeCon (z, x.typ, 0);
						CASE x.typ.form OF
							Byte, Char, SInt:
								z.adr := SYSTEM.ROT (SYSTEM.VAL (SHORTINT, x.adr), SHORT (y.adr))
						  | Int:
								z.adr := SYSTEM.ROT (SYSTEM.VAL (INTEGER, x.adr), SHORT (y.adr))
						  | LInt:
								z.adr := SYSTEM.ROT ( x.adr, SHORT (y.adr))
						END
					ELSE
						load (x); Gen3 (rol,  z, x, y)
					END
				ELSE
					load (x); load (y);
					Gen3 (rol, z, x, y)
				END
		END
	END SYSdop;
	
	PROCEDURE SYSgetput* (VAR z, x: Item; getfn: BOOLEAN);	(* SYSTEM.GET, SYSTEM.PUT *)
		VAR form: SHORTINT; constAddr: BOOLEAN;					(* GetPut *)
	BEGIN
		IF getfn THEN
			constAddr := x.mode = Con;					(* GetPut *)
			Mem (x); x.typ := z.typ; form := z.typ.form
		ELSE
			constAddr := z.mode = Con;					(* GetPut *)
			Mem (z);
			z.typ := x.typ; form := x.typ.form
		END;
		IF form IN realSet THEN loadf (x)
		ELSE load (x)
		END;
		OPL.Instr [pc-1].abs := constAddr & getfn;			(* if x is the address and a constant, no fixup *)	(* GetPut *)
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel
		ELSE CompleteSL (z)
		END;
		IF form IN realSet THEN GenStore (fstore, z, x)
		ELSE GenStore (store, z, x)
		END;
		OPL.Instr [pc-1].abs := constAddr & ~getfn			(* if z is the address and a constant, no fixup *)	(* GetPut *)
	END SYSgetput;

	PROCEDURE SYSportio* (VAR z, x: Item; pin: BOOLEAN);	(* SYSTEM.PORTIN, SYSTEM.PORTOUT *)(* New Functions *)
	(*	OUT x, z	/	IN z, x	*)
		 VAR	port, reg: Item; 
	BEGIN
		reg.mode := Reg; reg.node := NIL;
		IF pin THEN
			IF x.mode # Reg THEN 
				load(x);		(* load x into reg *)
			END;
			OPL.Instr [x.adr].hint := OPL.useEDX;	(* let the reg be DX *)
			ASSERT((x.mode = 15) & (x.typ = OPT.inttyp));
			x.typ := z.typ;		(* generate correct size *)
			GenLoad(in, reg, x);
			OPL.Instr [pc-1].hint := OPL.useEAX;
			IF z.mode = VarPar THEN 
				loadAdr(z); z.mode := RegRel		(* generate 0[Reg] where Reg = Address(par) *)
			ELSE CompleteSL(z)
			END;
			GenStore(store, z, reg)
		ELSE
			IF z.mode # Reg THEN  load(z)		(* load z into reg *)
			END;
			OPL.Instr [z.adr].hint := OPL.useEDX;
			ASSERT( z.mode = Reg );
			IF x.mode = VarPar THEN
				loadAdr(x); x.mode := RegRel		(* generate 0[Reg] where Reg = Address(par) *)
			ELSE CompleteSL(x)
			END;
			IF x.mode # Reg THEN GenLoad(ld, x, x) END;
			OPL.Instr [x.adr].hint := OPL.useEAX;
			ASSERT( x.mode = Reg );	
			GenLoad(out, reg, x);
			OPL.Instr [pc-1].dest := z.adr
		END;
	END SYSportio;

	PROCEDURE SYSgetputReg* (VAR z, x: Item; getrfn: BOOLEAN); (* SYSTEM.PUTREG, SYSTEM.GETREG *)
	(* 
	0	EAX/AX/AL	1	ECX/CX/CL	2	EDX/DX/DL	3	EBX/BX/BL
	4	ESP/SP/AH	5	EBP/BP/CH	6	ESI/SI/DH	7	EDI/DI/DL
	registers size is depending on the type of the variable (2nd argument in PUTREG/GETREG). 
	SHORTINT 	= 8 bit values 	(AL, CL, DL, BL, AH, CH, DH, DL)
	INTEGER  	= 16 bit values 	(AX, CX, DX, BX, SP, BP, SI, DI)
	LONGINT 	= 32 bit values 	(EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI)
	SYTEM.PUTREG (const, const) always access 32 bit register. 	*)
		VAR reg: Item;
	BEGIN
		reg.mode := Reg; reg.node := NIL;
		IF getrfn THEN
			reg.adr := x.adr; reg.typ := z.typ;
			IF z.mode = VarPar THEN
				loadAdr (z); z.mode := RegRel
			ELSE CompleteSL (z)
			END;
			GenStore (getReg, z, reg);
			OPL.Instr [pc-1].hint := OPL.useEAX + x.adr
		ELSE (* putrrn *)
			IF x.mode = Con THEN x.typ := OPT.linttyp
			ELSIF x.mode = VarPar THEN
				loadAdr (x); x.mode := RegRel
			ELSE CompleteSL (x)
			END;
			GenLoad (putReg, reg, x);
			OPL.Instr [pc-1].hint := OPL.useEAX + z.adr
		END
	END SYSgetputReg;

	PROCEDURE SYSinterrupt* (clear: BOOLEAN);					(* New Functions *)
	(*		inserts a CLI (clear) or a STI (~clear) instruction	*)
	BEGIN
		IF clear THEN Gen0(cli) ELSE Gen0(sti) END
	END SYSinterrupt;

	PROCEDURE Msk* (VAR z, x, y: Item); (* z := x AND y *)
	BEGIN
		y.adr := -1 - y.adr; (* invert y.adr *)
		load (x);
		Gen3 (and, z, x, y)
	END Msk;

	PROCEDURE Field* (VAR x: Item; offset: LONGINT); (* Record.field *)
	BEGIN
		ASSERT (x.mode IN {Var, VarPar, Abs, RegRel});
		IF x.mode IN {Var, Abs} THEN INC (x.adr, offset)
		ELSIF x.mode = VarPar THEN
			loadAdr (x); x.mode := RegRel; x.offs := offset
		ELSE (* RegRel *)
			INC (x.offs, offset)
		END
	END Field;


	PROCEDURE DynArrLen (VAR len, arr: Item; offs: LONGINT; n: LONGINT);

	(* returns the length in the offs DIV 4 -th dimension of a dynamic array *)
	BEGIN
		IF arr.descReg = FP THEN

			 len.mode := Var; len.adr := arr.descOffs + 4*(n+1); len.offs := 0

		ELSE
			len.mode := RegRel; len.adr := arr.descReg; len.offs := arr.descOffs + offs
		END;
		len.typ := OPT.linttyp; len.node := NIL; len.mnolev := arr.mnolev; len.inx := none 
	END DynArrLen;


	PROCEDURE SDynArrLen(VAR len: Item; link: OPT.Object);
	BEGIN
		len.mode := Var; len.adr := link.linkadr; len.offs := 0; len.typ := OPT.linttyp; len.node := NIL;
		len.mnolev := link.mnolev; len.inx := none
	END SDynArrLen;
	
	PROCEDURE Len* (VAR len, x, y: Item);	(* len := LEN (x, y), where x is a dynamic array and y the dimension *)
		VAR L: INTEGER; typ: OPT.Struct;
	BEGIN
		L := SHORT(y.adr); typ:=x.typ;
		WHILE L>0 DO typ:=typ.BaseTyp; DEC(L) END;
		IF typ.link=NIL THEN DynArrLen (len, x, typ.offset, typ.n) ELSE SDynArrLen (len, typ.link) END
	END Len;
	
	PROCEDURE DynLow(VAR z, lb: Item; VAR typ:OPT.Struct);
	BEGIN
		IF z.descReg=FP THEN
			lb.mode:=Var; lb.adr:=z.descOffs+4*(typ.n+2); lb.offs:=0;
		ELSE
			lb.mode:=RegRel; lb.adr:=z.descReg; lb.offs:=z.descOffs+ typ.offset-4
		END;
		lb.typ:=OPT.linttyp; lb.node:=NIL; lb.mnolev:=z.mnolev; lb.inx:=none
	END DynLow;

	PROCEDURE Low* (VAR lb, arr, y: Item);
		VAR t: OPT.Struct; i: LONGINT;
	BEGIN 
		t:=arr.typ; i:=y.adr;
		WHILE i>0 DO t:=t.BaseTyp; DEC(i) END;
		DynLow(arr, lb, t)
	END Low;
	
	PROCEDURE BaseTypSize (VAR sizeItem, arr: Item; typ: OPT.Struct; VAR size: LONGINT; VAR done: BOOLEAN);
		VAR len, t: Item;
	BEGIN
		IF (typ.comp IN {Array, SDynArr, DynArr}) & (typ.extlev=dynamic) THEN
			BaseTypSize(sizeItem, arr, typ.BaseTyp, size, done);
			IF typ.comp=Array THEN size:=size*typ.n
			ELSIF typ.comp=SDynArr THEN
				IF done THEN SDynArrLen(len, typ.link); t := sizeItem; Mul (sizeItem, t, len, LInt)
				ELSE SDynArrLen(sizeItem, typ.link); done:=TRUE
				END
			ELSIF done THEN
				DynArrLen(len, arr, typ.offset, typ.n); t := sizeItem; Mul (sizeItem, t, len, LInt)
			ELSE
				DynArrLen(sizeItem, arr, typ.offset, typ.n); done:=TRUE
			END
		ELSIF typ.comp IN {Array, SDynArr} THEN
			IF typ.extlev=sdynamic THEN BaseTypSize(sizeItem, arr, typ.BaseTyp, size, done);
				IF typ.comp=Array THEN size:=size*typ.n
				ELSIF done THEN SDynArrLen(len, typ.link); t := sizeItem; Mul (sizeItem, t, len, LInt) 
				ELSE SDynArrLen(sizeItem, typ.link); done:=TRUE
				END
			ELSE
				size:=typ.size
			END
		ELSE size:=typ.size
		END;
		IF typ=arr.typ.BaseTyp THEN
			CASE size MOD 8 OF
			| 2, 6: MakeCon(len, OPT.linttyp, size DIV 2); size:=2
			| 4: MakeCon(len, OPT.linttyp, size DIV 4); size:=4
			| 0: MakeCon(len, OPT.linttyp, size DIV 8); size:=8
			ELSE MakeCon(len, OPT.linttyp, size); size:=1
			END;
			IF (len.adr>1) & done THEN t:=sizeItem; Mul (sizeItem, t, len, LInt)
			ELSIF (len.adr>1) OR ~done THEN MakeCon(sizeItem, OPT.linttyp, len.adr)
			END;
		END;
	END BaseTypSize;
	
	PROCEDURE DynArrSize (VAR sizeItem, arr: Item; VAR size: LONGINT);
	(* returns the size of array arr. sizeItem * size = array size, measured in bytes *)
		VAR len, t: Item; done: BOOLEAN;
	BEGIN done:=FALSE;
		IF (arr.typ.comp IN {Array, SDynArr})&(arr.typ.extlev=dynamic) THEN
			BaseTypSize(sizeItem, arr, arr.typ.BaseTyp, size, done);
			IF arr.typ.comp=Array THEN size:=size*arr.typ.n
			ELSIF done THEN SDynArrLen(len, arr.typ.link); t := sizeItem; Mul (sizeItem, t, len, LInt)
			ELSE SDynArrLen(sizeItem, arr.typ.link)
			END
		ELSE
			DynArrLen (sizeItem, arr, arr.typ.offset(*(arr.typ.n + 1) * 4*),  arr.typ.n);
			IF arr.typ.n>0 THEN
				BaseTypSize (t, arr, arr.typ.BaseTyp, size, done);
				len := sizeItem;
				Mul (sizeItem, t, len, LInt)
			ELSE size := arr.typ.BaseTyp.size
			END
		END
	END DynArrSize;


	PROCEDURE Length (VAR len, x: Item); (* len := LEN (x) *)
	BEGIN
		IF x.typ.form = String THEN MakeCon (len, OPT.linttyp, x.offs);
		ELSIF x.typ.comp = Array THEN MakeCon (len, OPT.linttyp, x.typ.n)

		ELSIF x.typ.comp=SDynArr THEN SDynArrLen(len, x.typ.link)
		ELSE (* x.typ.comp = DynArr *)
			ASSERT (x.typ.comp = DynArr);
			DynArrLen (len, x, x.typ.offset, x.typ.n)

		END
	END Length;

	PROCEDURE Index* (VAR z, index: Item); (* z := z[index] *)
		VAR
			size, scale: LONGINT;
			t, cons, sizeItem, len  , lb  : Item;
			basetyp: OPT.Struct;
			comp: SHORTINT;

			sizeundef, done: BOOLEAN;

	BEGIN
		comp := z.typ.comp;  sizeundef:=(comp IN {Array, SDynArr}) & (z.typ.extlev IN {dynamic, sdynamic}); 

		IF ((comp = DynArr) OR sizeundef) & (z.mode IN {Var, VarPar}) THEN (* open array *)

			z.mode := VarPar; loadAdr (z); z.mode := RegRel
		END;
		basetyp := z.typ.BaseTyp; size := basetyp.size;
		IF  ~sizeundef & (z.typ.extlev#sdynamic) &  (comp # DynArr) & (index.mode = Con) THEN Field (z, index.adr * size)
		ELSE
			IF index.typ.form # LInt THEN
				IF index.mode = Con THEN index.typ := OPT.linttyp
				ELSE Convert (index, LInt)
				END
			ELSE load (index)
			END;

			(* load shift *)
			IF z.typ.lb=MAX(LONGINT) THEN	(* open lb *)
				IF index.mode=Con THEN load(index) END;
				DynLow(z, lb, z.typ); load(lb); Gen3(sub, index, index, lb)
			END;
			IF  inxchk THEN (* index check *)
				IF comp = DynArr THEN
					DynArrLen (len, z, z.typ.offset, z.typ.n); load (len); CheckIndex (index, len)
				ELSIF comp=SDynArr THEN
					SDynArrLen(len, z.typ.link); load(len); CheckIndex(index, len)
				ELSIF index.mode#Con THEN
					MakeCon (len, OPT.linttyp, z.typ.n); 
					CheckIndex (index, len)
				END
			END;
			IF basetyp.extlev IN {dynamic, sdynamic} THEN done:=FALSE;
				ASSERT (sizeItem.mode # Con);
				IF (index.mode # Con) OR (index.adr#0) THEN
					BaseTypSize (sizeItem, z, basetyp, scale, done);
					t := index; Mul (index, sizeItem, t, LInt)
				END

			ELSIF (basetyp.comp # Basic) & ~((size = 1) OR (size = 2) OR (size = 4) OR (size = 8)) THEN
				scale := 1;
				IF (index.mode # Con)  THEN
					MakeCon (cons, OPT.linttyp, size);
					t := index; Mul (index, t, cons, LInt)

				ELSIF index.adr#0 THEN
					index.adr:=index.adr*size

				END
			ELSE scale := size
			END;
		(*	CompleteSL (z); *)
			IF (z.mode = Var) & (level - z.mnolev > 0 ) THEN (* we need static link *)
				CompleteSL (z);
			END;
			IF (z.mode = Abs) & (z.inx = none) THEN (* Abs with no index yet *)
				ASSERT (index.mode # Con);
				z.inx := index.adr
			ELSIF z.mode = Var THEN (* local variable *)
				ASSERT (index.mode # Con);
				z.mode := RegRel; z.offs := z.adr; z.adr := FP; z.inx := index.adr
			ELSIF z.mode = VarPar THEN
				ASSERT (index.mode # Con);
				loadAdr (z); z.mode := RegRel; z.inx := index.adr
			ELSIF (z.mode = RegRel) & (z.inx = none) THEN
				IF index.mode = Con THEN (* dynamic array with constant index *)
					z.offs := z.offs + index.adr * scale; scale := z.scale
				ELSE z.inx := index.adr
				END
			ELSE (* z.mode IN {RegRel, Abs} with index *)
				ASSERT ((z.mode IN {RegRel, Abs}) & (z.inx # none));
				IF index.mode = Con THEN (* dynamic array with constant index *)
					z.offs := z.offs + index.adr * scale; scale := z.scale	(* << mh 30.8.94 *)
				ELSE
					GenLoad (lea, z, z);
					z.mode := RegRel; z.inx := index.adr; z.offs := 0
				END
			END;
			IF index.mode # Con THEN
				CASE scale OF
					1: z.scale := OPO.Scale1
				  | 2: z.scale := OPO.Scale2
				  | 4: z.scale := OPO.Scale4
				  | 8: z.scale := OPO.Scale8
				ELSE HALT (BUG)
				END
			END
		END
	END Index;

	PROCEDURE MoveBlock (VAR z, x, size: Item; moveSize: SHORTINT);
	(* move 'size' element from x to z, where 'element' has the size 'moveSize' (byte, word, dword *)
	BEGIN
		ASSERT (moveSize IN {OPO.Bit8, OPO.Bit16, OPO.Bit32});
		IF (size.mode = Con) & (moveSize IN {OPO.Bit16, OPO.Bit8})  THEN (* try to optimize *)
			IF (size.adr MOD 4 = 0) & (moveSize = OPO.Bit8) THEN
				size.adr := size.adr DIV 4; moveSize := OPO.Bit32
			ELSIF size.adr MOD 2 = 0 THEN
				size.adr := size.adr DIV 2; DEC (moveSize, 8) (* 8 bit -> 16 bit; 16  bit -> 32 bit *)
			END
		END;
		IF (size.typ.form # LInt) & (size.mode # Con) THEN
			Convert (size, LInt); OPL.Instr [size.adr].hint := OPL.useECX;
		ELSE
			IF size.mode # Reg THEN
				size.typ := OPT.linttyp; load (size); OPL.Instr [size.adr].hint := OPL.useECX
			ELSIF (size.adr > 0) & (OPL.Instr [size.adr].hint = OPL.noHint)  THEN OPL.Instr [size.adr].hint := OPL.tryECX
			END
		END;
		IF x.mode # Reg THEN
			loadAdr (x); OPL.Instr [x.adr].hint := OPL.useESI
		ELSIF (x.adr >= 0) & (OPL.Instr [x.adr].hint = OPL.noHint) THEN OPL.Instr [x.adr].hint := OPL.tryESI
		END;
		IF z.mode # Reg THEN
			loadAdr (z); OPL.Instr [z.adr].hint := OPL.useEDI
		ELSIF (z.adr >= 0) & (OPL.Instr [z.adr].hint = OPL.noHint) THEN OPL.Instr [z.adr].hint := OPL.tryEDI
		END;
		Gen0 (cld);
		GenRepMovs (z, x, size, moveSize);
		IncReg (size.adr); IncReg (x.adr); IncReg (z.adr)
	END MoveBlock;

	PROCEDURE Move (VAR z, x: Item); (* z := x, where the size of x is byte, word or dword *)
	BEGIN
		IF z.mode = VarPar THEN
			loadAdr (z); z.mode := RegRel
		ELSE CompleteSL (z)
		END;
		load (x);
		GenStore (store, z, x)
	END Move;

	PROCEDURE SYSmove* (VAR z, x, nofBytes: Item); (* z := SYSTEM.MOVE (x, y) *)
	BEGIN

		ASSERT ((z.typ.form IN {LInt, Pointer}) & (x.typ.form IN {LInt, Pointer}));

		IF x.mode # Reg THEN
			load (x); OPL.Instr [x.adr].hint := OPL.useESI
		ELSIF OPL.Instr [x.adr].hint = OPL.noHint THEN OPL.Instr [x.adr].hint := OPL.tryESI
		END;
		IF z.mode # Reg THEN
			load (z); OPL.Instr [z.adr].hint := OPL.useEDI
		ELSIF OPL.Instr [z.adr].hint = OPL.noHint THEN OPL.Instr [z.adr].hint := OPL.tryEDI
		END;
		IF (nofBytes.typ.form # LInt) & (nofBytes.mode # Con) THEN Convert (nofBytes, LInt);
		ELSE (* !!later if const then no load necessary *)
			nofBytes.typ := OPT.linttyp; load (nofBytes)
		END;
		ASSERT (nofBytes.adr >= 0);
		OPL.Instr [nofBytes.adr].hint := OPL.useECX;
		MoveBlock (z, x, nofBytes, OPO.Bit8)
	END SYSmove;
	
	PROCEDURE Copy* (VAR z, x: Item);	(* COPY (x, z) *)
		VAR 
			zLen, xLen, zLen0, xLen0, char0X, len, z0, x0, t: Item;
			Lfix, L: Label;
	BEGIN
		MakeCon (char0X, OPT.chartyp, 0);
		Length (zLen, z); Length (xLen, x);
		IF (zLen.mode = Con) & (xLen.mode = Con) THEN
			IF zLen.adr >= xLen.adr THEN MoveBlock (z, x, xLen, OPO.Bit8)
			ELSE
				DEC (zLen.adr); (* last char is always 0X *)
				MoveBlock (z, x, zLen, OPO.Bit8);
				t.adr := z.adr; t.mode := RegRel; t.offs := 0; t.inx := none; t.typ := OPT.chartyp; t.node := NIL;
				Move (t, char0X) (* write 0X at the end of z *)
			END
		ELSE 
			(* pre-load the addresses (it will be done only once and will free some regs!!) *)

			IF x.mode#Reg THEN loadAdr (x) ELSE x0:=x; MakeCon(len, OPT.linttyp, 0); Add(x, x0, len, LInt) END;

			OPL.Instr [x.adr].hint := OPL.tryESI;
			loadAdr (z); OPL.Instr [z.adr].hint := OPL.tryEDI;
			IF zLen.mode = Con THEN 
				xLen0 := xLen;
				IF xLen.typ.form # LInt THEN Convert (xLen0, LInt)
				ELSE load (xLen0)
				END;
				OPL.Instr [xLen0.adr].hint := OPL.tryECX;
				GenFlags (cmp, xLen0, zLen);
				Lfix := -2-pc;
				Gen1 (jg, Nil, NIL)
			ELSE
				zLen0 := zLen;
				IF zLen0.typ.form # LInt THEN Convert (zLen0, LInt)
				ELSE load (zLen0)
				END;
				OPL.Instr [zLen0.adr].hint := OPL.tryECX;
				xLen0 := xLen;
				IF xLen0.mode # Con THEN
					IF xLen0.typ.form # LInt THEN Convert (xLen0, LInt)
					ELSE load (xLen0)
					END
				END;
				GenFlags (cmp, zLen0, xLen0);
				Lfix := -2-pc;
				Gen1 (jl, Nil, NIL)
			END;
			(* first case: |src| <= |trg|: copy all *)
			z0 := z; x0 := x; MoveBlock (z0, x0, xLen, OPO.Bit8);
			L := -2-pc; Gen1 (jmp, Nil, NIL);
			FixLink (Lfix);
			(* second case: |src| > |trg|: copy |trg|-1 bytes *)
			IF zLen.mode = Con THEN DEC (zLen.adr)
			ELSE
				MakeCon (len, OPT.linttyp, 1);
				load (zLen); OPL.Instr [zLen.adr].hint := OPL.useECX;
				t := zLen; Sub (zLen, t, len, LInt)
			END;
			MoveBlock (z, x, zLen, OPO.Bit8);
			t.mode := RegRel; t.adr := z.adr; t.offs := 0; t.inx := none; t.typ := OPT.chartyp; t.node := NIL;
			Move (t, char0X); (* last char is 0X *)
			FixLink (L)
		END 
	END Copy;


	PROCEDURE GenCopyIntpt(nr: INTEGER);
	BEGIN
		OPM.err(-311);
		Gen1 (intpt, nr, NIL)
	END GenCopyIntpt;
	
	PROCEDURE CheckPtrToArray(typ: OPT.Struct): BOOLEAN;	
		VAR link: OPT.Object;
	BEGIN
		IF ~initarr THEN RETURN FALSE
		ELSIF typ.comp=Record THEN
			WHILE typ#NIL DO
				link:=typ.link;
				WHILE link#NIL DO
					IF CheckPtrToArray(link.typ) THEN RETURN TRUE END;
					link:=link.link
				END;
				typ:=typ.BaseTyp
			END;
		ELSIF typ.comp IN {Array, SDynArr, DynArr} THEN
			WHILE typ.comp IN {Array, SDynArr, DynArr} DO typ:=typ.BaseTyp END; RETURN CheckPtrToArray(typ)
		ELSIF typ.form=Pointer THEN 
			RETURN (typ.BaseTyp.comp IN {Array, SDynArr, DynArr}) & typ.init
		END;
		RETURN FALSE
	END CheckPtrToArray;
	
	PROCEDURE ^UndefBaseTypSize(VAR sizeItem: Item; VAR typ: OPT.Struct; VAR size: LONGINT; VAR done: BOOLEAN);
	
	PROCEDURE CopyDynArr(VAR x: Item);
		VAR id, tag, size, basesize, t0: Item; typ, btyp: OPT.Struct; sz: LONGINT; done: BOOLEAN;
	BEGIN
		typ:=x.typ;
		IF typ.comp=Record THEN
			MakeCon(id, OPT.linttyp, 2); MakeCon(size, OPT.linttyp, 0); GetTdAdr(typ, tag); load(tag)
		ELSE
			btyp:=typ; WHILE btyp.comp IN {Array, SDynArr} DO btyp:=btyp.BaseTyp END;
			IF typ.extlev=sdynamic THEN
				UndefBaseTypSize(size, typ, sz, done);
				IF sz>1 THEN MakeCon(basesize, OPT.linttyp, sz); t0:=size; Mul(size, t0, basesize, LInt) 
				ELSE MakeCon(size, OPT.linttyp, 0)
				END
			ELSE
				MakeCon (size, OPT.linttyp, typ.size)
			END;
			load(size);
			IF btyp.comp=Record THEN
				MakeCon(id, OPT.linttyp, 0); GetTdAdr(btyp, tag); load(tag);
			ELSE
				MakeCon(id, OPT.linttyp, 1); MakeCon(tag, OPT.linttyp, 0)
			END
		END;

		GenPush (id);
		IF (x.mode = RegRel) & (x.adr = ESP) THEN INC(x.offs, 4) END;
		loadAdr(x); GenPush (x);		(* adr *)
		GenPush (size);
		GenPush (tag);
		GenCall (xcall, OPL.CopyArrLinkIndex * 10000H + OPL.CopyArrEntryNr, 16, NIL);
		OPM.err(-311)
	END CopyDynArr;
	
	PROCEDURE Step(VAR size: LONGINT; VAR step: SHORTINT);
	BEGIN
		CASE size MOD 4 OF
		| 0: size:=size DIV 4; step:=OPO.Bit32
		| 2: size:=size DIV 2; step:=OPO.Bit16
		ELSE step:=OPO.Bit8
		END
	END Step;


	PROCEDURE Assign* (VAR z, x: Item);	(* z  := x *) 
		VAR 
			zform, xform  , step  : SHORTINT; 
			temp, zero  , sizeItem, t0  : Item;
			proc: OPT.Object;  size: LONGINT; done: BOOLEAN; 
	BEGIN
		zform := z.typ.form; xform := x.typ.form;
		IF (zform IN {Int, LInt, Real, LReal}) & (zform # xform) THEN Convert (x, zform) END;
		CASE zform OF
			Bool:
				IF x.mode = Coc THEN
					temp := x; MoveCoc (x, temp) 
				ELSE load (x) 
				END;
				IF z.mode = VarPar THEN
					loadAdr (z); z.mode := RegRel;
				ELSE CompleteSL (z) 
				END;
				GenStore (store, z, x)
		  | Byte, Char, SInt, Set, Int, LInt:
				Move (z, x)
		  | Real:
				loadf (x);
				IF z.mode = VarPar THEN
					loadAdr (z); z.mode := RegRel
				ELSE CompleteSL (z) 
				END;
				GenStore (fstore, z, x)
		  | LReal:
				loadf (x);
				IF z.mode = VarPar THEN
					loadAdr (z); z.mode := RegRel
				ELSE CompleteSL (z) 
				END;
				GenStore (fstore, z, x)
		  | Pointer:
				IF xform = NilTyp THEN
					MakeCon (zero, OPT.linttyp, nil);
					load (zero);
					IF z.mode = VarPar THEN
						loadAdr (z); z.mode := RegRel
					ELSE CompleteSL (z) 
					END;
					GenStore (store, z, zero);
				ELSE
					load (x);
					IF z.mode = VarPar THEN
						loadAdr (z); z.mode := RegRel
					ELSE CompleteSL (z) 
					END;
					 temp:=z; 
					GenStore (store, z, x);
					 IF (z.typ.BaseTyp.comp IN {Array, SDynArr, DynArr}) & initarr & z.typ.init THEN CopyDynArr(temp) END 
				END
		  | ProcTyp:
				IF (z.typ = x.typ) OR (xform = NilTyp) THEN (* procedure variable assignment *)
					IF xform = NilTyp THEN
						MakeCon (x, OPT.linttyp, nil)
					END;
					Move (z, x)
				ELSE (* procedure assignment *)
					proc := x.node.obj;
					IF x.mnolev = 0 THEN (* local procedure assignment *)
						GenLoadProc (ldProc, x, proc.adr MOD 10000H, x.node)
					ELSE
						GenLoadProc (ldXProc, x, proc.adr DIV 10000H, x.node)
					END;
					Move (z, x)
				END
		  | Comp:

				ASSERT ((z.typ.comp=Record) OR ((z.typ.comp IN {Array, SDynArr}) & (z.typ.extlev IN {static, sdynamic})));	
				IF x.typ.form = String THEN
					Copy(z, x)
				ELSE
					IF (z.typ.comp IN {Array, SDynArr}) & (z.typ.extlev=sdynamic) THEN
						UndefBaseTypSize(sizeItem, z.typ, size, done); Step(size, step);
						IF size>1 THEN
							MakeCon(temp, OPT.linttyp, size); t0:=sizeItem; Mul(sizeItem, t0, temp, LInt)
						END;
						temp:=z; MoveBlock (z, x, sizeItem, step)
					ELSIF x.typ.size#4 THEN
						MakeCon (sizeItem, OPT.linttyp, z.typ.size); step:=OPO.Bit8;	(* optimize later in MoveBlock *)
						temp:=z; MoveBlock (z, x, sizeItem, step)
					ELSE temp:=z; Move(z, x)
					END;
					IF CheckPtrToArray(z.typ) THEN CopyDynArr(temp) END
				END

		ELSE HALT (BUG)
		END
	END Assign;

	PROCEDURE IncDec* (VAR z, x: Item; increment: BOOLEAN); (* INC / DEC (z, x) *)
		VAR z0, temp: Item;
	BEGIN
		z0 := z; load (z0); temp := z0;
		IF increment THEN Add (z0, temp, x, z.typ.form)
		ELSE Sub (z0, temp, x, z.typ.form)
		END;
		Assign (z, z0)
	END IncDec;

	PROCEDURE MulDim* (VAR nofelem, len: Item); (* nofelem := nofelem * len *)
		VAR t: Item;
	BEGIN
		IF (nofelem.mode = Con) & (len.mode = Con) THEN nofelem.adr := nofelem.adr * len.adr
		ELSE
			t := nofelem; Mul (nofelem, t, len, LInt)
		END
	END MulDim;

	PROCEDURE PushLen* (VAR z: Item); (* push length z -> NEW (dynArr, dim0, dim1,... ) *)
	BEGIN
		IF z.mode # Con THEN
			IF  z.typ.form # LInt THEN  IF z.mode=Var THEN load(z) END;  Convert (z, LInt)
			ELSE load (z)
			END
		END;
		GenPush (z)
	END PushLen;


	PROCEDURE PopLenLow* (VAR block: Item);
	(* pop lower bound and length and store it to the dynamic array -> used for NEW (dynArr, dim0, dim1, ...) *)
		VAR reg: Item;
	BEGIN
		reg.typ := OPT.linttyp; (* reg.node := NIL is done in GenPop *)
		GenPop (reg);
		GenStore (store, block, reg);
		reg.typ := OPT.linttyp; INC(block.offs, 4);
		GenPop (reg);
		GenStore (store, block, reg)
	END PopLenLow;


	PROCEDURE NewSys* (VAR z, x: Item); (* SYSTEM.NEW (z, x) *)
			
	BEGIN
		IF z.mode # Reg THEN loadAdr (z) END;
		GenPush (z);
		IF x.typ.form IN {SInt, Int} THEN
			IF x.mode = Con THEN x.typ := OPT.linttyp
			ELSE Convert(x, LInt)  (* << mh 30.8.94 *)
			END
		END;
		load (x); GenPush (x); 
		GenCall (xcall, OPL.NewSysLinkIndex * 10000H + OPL.NewSysEntryNr, 8, NIL);
		
	END NewSys;


	PROCEDURE MakeVar(VAR var: Item; obj: OPT.Object);
	BEGIN
		ASSERT(obj^.mode=Var);
		var.typ:=obj^.typ; var.inx:=OPL.none; var.node:=NIL; var.mnolev:=obj^.mnolev;
		var.mode:=Var; var.offs:=0; var.adr:=obj^.linkadr
	END MakeVar;

	PROCEDURE UndefBaseTypSize (VAR sizeItem: Item; VAR typ: OPT.Struct; VAR size: LONGINT; VAR done: BOOLEAN);
		VAR len, t: Item;
	BEGIN
		IF typ.extlev=sdynamic THEN
			UndefBaseTypSize(sizeItem, typ.BaseTyp, size, done);
			IF typ.link#NIL THEN
				IF done THEN SDynArrLen(len, typ.link); t:=sizeItem; Mul(sizeItem, t, len, LInt)
				ELSE SDynArrLen(sizeItem, typ.link); done:=TRUE
				END
			ELSE size:=size*typ.n
			END
		ELSE 
			size:=typ.size
		END
	END UndefBaseTypSize;
	
	PROCEDURE SDynArrSize*(VAR z: Item; typ: OPT.Struct);
		VAR t, t1: Item; size: LONGINT; done: BOOLEAN;
	BEGIN
		UndefBaseTypSize(z, typ, size, done);
		IF size>1 THEN MakeCon(t, OPT.linttyp, size); t1:=z; Mul(z, t1, t, LInt) END;
	END SDynArrSize;
	
	PROCEDURE PushLowerBound*(typ: OPT.Struct);
		VAR lb: Item;
	BEGIN
		IF typ.lbound#NIL THEN MakeVar(lb, typ.lbound); load(lb)  ELSE MakeCon(lb, OPT.linttyp, typ.lb) END;
		GenPush(lb)
	END PushLowerBound;
	
	PROCEDURE RetListSize(VAR sizeItem: Item; VAR staticsize: LONGINT; n: OPT.Node);
		VAR size: LONGINT; done: BOOLEAN; t0, t1, t2: Item;
	BEGIN
		WHILE n.class=Nret DO
			IF (n.obj.typ.comp IN {Array, SDynArr}) & (n.obj.typ.extlev=sdynamic) THEN
				size:=0; done:=FALSE; UndefBaseTypSize(t1, n.obj.typ, size, done);
				IF size # 1 THEN MakeCon (t0, OPT.linttyp, size); t2:=t1; Mul (t1, t2, t0, LInt) ELSE load(t1) END;
				IF size MOD 4 # 0 THEN
					MakeCon(t0, OPT.linttyp, 3); t2.node:=NIL; Gen3(add, t2, t1, t0); t2.typ:=OPT.linttyp;
					t0.adr:=-4; Gen3(and, t1, t2, t0);
				END;
				IF sizeItem.mode=0 THEN sizeItem:=t1 ELSE t0:=sizeItem; Add(sizeItem, t0, t1, LInt) END
			ELSE INC(staticsize, n.obj.typ.size); INC(staticsize, (-staticsize) MOD 4)
			END;
			n:=n.link;
		END
	END RetListSize;

	PROCEDURE ReserveRetArea*(VAR sizeItem: Item; n: OPT.Node);
		VAR size: LONGINT; t0, t1: Item; 
	BEGIN
		size:=0; RetListSize(sizeItem, size, n);
		IF sizeItem.mode=0 THEN MakeCon(sizeItem, OPT.linttyp, size)
		ELSIF size>0 THEN MakeCon(t0, OPT.linttyp, size); t1:=sizeItem; Add(sizeItem, t1, t0, LInt)
		END;
		IF sizeItem.mode=Con THEN t0:=sizeItem; t1:=Stack; Sub(t1, Stack, t0, LInt);
		ELSE t0:=sizeItem; t1:=Stack; Sub(t1, Stack, t0, LInt); t0:=sizeItem; GenPush(t0)
		END
	END ReserveRetArea;
	
	PROCEDURE ClearRetArea*(sizeItem: Item);
		VAR t0, t1: Item;
	BEGIN
		IF sizeItem.mode=Con THEN
			t1:=Stack; t0:=sizeItem; Add(t1, Stack, t0, LInt)
		ELSIF sizeItem.mode#0 THEN 
			t0.typ:=OPT.linttyp; GenPop(t0);
			t1:=Stack; Gen3(add, t1, Stack, t0)
		END
	END ClearRetArea;
		
	PROCEDURE NewArray* (VAR z, nofelem: Item; nofdim: LONGINT; typ: OPT.Struct);
	(* NEW (dynArr, dim0, dim1, ...) *) (* dimUsed always !!! *)
		VAR
			cons, tdesc, t: Item; depth: LONGINT;
	BEGIN
		IF (typ.form # Pointer) & (typ.comp # Record) THEN (* simple type -> use SYSTEM.NEW (...) *)
			IF nofelem.mode = Con THEN
				nofelem.adr := nofelem.adr * typ.size 
			ELSE
				MakeCon (cons, OPT.linttyp, typ.size);
				t := nofelem; Mul (nofelem, t, cons, LInt);
			END;
			loadAdr(z); GenPush(z);
			t := z;
			GenPush(t);
			IF nofelem.mode=Con THEN
				IF nofelem.typ.form IN {SInt, Int} THEN nofelem.typ:=OPT.linttyp END
			ELSE
				IF nofelem.typ.form IN {SInt, Int} THEN Convert(nofelem, LInt) END;
				load(nofelem)
			END;
			GenPush(nofelem);
			MakeCon(cons, OPT.linttyp, PtrToArrOffs + 8 + 8*nofdim);  GenPush(cons);
			GenCall (xcall, OPL.NewSysArrLinkIndex * 10000H + OPL.NewSysArrEntryNr, 12, NIL)
		ELSE (* BaseTyp contains pointers *)
			loadAdr(z); GenPush(z); 
			GenPush(z);
			IF typ.form = Pointer THEN
				IF typ.init THEN MakeCon (cons, OPT.linttyp, OPM.nilval+2) ELSE MakeCon (cons, OPT.linttyp, OPM.nilval) END;
				GenPush (cons)
			ELSE
				GetTdAdr (typ, tdesc);
				load (tdesc);
				GenPush (tdesc)
			END;
			IF nofelem.mode # Con THEN load (nofelem) END; GenPush (nofelem);
			MakeCon (cons, OPT.linttyp, nofdim); GenPush (cons);
			GenCall (xcall, OPL.NewArrayLinkIndex * 10000H + OPL.NewArrayEntryNr, 16, NIL);
		END;
		GenPop (z); z.mode := RegRel; z.offs := 0; load (z);
		z.mode := RegRel; z.inx := none; z.typ := OPT.sysptrtyp; z.offs := PtrToArrOffs
	END NewArray;
	
	PROCEDURE ^ Call* (VAR x: Item; proc: OPT.Object; node: OPT.Node);
	
	PROCEDURE NewRec* (VAR z: Item; typ: OPT.Struct); (* NEW (record), (*not NEW (POINTER TO ARRAY n0, n1,... OF...)*) *)
		VAR
			tag,  cons, t: Item; 
			depth, tagId: LONGINT;
			
	BEGIN
		ASSERT(typ.comp=Record);
		loadAdr (z); GenPush (z);
		GetTdAdr (typ, tag);
		load (tag); 
		GenPush (tag);
		GenCall (xcall, OPL.NewLinkIndex * 10000H + OPL.NewEntryNr, 8, NIL);
	END NewRec;


	PROCEDURE PrepareObj*(VAR z: Item; typ: OPT.Struct);		(* Active only *)
		VAR adr, tag, con: Item;
	BEGIN
		(* add 64 to the address of the record to skip the process data *)
			adr := z; load(adr); adr.typ := OPT.linttyp;
			MakeCon(con, OPT.linttyp, 64);
			Gen3(add, adr, adr, con);
			IF z.mode = VarPar THEN
				loadAdr(z);
				z.mode := RegRel; z.offs := 0; z.inx := none
			END;
			GenStore(store, z, adr);								(* store the new address *)
		(* write the tag addr OR 10H to -4[adr] *)
			GetTdAdr(typ, tag); load(tag); tag.typ := OPT.linttyp;
			MakeCon(con, OPT.linttyp, ActiveTag);
			Gen3(or, tag, tag, con);
			adr.mode := RegRel; adr.offs := -4; adr.inx := none;
			GenStore(store, adr, tag)
	END PrepareObj;
	
	PROCEDURE CallRecBody*(VAR self, body: Item; typ: OPT.Struct);		(* Active only *)
		VAR con: Item;
			type: LONGINT;
			tag, mask: Item;
	BEGIN
			(* no concurrency support *)
			(* the type is statically known!! *)
			GetTdAdr (typ, con); load (con); GenPush (con);
			load(self); GenPush(self);
			body.node.left := body.node; 	(* tell lies to the code generator *)
			Call(body, typ.strobj, body.node)

	END CallRecBody;

	PROCEDURE PushDynArrLen (formalParam: OPT.Object; VAR actualParam: Item);
		(* push dynamic array length *)
		VAR atyp, ftyp: OPT.Struct; 
			len, sizeItem, arr, cons  , lb  : Item;
			descOffs, descReg, size: LONGINT;
	BEGIN
		atyp := actualParam.typ; ftyp := formalParam.typ;
		descOffs := actualParam.descOffs; descReg := actualParam.descReg;
		WHILE  ftyp.extlev=dynamic  DO
			IF ftyp.BaseTyp = OPT.bytetyp THEN (* ARRAY OF SYSTEM.BYTE -> total size measured in bytes *)
				sizeItem.typ := OPT.linttyp; sizeItem.mnolev := atyp.mno; sizeItem.inx := none; sizeItem.node := NIL;

				IF (atyp.comp IN {Array, SDynArr, DynArr}) & (atyp.extlev IN {dynamic, sdynamic}) THEN

					arr.mode := RegRel; arr.typ := atyp; arr.descReg := descReg; arr.descOffs := descOffs; 
					arr.inx := none; arr.node := NIL; arr.mnolev := actualParam.mnolev; (* arr.adr, arr.offs are not used *)
					DynArrSize (sizeItem, arr, size);
					IF size # 1 THEN
						MakeCon (cons, OPT.linttyp, size);
						len := sizeItem; Mul (sizeItem, len, cons, LInt)
					END;
					ASSERT (sizeItem.mode # Con);
					load (sizeItem);
				ELSIF (atyp.comp = Record) & (actualParam.mode = VarPar) THEN (* the size of the Par can be different from the static size *)
					len := actualParam;
					CompleteSL (len);
					IF len.mode IN {Var, VarPar} THEN
						INC (len.adr, 4); len.mode := Var  (* type descriptor is on the stack (hidden parameter) *)
					ELSE
						ASSERT (len.mode = RegRel);
						INC (len.offs, 4)
					END;
					DeRef (len); load (len);
					sizeItem := len
				ELSE
					MakeCon (sizeItem, OPT.linttyp, atyp.size)
				END;
				GenPush (sizeItem)

			ELSIF ftyp.comp=DynArr THEN (* push len *)
				IF atyp.comp = DynArr THEN
					len.typ := OPT.linttyp; len.inx := none; len.node := NIL; (* >> mh/nm 30.8.94 *)
					len.mnolev := actualParam.mnolev;
					IF descReg = FP THEN (* descriptor is on the stack *)
						len.mode := Var; len.offs := 0; len.adr := 4*(atyp.n+1) + descOffs;
						CompleteSL(len)
					ELSE (* descriptor is already loaded *)
						len.mode := RegRel; len.adr := descReg; len.offs := atyp.offset + descOffs;
					END; (* << mh/nm 30.8.94 *)
					load (len);
				ELSIF atyp.form = String THEN (* String *)
					MakeCon (len, OPT.linttyp, actualParam.offs) (* actualParam.offs = Length (String) *)
				ELSE (* Array *)
					ASSERT (atyp.comp IN {Array, SDynArr});
					IF atyp.comp=Array THEN MakeCon (len, OPT.linttyp, atyp.n)
					ELSE SDynArrLen(len, atyp.link); CompleteSL(len); load(len)
					END
				END;
				IF ftyp.lb=MAX(LONGINT) THEN
					IF atyp.lb=MAX(LONGINT) THEN DynLow(actualParam, lb, atyp); load(lb)
					ELSIF atyp.lbound#NIL THEN MakeVar(lb, atyp.lbound); load(lb)
					ELSE MakeCon(lb, OPT.linttyp, atyp.lb)
					END;
					GenPush(lb)
				END;
				GenPush (len)

			END;
			ftyp := ftyp.BaseTyp; atyp := atyp.BaseTyp (* next dimension *)
		END
	END PushDynArrLen;
	

	PROCEDURE PushComp(fp: OPT.Object; VAR ap: Item; apwCall: BOOLEAN);
		VAR sizeItem, t: Item; 
	BEGIN
		IF ap.typ.size#4 THEN
			MakeCon (sizeItem, OPT.linttyp, fp.typ.size); t:=Stack; Sub(t, Stack, sizeItem, LInt);
			MakeCon (sizeItem, OPT.linttyp, fp.typ.size); t:=Stack; MoveBlock (t, ap, sizeItem, OPO.Bit8)
		ELSE
			load(ap); GenPush(ap)
		END;
		IF apwCall & CheckPtrToArray(ap.typ) THEN
			t:=Stack; t.typ:=ap.typ; t.mode:=RegRel; t.offs:=0;
			CopyDynArr(t)
		END
	END PushComp;
	
	PROCEDURE ParRecord (fp: OPT.Object; VAR ap: Item; apIsDeref: BOOLEAN; apwCall: BOOLEAN);

		VAR t, tag: Item;
	BEGIN
		IF ap.mode = VarPar THEN
			IF fp.mode = VarPar THEN (* push tag too -> tag is on the stack as a hidden parameter *)
				t.mode := Var; t.adr := ap.adr + 4; t.typ := OPT.sysptrtyp; t.node := NIL; 
				t.inx := none; t.offs := 0; t.mnolev := ap.mnolev;
				load (t); GenPush (t);

				IF ap.mode#Reg THEN loadAdr(ap) END; GenPush(ap)
			ELSE PushComp(fp, ap, apwCall)
			END

		ELSE
			IF fp.mode = VarPar THEN (* push {Var, Abs} record *)
				IF apIsDeref THEN (* get type descriptor of dynamic type *)
					ASSERT((ap.mode = RegRel) & (ap.offs = 0));
					tag.mode := RegRel; tag.scale := noScale; tag.typ := OPT.sysptrtyp;
					tag.offs := -4; tag.adr := ap.adr; tag.inx := none; tag.descReg := none
				ELSE
					GetTdAdr(ap.typ, tag); (* get typedescriptor address of static type *)
				END;
				load(tag); GenPush(tag);

				IF ap.mode#Reg THEN loadAdr(ap) END; GenPush(ap)
			ELSE PushComp(fp, ap, apwCall)
			END

		END
	END ParRecord;


	PROCEDURE Parameter* (VAR ap: Item; fp: OPT.Object; apIsDeref, apwCall: BOOLEAN);
		VAR form, apMode: SHORTINT; temp, cons, stack, tag: Item;
			proc: OPT.Object; apTyp, fpTyp: OPT.Struct;
	BEGIN
		fpTyp := fp.typ; apTyp := ap.typ;
		IF apwCall THEN
			IF (ap.typ.form=Pointer) & (ap.typ.BaseTyp.comp IN {Array, SDynArr, DynArr}) & initarr THEN
				ASSERT(ap.mode=Reg); GenPush(ap);
				temp:=Stack; temp.offs:=0; temp.inx:=none; temp.mode:=RegRel; temp.typ:=OPT.linttyp;
				CopyDynArr(temp)
			ELSIF (fp.mode=Var)& ~(fpTyp.form IN {String,Comp}) THEN apwCall:=FALSE
			END
		END;
		IF (fp.mode = VarPar) OR (fpTyp.form IN {String,Comp}) THEN
			(* push actual parameter (ap) as Var-Parameter *)
			form := fpTyp.comp;
			IF form = Record THEN ParRecord (fp, ap, apIsDeref, apwCall)
			ELSIF (fp.mode=Var) & (fpTyp.extlev=static) THEN
				PushComp(fp, ap, apwCall);
			ELSIF fpTyp.extlev=dynamic THEN	(* form IN {Array, DynArr} *)
				PushDynArrLen (fp, ap); 
				IF ap.mode#Reg THEN loadAdr (ap) END;
				GenPush (ap)
			ELSE
				apMode := ap.mode;
				IF apTyp.form = String THEN (* constant *) ap.node := NIL END;
				IF ap.mode#Reg THEN loadAdr (ap) END;GenPush (ap);

				IF (fpTyp = OPT.sysptrtyp) & (apTyp # OPT.sysptrtyp) THEN
					(* pass ap static typ to enable run time tests -> hack *)
					GetTdAdr (apTyp.BaseTyp, tag);
					ap.mode := RegRel; Assign (ap, tag);
				ELSIF (fpTyp = OPT.sysptrtyp) & (apTyp = OPT.sysptrtyp) & (apMode # VarPar) THEN
					(* pass nil to disable runtime tests -> hack *)
					MakeCon (cons, OPT.linttyp, nil);
					ap.mode := RegRel; Assign (ap, cons)
				END
			END
		ELSE
			ASSERT (ap.mode IN {Abs, Var, VarPar, Con, Reg, RegRel, Coc, XProc, LProc});
			form := apTyp.form;
			IF (apTyp # fpTyp) & ~(ap.mode IN {XProc, LProc}) & ~(form  IN {Pointer, NilTyp, NoTyp}) THEN
				(* convert actual parameter *)
				Convert (ap, fp.typ.form); form := ap.typ.form
			END;
			IF (form IN realSet) & (ap.mode = Reg) THEN (* ap was converted *)
				IF fp.typ.form = Real THEN MakeCon (cons, OPT.linttyp, 4)
				ELSE MakeCon (cons, OPT.linttyp, 8)
				END;
				stack := Stack;
				Gen3 (sub, stack, stack, cons);
				stack.mode := RegRel; stack.offs := 0; stack.inx := none; stack.typ := fp.typ; (* OPT.lrltyp; *)
				GenStore (fstore, stack, ap)
			ELSE
				IF ap.mode IN {XProc, LProc} THEN
					proc := ap.node.obj;
					IF ap.mnolev = 0 THEN (* push global procedure *)
						GenLoadProc (ldProc, ap, proc.adr MOD 10000H, ap.node)
					ELSE (* push external procedure *)
						GenLoadProc (ldXProc, ap, proc.adr DIV 10000H, ap.node)
					END
				ELSIF form = LReal THEN (* push higher 4 bytes -> lower bytes will be pushed later *)
					temp := ap; temp.typ := OPT.linttyp;
					IF temp.mode = VarPar THEN loadAdr(temp); temp.mode := RegRel; temp.offs := 0 END; (* << mb 15.2.94 *)
					IF temp.mode = RegRel THEN INC (temp.offs, 4)
					ELSE INC (temp.adr, 4)
					END;
					load (temp); GenPush (temp)
				ELSIF ap.mode = Coc THEN
					temp := ap; MoveCoc (ap, temp)
				END;

				IF ~apwCall THEN

					IF ap.mode # Con THEN
						IF ap.typ.form IN realSet THEN ap.typ := OPT.linttyp END;
						load (ap)
					END;
					GenPush (ap)

				END

			END
		END
	END Parameter;
	
	PROCEDURE Call* (VAR x: Item; proc: OPT.Object; node: OPT.Node);
		VAR n: INTEGER; sl: Item;
			param: OPT.Object; tag, mask: Item;
			

				
	
	BEGIN
		IF (x.mode IN {LProc, CProc}) OR ((x.mode IN {XProc}) & (x.mnolev >= 0)) THEN (* local procedure *)	(* was active only *)
			IF slNeeded IN proc.conval.setval THEN
				n := level - x.mnolev;
				sl.mode := Var; sl.typ := OPT.linttyp; sl.mnolev := level; sl.inx := none; sl.node := NIL;
				IF n = 0 THEN
					sl.mode := Reg; sl.adr := FP;
					GenPush(sl)
				ELSIF n = 1 THEN
					sl.adr := StaticLinkAdr;
					load(sl); GenPush(sl)
				ELSE
					sl.adr := StaticLinkAdr;
					load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
					WHILE n > 2 DO
						load (sl); sl.mode := RegRel; sl.offs := StaticLinkAdr;
						DEC (n)
					END;
					load(sl);
					GenPush(sl)
				END
			END;
			IF (x.mode # CProc) & (proc.linkadr < 0) THEN (* forward declared procedure -> fixup chain *)
				GenCall (call, proc.linkadr, proc.conval.intval - 4, node);
				proc.linkadr := -2 - (pc - 1);
				
			ELSE
				GenCall (call, proc.linkadr, proc.conval.intval - 4, node);
				
			END
		ELSIF x.mode = XProc THEN (* external procedure *)
			GenCall (xcall, x.adr, proc.conval.intval - 4, node);
			
		ELSIF x.mode IN {TProc, Typ} THEN (* type bound procedure *)	(* was active only, but seems safe *)
			IF node.left.subcl = 1 THEN (* super call *)
				IF node.right.obj.typ.form = Pointer THEN GetTdAdr (node.right.obj.typ.BaseTyp.BaseTyp, tag)
				ELSE GetTdAdr (node.right.obj.typ.BaseTyp, tag)
				END;
				load(tag)
			ELSE
				IF node.obj.mode = VarPar (* node.left.obj.mode = VarPar *) THEN	(* << mb 21.2.94 *)
					tag.mode := RegRel; tag.typ := OPT.sysptrtyp; tag.node := NIL;
					tag.adr := ESP; tag.offs := 4  (*0*)(* obj.conval.intval - 12 (* 8 *) *); tag.inx := none; 
				ELSE (* pointer *)
					tag.mode := RegRel; tag.typ := OPT.sysptrtyp; tag.node := NIL;
					tag.adr := ESP; tag.offs := 0 (* obj.conval.intval - 12 *); tag.inx := none;
					DeRef(tag); tag.mode := RegRel; tag.offs := -4
				END;
				DeRef(tag);

			END;
			x.adr := tag.adr; (* x.offs set by OPV.Designator *)
			x.mode := RegRel; x.typ := OPT.sysptrtyp; load (x);
			GenCall(callReg, x.adr, proc.conval.intval - 4, node);
			
		ELSE (* procedure variable *)
			ASSERT (x.typ.form = ProcTyp);
			load(x);
			param := x.typ.link; 
			IF param = NIL THEN GenCall(callReg, x.adr, 0, node) (* no parameter *)
			ELSE GenCall(callReg, x.adr, param.adr, node);
				
			END
		END
	END Call;
	
	PROCEDURE PopResult* (n: OPT.Node; VAR z: Item);
	BEGIN
		IF n # NIL THEN (* result into ST(0) or EAX *)
			z.typ := n.typ; z.mode := Reg; z.adr := pc;
			IF z.typ.form IN {Byte..LInt, Set, Pointer, ProcTyp} THEN
				GenPopReg (OPL.useEAX, z.typ.form)

			ELSIF z.typ.comp IN {Array, SDynArr, Record} THEN
				GenPopReg (OPL.useEAX, z.typ.form)

			ELSE (* z.typ.form IN realSet *)
				ASSERT (z.typ.form IN realSet);
				GenPopReg (OPL.useST, z.typ.form) (* top of stack contains result *)
			END
		ELSE
			GenPopReg (OPL.noHint, 0) (* no result *)
		END
	END PopResult;


	PROCEDURE AllocSDynArr*(VAR proc: OPT.Object);
		VAR locals: OPT.Object; t: OPT.Node; t0, x, sizeItem, shift, adj, len: Item; size:LONGINT; done: BOOLEAN;
	BEGIN
		t:=proc.code;
		WHILE t#NIL DO SDynArrLen(len, t.left.obj); GenDimTrap(len); t:=t.link END;
		locals:=proc.scope.scope;
		WHILE locals#NIL DO
			IF (locals.typ.comp IN {Array, SDynArr}) & (locals.typ.extlev=sdynamic) THEN
				size:=1; done:=FALSE; UndefBaseTypSize(sizeItem, locals.typ, size, done);
				IF size>1 THEN MakeCon(t0, OPT.linttyp, size); Mul(sizeItem, sizeItem, t0, LInt) END;
				IF sizeItem.mode=Var THEN load(sizeItem) END;
				MakeCon(adj, OPT.linttyp, 3); t0:=sizeItem; Gen3(add, sizeItem, t0, adj);
				MakeCon(shift, OPT.linttyp, 2); t0:=sizeItem; Gen3(sar, sizeItem, t0, shift);
				Gen0(clear); OPL.Instr[pc-1].src1:=sizeItem.adr;			
				x.mode := Var; x.typ := OPT.linttyp; x.adr := locals.linkadr; x.node :=  NIL; x.mnolev := locals.mnolev;
				t0 := Stack; Move (x, t0)
			END;
			locals:=locals.link
		END
	END AllocSDynArr;

	
	PROCEDURE Enter* (proc: OPT.Object; dataSize: LONGINT; node: OPT.Node);
		VAR 
			par: OPT.Object;  typ: OPT.Struct; done: BOOLEAN; 
			z, x, sizeItem, stackCorr, t0, t1, arr  , tag  : Item; 
			size: LONGINT; 
			moveSize: SHORTINT;
	BEGIN (* !!later due to a bug this procedure looks no longer very nice *)
		IF proc # NIL THEN 
			OPL.FixupLocalProcCall (proc); (* fixup local procedure calls and assign target pc to procedure *)
			par := proc.link
		ELSE par := NIL;
		END;
(*

*)
		Gen1 (enter, dataSize, node);
		WHILE par # NIL DO (* copy val parameter Record, Array and DynArr *)
			IF par.mode = Var THEN

				IF (par.typ.comp IN {Array, SDynArr, DynArr}) & (par.typ.extlev IN {dynamic, sdynamic}) THEN (* sdynamic & open array *)
					IF par.typ.extlev=dynamic THEN
						arr.mode := RegRel; arr.typ := par.typ; arr.descReg := FP; arr.descOffs := par.adr; 
						arr.mnolev := par.mnolev; arr.node := NIL;	(* arr.adr, arr.offs are not used *)
						DynArrSize (sizeItem, arr, size); (* get open array size *)
					ELSE
						UndefBaseTypSize(sizeItem, par.typ, size, done)
					END;

					stackCorr := sizeItem;
					IF size # 1 THEN
						MakeCon (t0, OPT.linttyp, size);
						t1 := stackCorr; Mul (stackCorr, t1, t0, LInt);
						IF size = 2 THEN 
							moveSize := OPO.Bit16; load (sizeItem)
						ELSIF size = 4 THEN 
							moveSize := OPO.Bit32; load (sizeItem)
						ELSE 
							moveSize (* size *):= OPO.Bit8; sizeItem := stackCorr
						END
					ELSE
						load (sizeItem); load (stackCorr);
						moveSize := OPO.Bit8
					END;
					IF size MOD 4 # 0 THEN (* align stack *)
						stackCorr.typ := OPT.linttyp;
						MakeCon (t0, OPT.linttyp, 3);
						t1.node := NIL;
						Gen3 (add, t1, stackCorr, t0); t1.typ := OPT.linttyp;
						t0.adr := -4;
						Gen3 (and, stackCorr, t1, t0)
					END;
					t0 := Stack; Gen3 (sub, z, t0, stackCorr); OPL.Instr [pc-1].hint := OPL.useESP;
					z.adr := ESP; z.typ := OPT.linttyp; z.node := NIL; z.mnolev := par.mnolev;
					x.mode := VarPar; x.typ := OPT.linttyp; x.adr := par.adr; x.node :=  NIL; x.mnolev := z.mnolev;
					t0 := z; t1 := x;
					MoveBlock (t0, t1, sizeItem, moveSize); (* copy array *)
					x.mode := Var;
					Move (x, z); (* stack pointer is the new array address *)

					IF CheckPtrToArray(par.typ) THEN
						t0.mode:=RegRel; t0.adr:=ESP; t0.offs:=0; t0.inx:=none; loadAdr(t0); OPL.Instr[t0.adr].hint:=OPL.useEAX;
						typ:=par.typ; WHILE typ.comp IN {Array, SDynArr, DynArr} DO typ:=typ.BaseTyp END;
						IF typ.comp=Record THEN
							GetTdAdr(typ, tag); load(tag); OPL.Instr[tag.adr].hint:=OPL.useECX;
							OPL.Instr[stackCorr.adr].hint:=OPL.useEBX;
							MakeCon(t1, OPT.linttyp, 0); load(t1); OPL.Instr[t1.adr].hint:=OPL.useEDX
						ELSE
							OPL.Instr[stackCorr.adr].hint:=OPL.useEBX;
							MakeCon(t1, OPT.linttyp, 1); load(t1); OPL.Instr[t1.adr].hint:=OPL.useEDX
						END;
						GenCopyIntpt(OPL.EnterCopyInt)
					END

				ELSIF (par.typ.comp IN {Array, Record}) & (par.typ.size > 0) THEN (* copy array, record *)

					IF CheckPtrToArray(par.typ) THEN
						z.mode := Var; z.typ := OPT.linttyp; z.node := NIL; z.adr := par.linkadr; z.mnolev := par.mnolev;
						loadAdr(z); OPL.Instr[z.adr].hint:=OPL.useEAX;
						IF par.typ.comp=Record THEN
							GetTdAdr(par.typ, tag); load(tag); OPL.Instr[tag.adr].hint:=OPL.useECX;
							MakeCon(t0, OPT.linttyp, 2)
						ELSE
							typ:=par.typ; WHILE typ.comp=Array DO typ:=typ.BaseTyp END;
							IF typ.comp=Record THEN
								GetTdAdr(typ, tag); load(tag); OPL.Instr[tag.adr].hint:=OPL.useECX;
								MakeCon (sizeItem, OPT.linttyp, par.typ.size); MakeCon(t0, OPT.linttyp, 0)
							ELSE
								MakeCon (sizeItem, OPT.linttyp, par.typ.size); MakeCon(t0, OPT.linttyp, 1)
							END;
							load(sizeItem); OPL.Instr[sizeItem.adr].hint:=OPL.useEBX
						END;
						load(t0); OPL.Instr[t0.adr].hint:=OPL.useEDX;
						GenCopyIntpt(OPL.EnterCopyInt)
					END
				ELSIF (par.typ.form=Pointer) & (par.typ.BaseTyp.comp IN {Array, SDynArr, DynArr}) & initarr  & par.typ.init THEN
					z.mode := Var; z.typ := OPT.linttyp; z.node := NIL; z.adr := par.linkadr; z.mnolev := par.mnolev;
					loadAdr(z); OPL.Instr[z.adr].hint:=OPL.useEAX;
					MakeCon (sizeItem, OPT.linttyp, par.typ.size); load(sizeItem); OPL.Instr[sizeItem.adr].hint:=OPL.useEBX;
					MakeCon(t0, OPT.linttyp, 1); load(t0); OPL.Instr[t0.adr].hint:=OPL.useEDX;
					GenCopyIntpt(OPL.EnterCopyInt)	

				END
			END;
			par := par.link
		END
	END Enter;


	PROCEDURE Return* (VAR res: Item; typ: OPT.Struct); (* RETURN res *)
		VAR t: Item; pReg: LONGINT; procform: SHORTINT;
	BEGIN
		procform:=typ.form;

		IF res.mode = Coc THEN
			t := res;
			IF (t.offs = Nil) & (t.inx = Nil) THEN
				MoveCoc (res, t); OPL.Instr [res.adr].hint := OPL.useEAX
			ELSE
				MoveCoc (res, t);
				ASSERT (OPL.Instr [pc-2].op = phi);
				pReg := OPL.Instr [pc-2].src1;
				OPL.Instr [pReg].hint := OPL.useEAX
			END
		ELSE
			IF res.typ.form = NoTyp THEN (* RETURN procedure *)
				IF res.mnolev = 0 THEN (* local procedure assignment *)
					GenLoadProc (ldProc, res, res.node.obj.adr MOD 10000H, res.node)
				ELSE
					GenLoadProc (ldXProc, res, res.node.obj.adr DIV 10000H, res.node)
				END;
				OPL.Instr [res.adr].hint := OPL.useEAX
			ELSIF (procform # res.typ.form) & (res.typ.form # NilTyp) THEN
				ASSERT (procform # Set);
				Convert (res, procform)
			END;
			IF res.typ.form IN realSet THEN loadf (res)

			ELSIF (((typ.comp=Array) & (typ.extlev=static)) OR (typ.comp=Record)) & (typ.size#4) THEN
				IF res.mode#Reg THEN loadAdr(res) END; OPL.Instr [res.adr].hint := OPL.useEAX
			ELSIF (typ.comp IN {Array, SDynArr}) & (typ.extlev=sdynamic) THEN
				IF res.mode#Reg THEN loadAdr(res) END; OPL.Instr [res.adr].hint := OPL.useEAX

			ELSE
				load (res);
				OPL.Instr [res.adr].hint := OPL.useEAX
			END
		END
	END Return;
	
	PROCEDURE Exit* (proc: OPT.Object);
	BEGIN
		IF proc # NIL THEN (* procedure *)
(*

*)
			Gen1 (leave, proc.conval.intval2, NIL);
			 Gen1 (ret, proc.conval.intval - 8, NIL) 
		ELSE (* from module *)
			Gen1 (leave, 0, NIL);
			Gen1 (ret, 0, NIL)
		END
	END Exit;

	PROCEDURE Lock*(self, excl: Item);		(* active only *)
		VAR z, con, lock, reg: Item; L1, L2: Label; ex: BOOLEAN;
	BEGIN

		Gen0(cli);
		ex := excl.adr # 0;
		(* load address of the record *)
		IF self.typ.comp = Record THEN loadAdr (self) ELSE (*pointer*) load (self) END;
		
	(* MOV Reg0, Self  <- self already loaded *)
	(* CMP 0[Reg0], 0 *)
		lock := self; lock.mode := RegRel; lock.offs := 0; lock.typ := OPT.linttyp;
		MakeCon (con, OPT.linttyp, 0);
		Cmp (z, lock, con, eql);
	(* JZ L1 *)
		L1 := Nil;
		Jcc (z, L1, NIL);
	(* Call Lock *)
		GenPush (self);
		GenPush (excl);	(* -> don't load (excl) because it's a boolean constant. This generates better code *)
		GenCall (xcall, OPL.LockIndex * 10000H + OPL.LockEntryNr, 4, NIL);
	(* JMP L2 *)
		L2 := Nil;
		Jmp (L2, NIL);
	(* L1: *)
		FixLink (L1);
	(* MOV WORD 18[Reg0], a *)
		lock := self; lock.mode := RegRel; lock.offs := 18; lock.typ := OPT.inttyp;
		IF ex THEN MakeCon (con, OPT.inttyp, 1) ELSE MakeCon (con, OPT.inttyp, -1) END;
		Assign (lock, con);
	(* MOV Reg1, Cur *)
		MakeCon (con, OPT.linttyp, -1); con.mode := Abs; con.inx := none;
		GenLoad (ld, reg, con); OPL.Instr[pc-1].abs := TRUE;
		reg.typ := OPT.linttyp;
	(* MOV 0[Reg0], Reg1 *)
		lock := self; lock.mode := RegRel; lock.offs := 0; lock.typ := OPT.linttyp;
		Assign (lock, reg);
	(* L2: *)
		FixLink (L2);
		Gen0(sti);

	END Lock;

	PROCEDURE Unlock*(self, excl: Item);		(* active only *)
		VAR z, con, lock, reg: Item; L1, L2, L3: Label;
	BEGIN

		Gen0(cli);
		(* push address of the record *)
		IF self.typ.comp = Record THEN loadAdr (self) ELSE (*pointer*) load (self) END;
	(* MOV Reg0, Self  <- self already loaded *)
	(* CMP WORD 18[Reg0], 0 *)
		lock := self; lock.mode := RegRel; lock.offs := 18; lock.typ := OPT.inttyp;
		MakeCon (con, OPT.inttyp, 0);
		Cmp (z, lock, con, eql);
	(* JNZ L1 *)
		L1 := Nil;
		Jncc (z, L1, NIL);
	(* Call Unlock *)
		GenPush (self);
		GenPush (excl);	(* -> don't load (excl) because it's a boolean constant. This generates better code *)
		GenCall (xcall, OPL.UnlockIndex * 10000H + OPL.UnlockEntryNr, 4, NIL);
	(* JMP L2 *)
		L2 := Nil;
		Jmp (L2, NIL);
	(* L1: *)
		FixLink (L1);
	(* MOV WORD 18[Reg0], 0 *)
		lock := self; lock.mode := RegRel; lock.offs := 18; lock.typ := OPT.inttyp;
		MakeCon (con, OPT.inttyp, 0);
		Assign (lock, con);
	(* MOV DWORD 0[Reg0], 0 *)
		lock := self; lock.mode := RegRel; lock.offs := 0; lock.typ := OPT.linttyp;
		MakeCon (con, OPT.linttyp, 0);
		Assign (lock, con);
	(* CMP DWORD 4[Reg0], 0 *)
		lock := self; lock.mode := RegRel; lock.offs := 4; lock.typ := OPT.linttyp;
		MakeCon (con, OPT.linttyp, 0);
		Cmp (z, lock, con, eql);
	(* JZ L3 *)
		L3 := Nil;
		Jcc (z, L3, NIL);
	(* Call Check *)
		GenPush (self);
		MakeCon (con, OPT.linttyp, 0); GenPush (con);
		GenCall (xcall, OPL.CheckIndex * 10000H + OPL.CheckEntryNr, 4, NIL);
		FixLink (L3);
	(* L2: *)
		FixLink (L2);
		Gen0(sti);

	END Unlock;
	
	PROCEDURE Passivate*(z, self, y: Item);	(* active only *)
	BEGIN

		IF z.typ = OPT.niltyp THEN
			MakeCon(z, OPT.linttyp, -1)
		ELSE
			GenLoadProc(ldProc, z, z.node.obj.adr MOD 10000H, z.node);		(* !! z is a local procedure !! *)
		END;
		GenPush(z);
		z.mode := Reg; z.adr := FP; GenPush(z);
		IF self.mode # Con THEN
		(* push address of the record *)
			IF self.typ.comp = Record THEN loadAdr (self) ELSE (*pointer*) load (self) END
		END;
		GenPush(self);
		GenPush(y);
		GenCall(xcall, OPL.PassivateIndex * 10000H + OPL.PassivateEntryNr, 8, NIL);

	END Passivate;
	
	PROCEDURE Activate*(z: Item);	(* active only *)
	BEGIN

		(* push address of the record *)
		IF z.typ.comp = Record THEN loadAdr (z) ELSE (*pointer*) load (z) END;
		GenPush (z);
		GenCall (xcall, OPL.ActivateIndex * 10000H + OPL.ActivateEntryNr, 4, NIL)

	END Activate;
(*
	PROCEDURE Terminate*(z: Item);	(* active only *)
	BEGIN
		(* push address of the record *)
		IF z.typ.comp = Record THEN loadAdr (z) ELSE (*pointer*) load (z) END;
		GenPush (z);
		GenCall (xcall, OPL.TerminateIndex * 10000H + OPL.TerminateEntryNr, 4, NIL)
	END Terminate;
*)
	PROCEDURE Trap* (n: LONGINT; node: OPT.Node); (* HALT (n) *)
	BEGIN
		Gen1 (trap, n, node)
	END Trap;

	PROCEDURE GenAsm* (n: OPT.Node);		(* iASM *)
	BEGIN
		Gen1(assembler, 0, n)
	END GenAsm;
	
	PROCEDURE GenDimTrap* (VAR len: Item);
		VAR const: Item;
	BEGIN
		IF inxchk THEN
			MakeCon (const, OPT.linttyp, -1(*0*));
			load (len);
			GenFlags (cmp, len, const);
			Gen1 (tle, OPL.DimTrap , NIL)
		END
	END GenDimTrap;

	PROCEDURE Case* (VAR x: Item; low, high: LONGINT; VAR tab: LONGINT; VAR L: Label; node: OPT.Node);
	(* optimize the case where CASE expr and expr is constant! *)
		VAR c, y: Item;
	BEGIN
		MakeCon (c, OPT.linttyp, low);
		IF x.typ.form # LInt THEN
			IF x.mode = Con THEN 
				x.typ := OPT.linttyp;
				load (x)
			ELSE Convert (x, LInt)
			END
		ELSE load (x)
		END;
		IF low # 0 THEN
			Gen3 (sub, x, x, c)
		END;
		c.adr := high-low;
		GenFlags (cmp, x, c);
		L := -2-pc; Gen1 (ja, Nil, node);
		OPL.AllocCaseTab (low, high, tab);
		c.mode := Abs; c.typ := OPT.linttyp; c.adr := tab; c.inx := x.adr; c.scale := OPO.Scale4; c.node := NIL;
		GenLoad (ld, y, c);
		Gen1 (jmpReg, y.adr, node)
	END Case;
	
	PROCEDURE CaseFixup* (tab: LONGINT; elseLabel: Label; len: LONGINT); (* case *)
	BEGIN
		InitInstr (case, 0, 0, NIL);
		OPL.Instr [pc].src1 := tab; OPL.Instr [pc].src2 := elseLabel; OPL.Instr [pc].inx := len * 4;
		INC (pc)
	END CaseFixup;


	PROCEDURE MoveToStack*(ret: OPT.Node; VAR ap: Item; fp: OPT.Object);
		VAR size, dest, listsize, sizeItem, temp: Item; staticsize, itemsize: LONGINT; done: BOOLEAN; step: SHORTINT;
	BEGIN
		listsize.mode:=0; staticsize:=0; RetListSize(listsize, staticsize, ret.link);
		dest.mode:=RegRel; dest.typ:=OPT.sysptrtyp; dest.mnolev:=level; dest.adr:=ESP; dest.offs:=ret.obj.adr+staticsize;
		IF listsize.mode=0 THEN dest.inx:=none ELSE dest.inx:=listsize.adr END;
		IF ret.typ.extlev=sdynamic THEN	(* move on the stack reserved space *)
			UndefBaseTypSize(sizeItem, ret.typ, itemsize, done); Step(itemsize, step);
			IF itemsize>1 THEN MakeCon(size, OPT.linttyp, itemsize); temp:=sizeItem; Mul(sizeItem, temp, size, LInt) END;
			temp:=dest; MoveBlock (temp, ap, sizeItem, step)
		ELSIF ret.typ.size#4 THEN
			MakeCon(size, OPT.linttyp, ret.typ.size); temp:=dest; MoveBlock(temp, ap, size, OPO.Bit8);
		ELSE
			temp:=dest; Move(temp, ap);
		END;
		IF ret.typ.extlev=sdynamic THEN
			IF CheckPtrToArray(ret.typ) THEN
				IF dest.inx=none THEN
					dest.typ:=ret.typ; CopyDynArr(dest);
					ap.mode:=RegRel; ap.typ:=ret.typ; ap.mnolev:=level; ap.inx:=none; ap.adr:=ESP; ap.offs:=ret.obj.adr+staticsize;
					IF fp.typ.extlev=dynamic THEN INC(ap.offs, fp.typ.size-4) END;
				ELSE
					temp:=dest; loadAdr(temp); OPL.Instr[temp.adr].hint:=OPL.useEAX; GenPush(temp);
					INC(dest.offs, 4); dest.typ:=ret.typ; CopyDynArr(dest);
					GenPop(ap); ap.mode:=Reg; ap.typ:=ret.typ
				END
			ELSE
				ap.mode:=RegRel; ap.typ:=ret.typ; ap.mnolev:=level; ap.inx:=none; ap.adr:=ESP; ap.offs:=ret.obj.adr+staticsize;
				IF fp.typ.extlev=dynamic THEN INC( ap.offs, fp.typ.size-4) END;
			END
		ELSIF ret.typ.form=Pointer THEN	(* dereferenced pointer to array *)
			IF dest.inx=none THEN
				IF initarr THEN dest.offs:=ret.obj.adr+staticsize; dest.typ:=ret.typ; CopyDynArr(dest) END;
				ap.offs:=ret.obj.adr+staticsize; ap.adr:=ESP				
			ELSE
				IF initarr THEN
					temp:=dest; loadAdr(temp); OPL.Instr[temp.adr].hint:=OPL.useEAX; GenPush(temp);
					INC(dest.offs, 4); dest.typ:=ret.typ; CopyDynArr(dest);
				END;
				GenPop(ap); ap.offs:=0	
			END;
			ap.mode:=RegRel; ap.typ:=OPT.sysptrtyp; ap.mnolev:=level; ap.inx:=none;
			load(ap); OPL.Instr[pc-1].hint:=OPL.useEAX;
			ap.typ:=ret.typ; ap.mode:=RegRel; ap.inx:=none; ap.scale:=noScale
		ELSIF (ret.typ.comp=Array)&(ret.typ.extlev=static) THEN
				IF dest.inx=none THEN
					IF CheckPtrToArray(ret.typ) THEN dest.offs:=ret.obj.adr+staticsize; dest.typ:=ret.typ; CopyDynArr(dest) END;
					ap.mode:=RegRel; ap.typ:=ret.typ; ap.mnolev:=level; ap.inx:=none;
					ap.adr:=ESP; ap.offs:=ret.obj.adr+staticsize+fp.typ.size-4
				ELSE
					IF CheckPtrToArray(ret.typ) THEN
						temp:=dest; loadAdr(temp); OPL.Instr[temp.adr].hint:=OPL.useEAX; GenPush(temp);
						INC(dest.offs, 4); dest.typ:=ret.typ; CopyDynArr(dest);
						GenPop(ap); ap.mode:=RegRel; ap.mnolev:=level; ap.inx:=none; ap.offs:=0
					ELSE
						ap:=dest; INC(ap.offs, fp.typ.size-4)
					END
				END;
			ap.typ:=ret.typ
		END
	END MoveToStack;


BEGIN
	MakeCon (True, OPT.booltyp, true);
	MakeCon (False, OPT.booltyp, false);
	Stack.mode := Reg; Stack.adr := ESP; Stack.node := NIL; Stack.typ := OPT.linttyp; Stack.offs := 0; Stack.inx := none;
	ebp.mode := Reg; ebp.adr := FP; ebp.node := NIL; ebp.typ := OPT.linttyp;
	formTab[Undef] := 0;
	formTab[Byte] := OPO.Bit8 DIV 8; formTab[Bool] := OPO.Bit8 DIV 8; 
	formTab[Char] := OPO.Bit8 DIV 8; formTab[SInt] := OPO.Bit8 DIV 8;
	formTab[Int] := OPO.Bit16 DIV 8;
	formTab[LInt] := OPO.Bit32; formTab[Set] := OPO.Bit32;
	formTab[Pointer] := OPO.Bit32; formTab[ProcTyp] := OPO.Bit32; 
	formTab[NilTyp] := OPO.Bit32; formTab[Comp] := OPO.Bit32;
	formTab[Real] := 3;
	formTab[LReal] := 4;
	CCtab[0,0] := EQ; CCtab [0,1] := NE; CCtab [0,2] := LT; CCtab [0,3] := LE; CCtab [0,4] := GT; CCtab [0,5] := GE;
	CCtab[1,0] := EQ; CCtab [1,1] := NE; CCtab [1,2] := BL; CCtab [1,3] := BE; CCtab [1,4] := AB; CCtab [1,5] := AE;
	InvCCtab [0] := NE; InvCCtab [1] := EQ; InvCCtab [2] := GE; InvCCtab [3] := GT; InvCCtab [4] := LE; InvCCtab [5] := LT;
	InvCCtab [6] := BE; InvCCtab [7] := BL; InvCCtab [8] := AE; InvCCtab [9] := AB; InvCCtab [10] := CC; InvCCtab [11] := CS;

END OPC.

