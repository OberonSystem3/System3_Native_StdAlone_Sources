(* OBERON System 3, Release 2.2.

Copyright 1997 Team of the Institute of Computer Systems of ETH Zuerich,
ETH Center, CH-8092 Zuerich, e-mail: oberon@inf.ethz.ch.

This module may be used under the conditions of the general Oberon 
System 3 license contract.  The full text can be requested from the 
above-mentioned address, or downloaded from

	"ftp://ftp.inf.ethz.ch/pub/software/Oberon/System3/license.txt;A"

Under the license terms stated it is in particular (a) prohibited to modify
the interface of this module in any way that disagrees with the style
or content of the system and (b) requested to provide all conversions
of the source code to another platform with the name OBERON. *)

MODULE Display;	
(* Type: 86C924					*)
(* Date: 23.4.93					*)
(* Author: A. R. Disteli			*)
(* Modified for Native Oberon: muller 25.07.95 *)
(* muller 08.02.96, ported to Native Oberon 2.05 *)
(* pjm 28.08.96, config *)

(*	Aenderungen gegenüber der	Version für den 86C805:		(cs/17.05.93)	*)

(*	-	PROCEDURE WaitFIFOempty:																	*)
(*		Statt immer auf eine leere FIFO zu warten, wird nur auf die benötigte	*)
(*		Anzahl freier Plätze gewartet. Aus Performancegründen wurden die 		 *)
(*		8 Fälle ausformuliert. (Dies erspart u.a. das Erstellen der Abfragemaske) *)

(*	-	fehlende WaitFIFO nachgetragen:																*)
(*		An diversen Stellen (v.a. in Schleifen) wurden fehlende Waits eingefügt. *)

(*	-	Initialisierung des Grafikmodus:																	*)
(*		Statt des VESA-Modus 105H und anschliessender S3-Aktivierung von		*)
(*		Hand wird direkt der S3-Modus 205H eingeschaltet.								 *)



	IMPORT SYSTEM, Objects, Kernel;
	
	CONST
		BG* = 0; FG* = 15; (*background, foreground*)
		replace* = 0; paint* = 1; invert* = 2; (*operation modes*)
		
		remove* = 0; suspend* = 1; restore* = 2; newprinter* = 3; (*ControlMsg id*)
		reduce* = 0; extend* = 1; move* = 2; (*ModifyMsg id*)
		display* = 0; state* = 1; (*ModifyMsg mode*)
		screen* = 0; printer* = 1; (* DisplayMsg device *)
		full* = 0; area* = 1; contents* = 2; (* DisplayMsg id. *)
		get* = 0; set* = 1; reset* = 2; (*SelectMsg id*)
		drop* = 0; integrate* = 1; (*ConsumeMsg id*)
		
		(* S3 Constants *)
		index = 3D4H;
		data = 3D5H;
		Xpos = 20H;
		Ypos = 80H;
		Ymajor = 40H;
		advFnCtrl = 4AE8H;
		curX = 86E8H;
		curY = 82E8H;
		axStep = 8AE8H;
		diaStep = 8EE8H;
		errTerm = 92E8H;
		majAxis = 96E8H;
		minAxis = 0BEE8H;
		gpStat = 9AE8H;
		cmdReg = 9AE8H;
		shortStroke = 9EE8H;
		BGcol = 0A2E8H;
		FGcol = 0A6E8H;
		wrtMask = 0AAE8H;
		rdMask = 0AEE8H;
		BGmix = 0B6E8H;
		FGmix = 0BAE8H;
		MFcont = 0BEE8H;
		pixTrans = 0E2E8H;

	TYPE Pattern* = LONGINT;
			PatternPtr = POINTER TO RECORD w, h, pixmap: SHORTINT END;
			List = POINTER TO ListDesc;
			ListDesc = RECORD
				next: List;
				pat: PatternPtr
			END;

			Frame* = POINTER TO FrameDesc;
			FrameDesc* = RECORD (Objects.ObjDesc)
				next*, dsc*: Frame;
				X*, Y*, W*, H*: INTEGER
			END;
	
			FrameMsg* = RECORD (Objects.ObjMsg)
				F*: Frame; (*target*)
				x*, y*, res*: INTEGER
			END;
		
			ControlMsg* = RECORD (FrameMsg)
				id*: INTEGER
			END;
		
			ModifyMsg* = RECORD (FrameMsg)
				id*, mode*: INTEGER;
				dX*, dY*, dW*, dH*: INTEGER;
				X*, Y*, W*, H*: INTEGER
			END;
		
			DisplayMsg* = RECORD (FrameMsg)
				device*: INTEGER;
				id*: INTEGER;
				u*, v*, w*, h*: INTEGER
			END;
		
			LocateMsg* = RECORD (FrameMsg)
				loc*: Frame;
				X*, Y*, u*, v*: INTEGER
			END;
		
			SelectMsg* = RECORD (FrameMsg)
				id*: INTEGER;
				time*: LONGINT;
				sel*: Frame;
				obj*: Objects.Object
			END;
		
			ConsumeMsg* = RECORD (FrameMsg)
				id*: INTEGER;
				u*, v*: INTEGER;
				obj*: Objects.Object
			END;
		
			MsgProc* = PROCEDURE (VAR M: FrameMsg);

	VAR
		Unit*: LONGINT; (* RasterUnit = Unit/36000 mm *)
		Left*, (* left margin of black-and-white maps *)
		ColLeft*, (* left margin of color maps *)
		Bottom*, (* bottom of primary map *)
		UBottom*, (* bottom of secondary map *)
		Width*, (* map width *)
		Height*: (* map hight*)
			INTEGER;
			
		arrow*, star*, cross*, downArrow*, hook*: Pattern;
		grey0*, grey1*, grey2*, ticks*, solid*: Pattern;

		Broadcast*: MsgProc;

		dmem, lasty: LONGINT;
		
		Pat: List;

		clipx, clipy, clipright, cliptop, height, width: INTEGER;	(* clipping variables *)
		pixctrl1, pixctrl2, copycmd: LONGINT;	
		mask: INTEGER;
		
	PROCEDURE WaitFIFO1;
	CODE
		MOV DX, 09AE8H
lab1:
		IN AX, DX
		AND AX, 0FFH-127
		JNZ lab1
	END WaitFIFO1;
	
	PROCEDURE WaitFIFO2;
	CODE
		MOV DX, 09AE8H
lab2:
		IN AX, DX
		AND AX, 0FFH-63
		JNZ lab2
	END WaitFIFO2;
	
	PROCEDURE WaitFIFO3;
	CODE
		MOV DX, 09AE8H
lab3:
		IN AX, DX
		AND AX, 0FFH-31
		JNZ lab3
	END WaitFIFO3;
	
	PROCEDURE WaitFIFO4;
	CODE
		MOV DX, 09AE8H
lab4:
		IN AX, DX
		AND AX, 0FFH-15
		JNZ lab4
	END WaitFIFO4;
	
	PROCEDURE WaitFIFO5;
	CODE
		MOV DX, 09AE8H
lab5:
		IN AX, DX
		AND AX, 0FFH-7
		JNZ lab5
	END WaitFIFO5;
	
	PROCEDURE WaitFIFO6;
	CODE
		MOV DX, 09AE8H
lab6:
		IN AX, DX
		AND AX, 0FFH-3
		JNZ lab6
	END WaitFIFO6;
	
	PROCEDURE WaitFIFO7;
	CODE
		MOV DX, 09AE8H
lab7:
		IN AX, DX
		AND AX, 0FFH-1
		JNZ lab7
	END WaitFIFO7;
	
	PROCEDURE WaitFIFO8;
	CODE
		MOV DX, 09AE8H
lab8:
		IN AX, DX
		AND AX, 0FFH
		JNZ lab8
	END WaitFIFO8;
	
	PROCEDURE EnableRegs;
	VAR i: INTEGER;
	BEGIN		
		WaitFIFO2;
		SYSTEM.PORTOUT(wrtMask, mask);		; (* Write mask *)
		SYSTEM.PORTOUT(rdMask, mask);		; (* Read mask *)
	END EnableRegs;
		
	PROCEDURE max (i, j: INTEGER): INTEGER; BEGIN IF i >= j THEN RETURN i ELSE RETURN j END END max;
	PROCEDURE min (i, j: INTEGER): INTEGER; BEGIN	IF i >= j THEN RETURN j ELSE RETURN i END END min;
		
	PROCEDURE Map*(X: INTEGER): LONGINT;
	BEGIN RETURN 0A0000H	(* Start of the video RAM *)
	END Map;
	
	PROCEDURE AdjustClip*(X, Y, W, H: INTEGER);
	VAR right, top, left, bottom: INTEGER;
	BEGIN 
		right := X + W; top := Y + H; clipx := max(clipx, X); clipy := max(clipy, Y); 
		clipright := min(right, clipright); cliptop := min(top, cliptop);
		top := height-1-cliptop; left := clipx; bottom := height-1-clipy; right := clipright-1;
		IF top < 0 THEN top := 0 ELSIF top > height-1 THEN top := height-1 END;
		IF left < 0 THEN left := 0 ELSIF left > width THEN left := width END;
		IF bottom < 0 THEN bottom := 0 ELSIF bottom > height-1 THEN bottom := height-1 END;
		IF right < 0 THEN right := 0 ELSIF right > width THEN right := width END;
		WaitFIFO4;
		SYSTEM.PORTOUT(MFcont, 1000H + top);	(* top *)
		SYSTEM.PORTOUT(MFcont, 2000H + left); 			 (* left *)
		SYSTEM.PORTOUT(MFcont, 3000H + bottom);	(* bottom *)
		SYSTEM.PORTOUT(MFcont, 4000H + right); 		 (* right *)
	END AdjustClip;

	PROCEDURE GetDim*(pat: Pattern; VAR w, h: INTEGER);
	VAR s: SHORTINT;
	BEGIN SYSTEM.GET(pat, s); w := s; SYSTEM.GET(pat+1, s); h := s; 
	END GetDim;

	PROCEDURE ResetClip*;
	BEGIN 
		clipx := 0; clipy := UBottom; 
		clipright := width;
		cliptop := height-1;
		WaitFIFO4;
		SYSTEM.PORTOUT(MFcont, 1000H);	(* top *)
		SYSTEM.PORTOUT(MFcont, 2000H);	(* left *)
		SYSTEM.PORTOUT(MFcont, 3000H + height-1-UBottom);	(* bottom *)
		SYSTEM.PORTOUT(MFcont, 4000H + width-1);	(* right *)
	END ResetClip;
	
	PROCEDURE SetClip*(x, y, w, h: INTEGER);
	VAR right, top, left, bottom: INTEGER;
	BEGIN	
		clipright := x+w;
		cliptop := y+h;
		clipy := y; clipx := x;
		top := height-1-cliptop; left := clipx; bottom := height-1-clipy; right := clipright-1;
		WaitFIFO4;
		SYSTEM.PORTOUT(MFcont, 1000H + top);	(* top *)
		SYSTEM.PORTOUT(MFcont, 2000H + left); 			 (* left *)
		SYSTEM.PORTOUT(MFcont, 3000H + bottom);	(* bottom *)
		SYSTEM.PORTOUT(MFcont, 4000H + right); 		 (* right *)
	END SetClip;
	
	PROCEDURE GetClip*(VAR x, y, w, h: INTEGER);
	BEGIN 
		x := clipx; y := clipy; w := clipright - clipx; h := cliptop - clipy
	END GetClip;

	PROCEDURE SetColor*(col, red, green, blue: INTEGER);	(* 0 <= col, red, green, blue < 256 *)
	VAR ch: CHAR;
	BEGIN
		IF (col = 0) OR (col = 15) THEN	(* either 0 or 15 must be black.  set the border to black. *)
				(* note: the S3 uses the palette for the border colour too *)
			SYSTEM.PORTIN(3DAH, ch);
			SYSTEM.PORTOUT(3C0H, 11X);
			IF (red = 0) & (green = 0) & (blue = 0) THEN SYSTEM.PORTOUT(3C0H, CHR(col))
			ELSE SYSTEM.PORTOUT(3C0H, CHR(15-col))
			END;
			SYSTEM.PORTOUT(3C0H, 20X)
		END;
		red := (red + 4) DIV 4 -1;
		green := (green + 4) DIV 4 -1;
		blue := (blue + 4) DIV 4 -1;
		SYSTEM.PORTOUT(3C8H, SHORT(col));
		SYSTEM.PORTOUT(3C9H, SHORT(red));
		SYSTEM.PORTOUT(3C9H, SHORT(green));
		SYSTEM.PORTOUT(3C9H, SHORT(blue))
	END SetColor;

	PROCEDURE GetColor*(col: INTEGER; VAR red, green, blue: INTEGER);
	VAR help: CHAR;
	BEGIN
		SYSTEM.PORTOUT(3C7H, SHORT(col));
		SYSTEM.PORTIN(3C9H, help); red := ORD(help);
		SYSTEM.PORTIN(3C9H, help); green := ORD(help);
		SYSTEM.PORTIN(3C9H, help); blue := ORD(help);
		red := red * 4 + red DIV 16;
		green := green * 4 + green DIV 16;
		blue := blue * 4 + blue DIV 16
	 END GetColor;
	
	PROCEDURE Dot*(col, x, y, mode: INTEGER);
	BEGIN
		y := Height-1-y; 
		WaitFIFO7;
		IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)) ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)) END;
		SYSTEM.PORTOUT(FGcol, col);
		SYSTEM.PORTOUT(MFcont, SHORT(pixctrl1));
		SYSTEM.PORTOUT(curX, x);
		SYSTEM.PORTOUT(curY, y);
		SYSTEM.PORTOUT(cmdReg, 121BH);
		SYSTEM.PORTOUT(shortStroke, LONG(10H));
	END Dot;

	PROCEDURE CopyBlock*(SX, SY, W, H, DX, DY, mode: INTEGER);
	VAR xpos, ypos: INTEGER;
	BEGIN
		IF (W > 0) & (H > 0) THEN
			xpos := 0; ypos := 0; 
			IF SY < DY THEN INC(SY, H-1); INC(DY, H-1); ypos := 128 END;
			IF SX < DX THEN INC(SX, W-1); INC(DX, W-1) ELSE xpos := 32 END;
			SY := Height - 1 - SY; DY := Height - 1 - DY;
			DEC(W); DEC(H); 
			WaitFIFO1;
			IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(65H)) ELSE SYSTEM.PORTOUT(FGmix, LONG(67H)) END;
			WaitFIFO8;
			SYSTEM.PORTOUT(MFcont, SHORT(pixctrl1));
			SYSTEM.PORTOUT(curX, SX);
			SYSTEM.PORTOUT(curY, SY);
			SYSTEM.PORTOUT(diaStep, DX);
			SYSTEM.PORTOUT(axStep, DY);
			SYSTEM.PORTOUT(majAxis, W);
			SYSTEM.PORTOUT(MFcont, H);
			SYSTEM.PORTOUT(cmdReg, SHORT(copycmd) + xpos + ypos)
		END
	END CopyBlock;

	PROCEDURE SetMode*(X: INTEGER; s: SET);
	BEGIN END SetMode;
	
	PROCEDURE CopyPattern*(col: INTEGER; pat: LONGINT; X, Y, mode: INTEGER);
	VAR width, height: SHORTINT; 
			diastep, axstep, errterm, bit16: INTEGER; 
			bit8: CHAR; bit24, bit32: SET;
	BEGIN
		SYSTEM.GET(pat, width);
		SYSTEM.GET(pat+1, height);
		INC(pat, 2);
		width := (width+7) DIV 8 * 8;
		axstep := 0;
		diastep := -2*width;
		errterm := -width-1;
		INC(X, LONG(width-1)); 
		Y := Height-1-Y;
		WaitFIFO8; 
		IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)); SYSTEM.PORTOUT(BGmix, LONG(3H)) 
		ELSIF mode = paint THEN SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(3H))
		ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(1H)) END;
		SYSTEM.PORTOUT(FGcol, col);
		SYSTEM.PORTOUT(MFcont, SHORT(pixctrl2));
		SYSTEM.PORTOUT(majAxis, LONG(width)-1);
		SYSTEM.PORTOUT(diaStep, diastep);
		SYSTEM.PORTOUT(axStep, axstep);
		SYSTEM.PORTOUT(errTerm, errterm);
		IF width <= 8 THEN
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit8); INC(pat);
				WaitFIFO4;
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 2313H);
				SYSTEM.PORTOUT(pixTrans, ORD(bit8) * 100H);
				DEC(Y);
			END
		ELSIF width <= 16 THEN
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit16); INC(pat, 2);
				WaitFIFO4;
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 2313H);
				SYSTEM.PORTOUT(pixTrans, bit16);
				DEC(Y);
			END
		ELSIF width <=24 THEN
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit24); INC(pat, 3);
				bit24 := SYSTEM.LSH(bit24 * {0 .. 23}, 8);
				bit24 := SYSTEM.ROT(bit24, 16);
				WaitFIFO5;
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 2313H);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit24*{0..15}));
				bit24 := SYSTEM.ROT(bit24, 16);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit24*{0..15}));
				DEC(Y);
			END
		ELSE
			WHILE height > 0 DO DEC(height);
				SYSTEM.GET(pat, bit32); INC(pat, 4);
				bit32 := SYSTEM.ROT(bit32, 16);
				WaitFIFO5;
				SYSTEM.PORTOUT(curX, X);
				SYSTEM.PORTOUT(curY, Y);
				SYSTEM.PORTOUT(cmdReg, 2313H);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit32*{0..15}));
				bit32 := SYSTEM.ROT(bit32, 16);
				SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, bit32*{0..15}));
				DEC(Y);
			END
		END;
	END CopyPattern;

	PROCEDURE ReplConst*(col, X, Y, W, H, mode: INTEGER);
	BEGIN
		IF (W > 0) & (H > 0) THEN 
			DEC(H); DEC(W); Y := Height-1-Y; 
			WaitFIFO8;
			IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)) ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)) END;
			SYSTEM.PORTOUT(FGcol, col);
			SYSTEM.PORTOUT(MFcont, SHORT(pixctrl1));
			SYSTEM.PORTOUT(curX, X);
			SYSTEM.PORTOUT(curY, Y);
			SYSTEM.PORTOUT(majAxis, W);
			SYSTEM.PORTOUT(minAxis, H);
			SYSTEM.PORTOUT(cmdReg, 4073H)
		END
	END ReplConst;

	PROCEDURE FillPattern*(col: INTEGER; pat: Pattern; pX, pY, X, Y, W, H, mode: INTEGER);
		VAR patwidth, patheight: SHORTINT; 
			diastep, axstep, errterm, bit16: INTEGER; 
			offset, W0, Y0, X0: INTEGER; 
			pat0, bit32: LONGINT;
			wth, hgt: INTEGER;
	BEGIN 
		IF (W > 0) & (H > 0) THEN 
			SYSTEM.GET(pat, patwidth);
			SYSTEM.GET(pat+1, patheight);
			INC(pat, 2);
			wth := (W+7) DIV 8 * 8;	(* nof complete bytes *)
			axstep := 0;
			diastep := -2*wth;
			errterm := -wth-1;
			INC(X, W-1); 
			Y0 := Y; X0 := X; Y := Height-1-Y;
			WaitFIFO8;
			IF mode = invert THEN SYSTEM.PORTOUT(FGmix, LONG(25H)); SYSTEM.PORTOUT(BGmix, LONG(3H)) 
			ELSIF mode = paint THEN SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(3H))
			ELSE SYSTEM.PORTOUT(FGmix, LONG(27H)); SYSTEM.PORTOUT(BGmix, LONG(1H)) END;
			SYSTEM.PORTOUT(FGcol, col);
			SYSTEM.PORTOUT(MFcont, SHORT(pixctrl2));
			SYSTEM.PORTOUT(majAxis, W-1);
			SYSTEM.PORTOUT(diaStep, diastep);
			SYSTEM.PORTOUT(axStep, axstep);
			SYSTEM.PORTOUT(errTerm, errterm);
			pat0 := pat; W0 := W;
			hgt := patheight - (Y0 + pY) MOD patheight;
			offset := (Y0 + pY) MOD patheight;
			IF patwidth = 16 THEN
				pat := pat + 2*offset;
				WHILE H > 0 DO 
					W := (W + 7) DIV 8 * 4;
					SYSTEM.GET(pat, bit16); INC(pat, 2);
					bit16 := SYSTEM.ROT(bit16, pX-X0);
					WaitFIFO3;
					SYSTEM.PORTOUT(curX, X);
					SYSTEM.PORTOUT(curY, Y);
					SYSTEM.PORTOUT(cmdReg, 2313H);
					WHILE W > 0 DO
						WaitFIFO1;
						SYSTEM.PORTOUT(pixTrans, bit16);
						DEC(W,2);
					END;
					DEC(Y);
					DEC(H); DEC(hgt); W := W0;
					IF hgt <= 0 THEN hgt := patheight; pat := pat0 END;
				END
			ELSIF patwidth = 32 THEN
				pat := pat + 4*offset;
				WHILE H > 0 DO 
					W := (W + 7) DIV 8 * 2;
					SYSTEM.GET(pat, bit32); INC(pat, 4);
					bit32 := SYSTEM.ROT(bit32, pX-X0+16);
					WaitFIFO3;
					SYSTEM.PORTOUT(curX, X);
					SYSTEM.PORTOUT(curY, Y);
					SYSTEM.PORTOUT(cmdReg, 2313H);
					WHILE W > 0 DO
						WaitFIFO2;
						SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, bit32)*{0..15}));
						bit32 := SYSTEM.ROT(bit32, 16);
						SYSTEM.PORTOUT(pixTrans, SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, bit32)*{0..15}));
						DEC(W,4)
					END;
					DEC(Y);
					DEC(H); DEC(hgt); W := W0;
					IF hgt <= 0 THEN hgt := patheight; pat := pat0 END
				END
			END
		END
	END FillPattern;
	
	PROCEDURE ReplPattern*(col: INTEGER; pat: Pattern; X, Y, W, H, mode: INTEGER);
	BEGIN FillPattern(col, pat, 0, 0, X, Y, W, H, mode)
	END ReplPattern;

	PROCEDURE NewPattern*(width, height: INTEGER; VAR image: ARRAY OF SET): Pattern;
	VAR len, src, dest: LONGINT; i: INTEGER; p: PatternPtr; inter: SET;  pl: List;
	BEGIN 
		len := (width+7) DIV 8;
		SYSTEM.NEW(p, 4+len*height); p.w := SHORT(width); p.h := SHORT(height);
		src := SYSTEM.ADR(image); dest := SYSTEM.ADR(p.pixmap);
		i := 0;
		WHILE i < height DO SYSTEM.MOVE(src, dest, len); INC(src, 4); INC(dest, len); INC(i) END;
		NEW(pl);  pl.pat := p;  pl.next := Pat;  Pat := pl;	(* put in list to avoid GC *)
		RETURN SYSTEM.ADR(p.w)
	END NewPattern;
	
	PROCEDURE CreatePatterns;
	VAR image: ARRAY 16 OF SET;
	BEGIN
		image[0] := {13};
		image[1] := {12..14};
		image[2] := {11..13};
		image[3] := {10..12};
		image[4] := {9..11};
		image[5] := {8..10};
		image[6] := {7..9};
		image[7] := {0, 6..8};
		image[8] := {0, 1, 5..7};
		image[9] := {0..2, 4..6};
		image[10] := {0..5};
		image[11] := {0..4};
		image[12] := {0..5};
		image[13] := {0..6};
		image[14] := {0..7};
		arrow := NewPattern(15, 15, image);
		
		image[0] := {0, 10};
		image[1] := {1, 9};
		image[2] := {2, 8};
		image[3] := {3, 7};
		image[4] := {4, 6};
		image[5] := {};
		image[6] := {4, 6};
		image[7] := {3, 7};
		image[8] := {2, 8};
		image[9] := {1, 9};
		image[10] := {0, 10};
		cross := NewPattern(11, 11, image); 
		
		image[0] := {6};
		image[1] := {5..7};
		image[2] := {4..8};
		image[3] := {3..9};
		image[4] := {2..10};
		image[5] := {5..7};
		image[6] := {5..7};
		image[7] := {5..7};
		image[8] := {5..7};
		image[9] := {5..7};
		image[10] := {5..7};
		image[11] := {5..7};
		image[12] := {5..7};
		image[13] := {5..7};
		image[14] := {};
		downArrow := NewPattern(15, 15, image);
		
		image[0] := {0, 4, 8, 12};
		image[1] := {};
		image[2] := {2, 6, 10, 14};
		image[3] := {};
		image[4] := {0, 4, 8, 12};
		image[5] := {};
		image[6] := {2, 6, 10, 14};
		image[7] := {};
		image[8] := {0, 4, 8, 12};
		image[9] := {};
		image[10] := {2, 6, 10, 14};
		image[11] := {};
		image[12] := {0, 4, 8, 12};
		image[13] := {};
		image[14] := {2, 6, 10, 14};
		image[15] := {};
		grey0 := NewPattern(16, 16, image);
		
		image[0] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[1] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[2] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[3] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[4] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[5] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[6] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[7] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[8] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[9] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[10] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[11] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[12] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[13] := {1, 3, 5, 7, 9, 11, 13, 15};
		image[14] := {0, 2, 4, 6, 8, 10, 12, 14};
		image[15] := {1, 3, 5, 7, 9, 11, 13, 15};
		grey1 := NewPattern(16, 16, image);
		
		image[0] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[1] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[2] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[3] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[4] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[5] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[6] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[7] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[8] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[9] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[10] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[11] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[12] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[13] := {0, 1, 4, 5, 8, 9, 12, 13};
		image[14] := {2, 3, 6, 7, 10, 11, 14, 15};
		image[15] := {2, 3, 6, 7, 10, 11, 14, 15};
		grey2 := NewPattern(16, 16, image);
		
		image[0] := {0..2, 8..11};
		image[1] := {0..2, 7..10};
		image[2] := {0..2, 6..9};
		image[3] := {0..2, 5..8};
		image[4] := {0..2, 4..7};
		image[5] := {0..6};
		image[6] := {0..5};
		image[7] := {0..4};
		image[8] := {0..3};
		image[9] := {0..2};
		image[10] := {0, 1};
		image[11] := {0};
		hook := NewPattern(12, 12, image);
		
		image[0] := {7};
		image[1] := {7};
		image[2] := {2, 7, 12};
		image[3] := {3, 7, 11};
		image[4] := {4, 7, 10};
		image[5] := {5, 7, 9};
		image[6] := {6..8};
		image[7] := {0..6, 8..14};
		image[8] := {6..8};
		image[9] := {5, 7, 9};
		image[10] := {4, 7, 10};
		image[11] := {3, 7, 11};
		image[12] := {2, 7, 12};
		image[13] := {7};
		image[14] := {7};
		star := NewPattern(15, 15, image);
		
		image[0] := {};
		image[1] := {};
		image[2] := {0};
		image[3] := {};
		image[4] := {};
		image[5] := {};
		image[6] := {};
		image[7] := {};
		image[8] := {};
		image[9] := {};
		image[10] := {};
		image[11] := {};
		image[12] := {};
		image[13] := {};
		image[14] := {};
		image[15] := {};
		ticks := NewPattern(16, 16, image);
		
		image[0] := -{};
		image[1] := -{};
		solid := NewPattern(16, 2, image);
		
	END CreatePatterns;
	
	PROCEDURE Depth*(X: INTEGER): INTEGER;
	BEGIN RETURN 8 END Depth;
	
	PROCEDURE DisplayBlock*(B:LONGINT; DX, DY, W, H, SX, SY, mode:INTEGER);
	VAR BitmapWth, locW, locH: LONGINT;
	CODE
		MOVSX EAX, Width
		MOV locW[EBP], EAX	; locW := Width
		
		MOVSX EAX, Height
		DEC EAX
		DEC EAX
		MOV locH[EBP], EAX	; locH := Height-2
		
		MOVSX EAX, SY[EBP]
		MOV DWORD SY[EBP], EAX
		
		MOV ESI, B[EBP]    		; address of bitmap descriptor
		MOV EDI, 12[ESI]
		MOV ESI, 8[ESI] 
		MOV BitmapWth[EBP], ESI
		MOVZX ECX, DY[EBP]
		IMUL ESI,ECX
		MOVZX EBX, WORD 32[EBP]	; DX
		ADD ESI, EBX	
		ADD ESI, EDI				; esi = source index register
		MOV EDI, locW[EBP]
		MOV EBX, locH[EBP]
		DEC EBX										;!!!!
		SUB EBX,DWORD SY[EBP]
		IMUL EDI,EBX 
		MOVZX EBX, SX[EBP]
		ADD EDI, EBX				; edi = destination index register without VGAaddr
		MOV EAX, locH[EBP]
		SUB AX, SY[EBP]
		MOV SY[EBP], AX
		
		MOV DX, 9AE8H
lab1:
		IN AX, DX
		AND AX, 100H
		JNZ lab1
		
		CMP mode[EBP], 1
		JL repllab
		JG invlab
		MOV AX, 4BH
		JMP contlab
repllab:
		MOV AX, 47H
		JMP contlab
invlab:
		MOV AX, 45H
contlab:
		MOV DX, 0BAE8H
		OUT DX, AX
		
		MOV DX, 0BEE8H
		MOV AX, 0A000H
		OUT DX, AX
		
		MOV DX, 086E8H
		MOV AX, SX[EBP]
		OUT DX, AX
		MOV DX, 082E8H
		MOV AX, SY[EBP]
		OUT DX, AX
		
		MOV DX, 096E8H
		MOV AX, W[EBP]
		DEC AX
		OUT DX, AX
		
		MOV DX, 0BEE8H
		MOV AX, H[EBP]
		DEC AX
		OUT DX, AX
		
		MOV DX, 09AE8H
		MOV AX, 05331H
		OUT DX, AX
		
		MOV DX, 0E2E8H
		
RowLoopR:
		MOV CX, W[EBP]
		INC CX
		SHR CX, 1
		PUSH ESI
lab2:
		MOV AX, [ESI]
		OUT DX, AX
		INC ESI
		INC ESI
		DEC CX
		JNZ lab2
		POP ESI
		ADD ESI, BitmapWth[EBP]
		DEC H[EBP]
		JNZ RowLoopR
DispEnd:
	END DisplayBlock;
	
	PROCEDURE GetVal(str: ARRAY OF CHAR): LONGINT;
	VAR i: SHORTINT;  v, sgn: LONGINT;  s: ARRAY 10 OF CHAR;
	BEGIN
		Kernel.GetConfig(str, s);
		v := 0;  i := 0;
		WHILE s[i] # 0X DO v := v*10+(ORD(s[i])-48); INC(i) END;
		RETURN v
	END GetVal;

BEGIN
	Width := SHORT(GetVal("DWidth"));
	IF Width = 0 THEN Width := 1024 END;	(* assume 1024 if not specified *)
	Height := SHORT(GetVal("DHeight"));
	IF Height = 0 THEN Height := 768 END;	(* assume 768 if not specified *)
	dmem := GetVal("DMem")*1024;
	IF dmem = 0 THEN dmem := 1024*1024 END;	(* assume 1Mb if not specified *)
	UBottom := Height - SHORT(dmem DIV Width) + 1;
	Left:= 0; ColLeft:= 0; Bottom:= 0; 
	Pat := NIL;
	mask := -1; pixctrl1 := 0A000H; pixctrl2 := 0A080H; copycmd := 0C053H;
	EnableRegs;
	width := Width;
	height := Height;
	ResetClip;
	CreatePatterns;
	Unit := 10000
END Display.
